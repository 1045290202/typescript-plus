/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

declare namespace ts {
    namespace server {
        /** @internal */
        function hasArgument(argumentName: string): boolean;
        /** @internal */
        function findArgument(argumentName: string): string | undefined;
        /** @internal */
        function nowString(): string;
        type ActionSet = "action::set";
        /** @internal */
        const ActionSet: ActionSet;
        type ActionInvalidate = "action::invalidate";
        /** @internal */
        const ActionInvalidate: ActionInvalidate;
        type ActionPackageInstalled = "action::packageInstalled";
        /** @internal */
        const ActionPackageInstalled: ActionPackageInstalled;
        type EventTypesRegistry = "event::typesRegistry";
        /** @internal */
        const EventTypesRegistry: EventTypesRegistry;
        type EventBeginInstallTypes = "event::beginInstallTypes";
        /** @internal */
        const EventBeginInstallTypes: EventBeginInstallTypes;
        type EventEndInstallTypes = "event::endInstallTypes";
        /** @internal */
        const EventEndInstallTypes: EventEndInstallTypes;
        type EventInitializationFailed = "event::initializationFailed";
        /** @internal */
        const EventInitializationFailed: EventInitializationFailed;
        /** @internal */
        namespace Arguments {
            const GlobalCacheLocation = "--globalTypingsCacheLocation";
            const LogFile = "--logFile";
            const EnableTelemetry = "--enableTelemetry";
            const TypingSafeListLocation = "--typingSafeListLocation";
            const TypesMapLocation = "--typesMapLocation";
            /**
             * This argument specifies the location of the NPM executable.
             * typingsInstaller will run the command with `${npmLocation} install ...`.
             */
            const NpmLocation = "--npmLocation";
            /**
             * Flag indicating that the typings installer should try to validate the default npm location.
             * If the default npm is not found when this flag is enabled, fallback to `npm install`
             */
            const ValidateDefaultNpmLocation = "--validateDefaultNpmLocation";
        }
        interface TypingInstallerResponse {
            readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed;
        }
        interface TypingInstallerRequestWithProjectName {
            readonly projectName: string;
        }
        /** @internal */
        type TypingInstallerRequestUnion = DiscoverTypings | CloseProject | TypesRegistryRequest | InstallPackageRequest;
        interface DiscoverTypings extends TypingInstallerRequestWithProjectName {
            readonly fileNames: string[];
            readonly projectRootPath: Path;
            readonly compilerOptions: CompilerOptions;
            readonly watchOptions?: WatchOptions;
            readonly typeAcquisition: TypeAcquisition;
            readonly unresolvedImports: SortedReadonlyArray<string>;
            readonly cachePath?: string;
            readonly kind: "discover";
        }
        interface CloseProject extends TypingInstallerRequestWithProjectName {
            readonly kind: "closeProject";
        }
        interface TypesRegistryRequest {
            readonly kind: "typesRegistry";
        }
        interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {
            readonly kind: "installPackage";
            readonly fileName: Path;
            readonly packageName: string;
            readonly projectRootPath: Path;
        }
        /** @internal */
        interface TypesRegistryResponse extends TypingInstallerResponse {
            readonly kind: EventTypesRegistry;
            readonly typesRegistry: MapLike<MapLike<string>>;
        }
        interface PackageInstalledResponse extends ProjectResponse {
            readonly kind: ActionPackageInstalled;
            readonly success: boolean;
            readonly message: string;
        }
        interface InitializationFailedResponse extends TypingInstallerResponse {
            readonly kind: EventInitializationFailed;
            readonly message: string;
            readonly stack?: string;
        }
        interface ProjectResponse extends TypingInstallerResponse {
            readonly projectName: string;
        }
        interface InvalidateCachedTypings extends ProjectResponse {
            readonly kind: ActionInvalidate;
        }
        interface InstallTypes extends ProjectResponse {
            readonly kind: EventBeginInstallTypes | EventEndInstallTypes;
            readonly eventId: number;
            readonly typingsInstallerVersion: string;
            readonly packagesToInstall: readonly string[];
        }
        interface BeginInstallTypes extends InstallTypes {
            readonly kind: EventBeginInstallTypes;
        }
        interface EndInstallTypes extends InstallTypes {
            readonly kind: EventEndInstallTypes;
            readonly installSuccess: boolean;
        }
        /** @internal */
        interface InstallTypingHost extends JsTyping.TypingResolutionHost {
            useCaseSensitiveFileNames: boolean;
            writeFile(path: string, content: string): void;
            createDirectory(path: string): void;
            getCurrentDirectory?(): string;
            watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
            watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
        }
        interface SetTypings extends ProjectResponse {
            readonly typeAcquisition: TypeAcquisition;
            readonly compilerOptions: CompilerOptions;
            readonly typings: string[];
            readonly unresolvedImports: SortedReadonlyArray<string>;
            readonly kind: ActionSet;
        }
        /** @internal */
        type TypingInstallerResponseUnion = SetTypings | InvalidateCachedTypings | TypesRegistryResponse | PackageInstalledResponse | InstallTypes | InitializationFailedResponse;
        namespace protocol {
            enum CommandTypes {
                JsxClosingTag = "jsxClosingTag",
                Brace = "brace",
                /** @internal */
                BraceFull = "brace-full",
                BraceCompletion = "braceCompletion",
                GetSpanOfEnclosingComment = "getSpanOfEnclosingComment",
                Change = "change",
                Close = "close",
                /** @deprecated Prefer CompletionInfo -- see comment on CompletionsResponse */
                Completions = "completions",
                CompletionInfo = "completionInfo",
                /** @internal */
                CompletionsFull = "completions-full",
                CompletionDetails = "completionEntryDetails",
                /** @internal */
                CompletionDetailsFull = "completionEntryDetails-full",
                CompileOnSaveAffectedFileList = "compileOnSaveAffectedFileList",
                CompileOnSaveEmitFile = "compileOnSaveEmitFile",
                Configure = "configure",
                Definition = "definition",
                /** @internal */
                DefinitionFull = "definition-full",
                DefinitionAndBoundSpan = "definitionAndBoundSpan",
                /** @internal */
                DefinitionAndBoundSpanFull = "definitionAndBoundSpan-full",
                Implementation = "implementation",
                /** @internal */
                ImplementationFull = "implementation-full",
                /** @internal */
                EmitOutput = "emit-output",
                Exit = "exit",
                FileReferences = "fileReferences",
                /** @internal */
                FileReferencesFull = "fileReferences-full",
                Format = "format",
                Formatonkey = "formatonkey",
                /** @internal */
                FormatFull = "format-full",
                /** @internal */
                FormatonkeyFull = "formatonkey-full",
                /** @internal */
                FormatRangeFull = "formatRange-full",
                Geterr = "geterr",
                GeterrForProject = "geterrForProject",
                SemanticDiagnosticsSync = "semanticDiagnosticsSync",
                SyntacticDiagnosticsSync = "syntacticDiagnosticsSync",
                SuggestionDiagnosticsSync = "suggestionDiagnosticsSync",
                NavBar = "navbar",
                /** @internal */
                NavBarFull = "navbar-full",
                Navto = "navto",
                /** @internal */
                NavtoFull = "navto-full",
                NavTree = "navtree",
                NavTreeFull = "navtree-full",
                /** @deprecated */
                Occurrences = "occurrences",
                DocumentHighlights = "documentHighlights",
                /** @internal */
                DocumentHighlightsFull = "documentHighlights-full",
                Open = "open",
                Quickinfo = "quickinfo",
                /** @internal */
                QuickinfoFull = "quickinfo-full",
                References = "references",
                /** @internal */
                ReferencesFull = "references-full",
                Reload = "reload",
                Rename = "rename",
                /** @internal */
                RenameInfoFull = "rename-full",
                /** @internal */
                RenameLocationsFull = "renameLocations-full",
                Saveto = "saveto",
                SignatureHelp = "signatureHelp",
                /** @internal */
                SignatureHelpFull = "signatureHelp-full",
                FindSourceDefinition = "findSourceDefinition",
                Status = "status",
                TypeDefinition = "typeDefinition",
                ProjectInfo = "projectInfo",
                ReloadProjects = "reloadProjects",
                Unknown = "unknown",
                OpenExternalProject = "openExternalProject",
                OpenExternalProjects = "openExternalProjects",
                CloseExternalProject = "closeExternalProject",
                /** @internal */
                SynchronizeProjectList = "synchronizeProjectList",
                /** @internal */
                ApplyChangedToOpenFiles = "applyChangedToOpenFiles",
                UpdateOpen = "updateOpen",
                /** @internal */
                EncodedSyntacticClassificationsFull = "encodedSyntacticClassifications-full",
                /** @internal */
                EncodedSemanticClassificationsFull = "encodedSemanticClassifications-full",
                /** @internal */
                Cleanup = "cleanup",
                GetOutliningSpans = "getOutliningSpans",
                /** @internal */
                GetOutliningSpansFull = "outliningSpans",
                TodoComments = "todoComments",
                Indentation = "indentation",
                DocCommentTemplate = "docCommentTemplate",
                /** @internal */
                CompilerOptionsDiagnosticsFull = "compilerOptionsDiagnostics-full",
                /** @internal */
                NameOrDottedNameSpan = "nameOrDottedNameSpan",
                /** @internal */
                BreakpointStatement = "breakpointStatement",
                CompilerOptionsForInferredProjects = "compilerOptionsForInferredProjects",
                GetCodeFixes = "getCodeFixes",
                /** @internal */
                GetCodeFixesFull = "getCodeFixes-full",
                GetCombinedCodeFix = "getCombinedCodeFix",
                /** @internal */
                GetCombinedCodeFixFull = "getCombinedCodeFix-full",
                ApplyCodeActionCommand = "applyCodeActionCommand",
                GetSupportedCodeFixes = "getSupportedCodeFixes",
                GetApplicableRefactors = "getApplicableRefactors",
                GetEditsForRefactor = "getEditsForRefactor",
                /** @internal */
                GetEditsForRefactorFull = "getEditsForRefactor-full",
                OrganizeImports = "organizeImports",
                /** @internal */
                OrganizeImportsFull = "organizeImports-full",
                GetEditsForFileRename = "getEditsForFileRename",
                /** @internal */
                GetEditsForFileRenameFull = "getEditsForFileRename-full",
                ConfigurePlugin = "configurePlugin",
                SelectionRange = "selectionRange",
                /** @internal */
                SelectionRangeFull = "selectionRange-full",
                ToggleLineComment = "toggleLineComment",
                /** @internal */
                ToggleLineCommentFull = "toggleLineComment-full",
                ToggleMultilineComment = "toggleMultilineComment",
                /** @internal */
                ToggleMultilineCommentFull = "toggleMultilineComment-full",
                CommentSelection = "commentSelection",
                /** @internal */
                CommentSelectionFull = "commentSelection-full",
                UncommentSelection = "uncommentSelection",
                /** @internal */
                UncommentSelectionFull = "uncommentSelection-full",
                PrepareCallHierarchy = "prepareCallHierarchy",
                ProvideCallHierarchyIncomingCalls = "provideCallHierarchyIncomingCalls",
                ProvideCallHierarchyOutgoingCalls = "provideCallHierarchyOutgoingCalls",
                ProvideInlayHints = "provideInlayHints"
            }
            /**
             * A TypeScript Server message
             */
            interface Message {
                /**
                 * Sequence number of the message
                 */
                seq: number;
                /**
                 * One of "request", "response", or "event"
                 */
                type: "request" | "response" | "event";
            }
            /**
             * Client-initiated request message
             */
            interface Request extends Message {
                type: "request";
                /**
                 * The command to execute
                 */
                command: string;
                /**
                 * Object containing arguments for the command
                 */
                arguments?: any;
            }
            /**
             * Request to reload the project structure for all the opened files
             */
            interface ReloadProjectsRequest extends Message {
                command: CommandTypes.ReloadProjects;
            }
            /**
             * Server-initiated event message
             */
            interface Event extends Message {
                type: "event";
                /**
                 * Name of event
                 */
                event: string;
                /**
                 * Event-specific information
                 */
                body?: any;
            }
            /**
             * Response by server to client request message.
             */
            interface Response extends Message {
                type: "response";
                /**
                 * Sequence number of the request message.
                 */
                request_seq: number;
                /**
                 * Outcome of the request.
                 */
                success: boolean;
                /**
                 * The command requested.
                 */
                command: string;
                /**
                 * If success === false, this should always be provided.
                 * Otherwise, may (or may not) contain a success message.
                 */
                message?: string;
                /**
                 * Contains message body if success === true.
                 */
                body?: any;
                /**
                 * Contains extra information that plugin can include to be passed on
                 */
                metadata?: unknown;
                /**
                 * Exposes information about the performance of this request-response pair.
                 */
                performanceData?: PerformanceData;
            }
            interface PerformanceData {
                /**
                 * Time spent updating the program graph, in milliseconds.
                 */
                updateGraphDurationMs?: number;
                /**
                 * The time spent creating or updating the auto-import program, in milliseconds.
                 */
                createAutoImportProviderProgramDurationMs?: number;
            }
            /**
             * Arguments for FileRequest messages.
             */
            interface FileRequestArgs {
                /**
                 * The file for the request (absolute pathname required).
                 */
                file: string;
                projectFileName?: string;
            }
            interface StatusRequest extends Request {
                command: CommandTypes.Status;
            }
            interface StatusResponseBody {
                /**
                 * The TypeScript version (`ts.version`).
                 */
                version: string;
            }
            /**
             * Response to StatusRequest
             */
            interface StatusResponse extends Response {
                body: StatusResponseBody;
            }
            /**
             * Requests a JS Doc comment template for a given position
             */
            interface DocCommentTemplateRequest extends FileLocationRequest {
                command: CommandTypes.DocCommentTemplate;
            }
            /**
             * Response to DocCommentTemplateRequest
             */
            interface DocCommandTemplateResponse extends Response {
                body?: TextInsertion;
            }
            /**
             * A request to get TODO comments from the file
             */
            interface TodoCommentRequest extends FileRequest {
                command: CommandTypes.TodoComments;
                arguments: TodoCommentRequestArgs;
            }
            /**
             * Arguments for TodoCommentRequest request.
             */
            interface TodoCommentRequestArgs extends FileRequestArgs {
                /**
                 * Array of target TodoCommentDescriptors that describes TODO comments to be found
                 */
                descriptors: TodoCommentDescriptor[];
            }
            /**
             * Response for TodoCommentRequest request.
             */
            interface TodoCommentsResponse extends Response {
                body?: TodoComment[];
            }
            /**
             * A request to determine if the caret is inside a comment.
             */
            interface SpanOfEnclosingCommentRequest extends FileLocationRequest {
                command: CommandTypes.GetSpanOfEnclosingComment;
                arguments: SpanOfEnclosingCommentRequestArgs;
            }
            interface SpanOfEnclosingCommentRequestArgs extends FileLocationRequestArgs {
                /**
                 * Requires that the enclosing span be a multi-line comment, or else the request returns undefined.
                 */
                onlyMultiLine: boolean;
            }
            /**
             * Request to obtain outlining spans in file.
             */
            interface OutliningSpansRequest extends FileRequest {
                command: CommandTypes.GetOutliningSpans;
            }
            interface OutliningSpan {
                /** The span of the document to actually collapse. */
                textSpan: TextSpan;
                /** The span of the document to display when the user hovers over the collapsed span. */
                hintSpan: TextSpan;
                /** The text to display in the editor for the collapsed region. */
                bannerText: string;
                /**
                 * Whether or not this region should be automatically collapsed when
                 * the 'Collapse to Definitions' command is invoked.
                 */
                autoCollapse: boolean;
                /**
                 * Classification of the contents of the span
                 */
                kind: OutliningSpanKind;
            }
            /**
             * Response to OutliningSpansRequest request.
             */
            interface OutliningSpansResponse extends Response {
                body?: OutliningSpan[];
            }
            /**
             * Request to obtain outlining spans in file.
             *
             * @internal
             */
            interface OutliningSpansRequestFull extends FileRequest {
                command: CommandTypes.GetOutliningSpansFull;
            }
            /**
             * Response to OutliningSpansRequest request.
             *
             * @internal
             */
            interface OutliningSpansResponseFull extends Response {
                body?: ts.OutliningSpan[];
            }
            /**
             * A request to get indentation for a location in file
             */
            interface IndentationRequest extends FileLocationRequest {
                command: CommandTypes.Indentation;
                arguments: IndentationRequestArgs;
            }
            /**
             * Response for IndentationRequest request.
             */
            interface IndentationResponse extends Response {
                body?: IndentationResult;
            }
            /**
             * Indentation result representing where indentation should be placed
             */
            interface IndentationResult {
                /**
                 * The base position in the document that the indent should be relative to
                 */
                position: number;
                /**
                 * The number of columns the indent should be at relative to the position's column.
                 */
                indentation: number;
            }
            /**
             * Arguments for IndentationRequest request.
             */
            interface IndentationRequestArgs extends FileLocationRequestArgs {
                /**
                 * An optional set of settings to be used when computing indentation.
                 * If argument is omitted - then it will use settings for file that were previously set via 'configure' request or global settings.
                 */
                options?: EditorSettings;
            }
            /**
             * Arguments for ProjectInfoRequest request.
             */
            interface ProjectInfoRequestArgs extends FileRequestArgs {
                /**
                 * Indicate if the file name list of the project is needed
                 */
                needFileNameList: boolean;
            }
            /**
             * A request to get the project information of the current file.
             */
            interface ProjectInfoRequest extends Request {
                command: CommandTypes.ProjectInfo;
                arguments: ProjectInfoRequestArgs;
            }
            /**
             * A request to retrieve compiler options diagnostics for a project
             */
            interface CompilerOptionsDiagnosticsRequest extends Request {
                arguments: CompilerOptionsDiagnosticsRequestArgs;
            }
            /**
             * Arguments for CompilerOptionsDiagnosticsRequest request.
             */
            interface CompilerOptionsDiagnosticsRequestArgs {
                /**
                 * Name of the project to retrieve compiler options diagnostics.
                 */
                projectFileName: string;
            }
            /**
             * Response message body for "projectInfo" request
             */
            interface ProjectInfo {
                /**
                 * For configured project, this is the normalized path of the 'tsconfig.json' file
                 * For inferred project, this is undefined
                 */
                configFileName: string;
                /**
                 * The list of normalized file name in the project, including 'lib.d.ts'
                 */
                fileNames?: string[];
                /**
                 * Indicates if the project has a active language service instance
                 */
                languageServiceDisabled?: boolean;
            }
            /**
             * Represents diagnostic info that includes location of diagnostic in two forms
             * - start position and length of the error span
             * - startLocation and endLocation - a pair of Location objects that store start/end line and offset of the error span.
             */
            interface DiagnosticWithLinePosition {
                message: string;
                start: number;
                length: number;
                startLocation: Location;
                endLocation: Location;
                category: string;
                code: number;
                /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */
                reportsUnnecessary?: {};
                reportsDeprecated?: {};
                relatedInformation?: DiagnosticRelatedInformation[];
            }
            /**
             * Response message for "projectInfo" request
             */
            interface ProjectInfoResponse extends Response {
                body?: ProjectInfo;
            }
            /**
             * Request whose sole parameter is a file name.
             */
            interface FileRequest extends Request {
                arguments: FileRequestArgs;
            }
            /**
             * Instances of this interface specify a location in a source file:
             * (file, line, character offset), where line and character offset are 1-based.
             */
            interface FileLocationRequestArgs extends FileRequestArgs {
                /**
                 * The line number for the request (1-based).
                 */
                line: number;
                /**
                 * The character offset (on the line) for the request (1-based).
                 */
                offset: number;
                /**
                 * Position (can be specified instead of line/offset pair)
                 *
                 * @internal
                 */
                position?: number;
            }
            type FileLocationOrRangeRequestArgs = FileLocationRequestArgs | FileRangeRequestArgs;
            /**
             * Request refactorings at a given position or selection area.
             */
            interface GetApplicableRefactorsRequest extends Request {
                command: CommandTypes.GetApplicableRefactors;
                arguments: GetApplicableRefactorsRequestArgs;
            }
            type GetApplicableRefactorsRequestArgs = FileLocationOrRangeRequestArgs & {
                triggerReason?: RefactorTriggerReason;
                kind?: string;
            };
            type RefactorTriggerReason = "implicit" | "invoked";
            /**
             * Response is a list of available refactorings.
             * Each refactoring exposes one or more "Actions"; a user selects one action to invoke a refactoring
             */
            interface GetApplicableRefactorsResponse extends Response {
                body?: ApplicableRefactorInfo[];
            }
            /**
             * A set of one or more available refactoring actions, grouped under a parent refactoring.
             */
            interface ApplicableRefactorInfo {
                /**
                 * The programmatic name of the refactoring
                 */
                name: string;
                /**
                 * A description of this refactoring category to show to the user.
                 * If the refactoring gets inlined (see below), this text will not be visible.
                 */
                description: string;
                /**
                 * Inlineable refactorings can have their actions hoisted out to the top level
                 * of a context menu. Non-inlineanable refactorings should always be shown inside
                 * their parent grouping.
                 *
                 * If not specified, this value is assumed to be 'true'
                 */
                inlineable?: boolean;
                actions: RefactorActionInfo[];
            }
            /**
             * Represents a single refactoring action - for example, the "Extract Method..." refactor might
             * offer several actions, each corresponding to a surround class or closure to extract into.
             */
            interface RefactorActionInfo {
                /**
                 * The programmatic name of the refactoring action
                 */
                name: string;
                /**
                 * A description of this refactoring action to show to the user.
                 * If the parent refactoring is inlined away, this will be the only text shown,
                 * so this description should make sense by itself if the parent is inlineable=true
                 */
                description: string;
                /**
                 * A message to show to the user if the refactoring cannot be applied in
                 * the current context.
                 */
                notApplicableReason?: string;
                /**
                 * The hierarchical dotted name of the refactor action.
                 */
                kind?: string;
            }
            interface GetEditsForRefactorRequest extends Request {
                command: CommandTypes.GetEditsForRefactor;
                arguments: GetEditsForRefactorRequestArgs;
            }
            /**
             * Request the edits that a particular refactoring action produces.
             * Callers must specify the name of the refactor and the name of the action.
             */
            type GetEditsForRefactorRequestArgs = FileLocationOrRangeRequestArgs & {
                refactor: string;
                action: string;
            };
            interface GetEditsForRefactorResponse extends Response {
                body?: RefactorEditInfo;
            }
            interface RefactorEditInfo {
                edits: FileCodeEdits[];
                /**
                 * An optional location where the editor should start a rename operation once
                 * the refactoring edits have been applied
                 */
                renameLocation?: Location;
                renameFilename?: string;
            }
            /**
             * Organize imports by:
             *   1) Removing unused imports
             *   2) Coalescing imports from the same module
             *   3) Sorting imports
             */
            interface OrganizeImportsRequest extends Request {
                command: CommandTypes.OrganizeImports;
                arguments: OrganizeImportsRequestArgs;
            }
            type OrganizeImportsScope = GetCombinedCodeFixScope;
            enum OrganizeImportsMode {
                All = "All",
                SortAndCombine = "SortAndCombine",
                RemoveUnused = "RemoveUnused"
            }
            interface OrganizeImportsRequestArgs {
                scope: OrganizeImportsScope;
                /** @deprecated Use `mode` instead */
                skipDestructiveCodeActions?: boolean;
                mode?: OrganizeImportsMode;
            }
            interface OrganizeImportsResponse extends Response {
                body: readonly FileCodeEdits[];
            }
            interface GetEditsForFileRenameRequest extends Request {
                command: CommandTypes.GetEditsForFileRename;
                arguments: GetEditsForFileRenameRequestArgs;
            }
            /** Note: Paths may also be directories. */
            interface GetEditsForFileRenameRequestArgs {
                readonly oldFilePath: string;
                readonly newFilePath: string;
            }
            interface GetEditsForFileRenameResponse extends Response {
                body: readonly FileCodeEdits[];
            }
            /**
             * Request for the available codefixes at a specific position.
             */
            interface CodeFixRequest extends Request {
                command: CommandTypes.GetCodeFixes;
                arguments: CodeFixRequestArgs;
            }
            interface GetCombinedCodeFixRequest extends Request {
                command: CommandTypes.GetCombinedCodeFix;
                arguments: GetCombinedCodeFixRequestArgs;
            }
            interface GetCombinedCodeFixResponse extends Response {
                body: CombinedCodeActions;
            }
            interface ApplyCodeActionCommandRequest extends Request {
                command: CommandTypes.ApplyCodeActionCommand;
                arguments: ApplyCodeActionCommandRequestArgs;
            }
            interface ApplyCodeActionCommandResponse extends Response {
            }
            interface FileRangeRequestArgs extends FileRequestArgs {
                /**
                 * The line number for the request (1-based).
                 */
                startLine: number;
                /**
                 * The character offset (on the line) for the request (1-based).
                 */
                startOffset: number;
                /**
                 * Position (can be specified instead of line/offset pair)
                 *
                 * @internal
                 */
                startPosition?: number;
                /**
                 * The line number for the request (1-based).
                 */
                endLine: number;
                /**
                 * The character offset (on the line) for the request (1-based).
                 */
                endOffset: number;
                /**
                 * Position (can be specified instead of line/offset pair)
                 *
                 * @internal
                 */
                endPosition?: number;
            }
            /**
             * Instances of this interface specify errorcodes on a specific location in a sourcefile.
             */
            interface CodeFixRequestArgs extends FileRangeRequestArgs {
                /**
                 * Errorcodes we want to get the fixes for.
                 */
                errorCodes: readonly number[];
            }
            interface GetCombinedCodeFixRequestArgs {
                scope: GetCombinedCodeFixScope;
                fixId: {};
            }
            interface GetCombinedCodeFixScope {
                type: "file";
                args: FileRequestArgs;
            }
            interface ApplyCodeActionCommandRequestArgs {
                /** May also be an array of commands. */
                command: {};
            }
            /**
             * Response for GetCodeFixes request.
             */
            interface GetCodeFixesResponse extends Response {
                body?: CodeAction[];
            }
            /**
             * A request whose arguments specify a file location (file, line, col).
             */
            interface FileLocationRequest extends FileRequest {
                arguments: FileLocationRequestArgs;
            }
            /**
             * A request to get codes of supported code fixes.
             */
            interface GetSupportedCodeFixesRequest extends Request {
                command: CommandTypes.GetSupportedCodeFixes;
                arguments?: Partial<FileRequestArgs>;
            }
            /**
             * A response for GetSupportedCodeFixesRequest request.
             */
            interface GetSupportedCodeFixesResponse extends Response {
                /**
                 * List of error codes supported by the server.
                 */
                body?: string[];
            }
            /**
             * A request to get encoded Syntactic classifications for a span in the file
             *
             * @internal
             */
            interface EncodedSyntacticClassificationsRequest extends FileRequest {
                arguments: EncodedSyntacticClassificationsRequestArgs;
            }
            /**
             * Arguments for EncodedSyntacticClassificationsRequest request.
             *
             * @internal
             */
            interface EncodedSyntacticClassificationsRequestArgs extends FileRequestArgs {
                /**
                 * Start position of the span.
                 */
                start: number;
                /**
                 * Length of the span.
                 */
                length: number;
            }
            /**
             * A request to get encoded semantic classifications for a span in the file
             */
            interface EncodedSemanticClassificationsRequest extends FileRequest {
                arguments: EncodedSemanticClassificationsRequestArgs;
            }
            /**
             * Arguments for EncodedSemanticClassificationsRequest request.
             */
            interface EncodedSemanticClassificationsRequestArgs extends FileRequestArgs {
                /**
                 * Start position of the span.
                 */
                start: number;
                /**
                 * Length of the span.
                 */
                length: number;
                /**
                 * Optional parameter for the semantic highlighting response, if absent it
                 * defaults to "original".
                 */
                format?: "original" | "2020";
            }
            /** The response for a EncodedSemanticClassificationsRequest */
            interface EncodedSemanticClassificationsResponse extends Response {
                body?: EncodedSemanticClassificationsResponseBody;
            }
            /**
             * Implementation response message. Gives series of text spans depending on the format ar.
             */
            interface EncodedSemanticClassificationsResponseBody {
                endOfLineState: EndOfLineState;
                spans: number[];
            }
            /**
             * Arguments in document highlight request; include: filesToSearch, file,
             * line, offset.
             */
            interface DocumentHighlightsRequestArgs extends FileLocationRequestArgs {
                /**
                 * List of files to search for document highlights.
                 */
                filesToSearch: string[];
            }
            /**
             * Go to definition request; value of command field is
             * "definition". Return response giving the file locations that
             * define the symbol found in file at location line, col.
             */
            interface DefinitionRequest extends FileLocationRequest {
                command: CommandTypes.Definition;
            }
            interface DefinitionAndBoundSpanRequest extends FileLocationRequest {
                readonly command: CommandTypes.DefinitionAndBoundSpan;
            }
            interface FindSourceDefinitionRequest extends FileLocationRequest {
                readonly command: CommandTypes.FindSourceDefinition;
            }
            interface DefinitionAndBoundSpanResponse extends Response {
                readonly body: DefinitionInfoAndBoundSpan;
            }
            /** @internal */
            interface EmitOutputRequest extends FileRequest {
                command: CommandTypes.EmitOutput;
                arguments: EmitOutputRequestArgs;
            }
            /** @internal */
            interface EmitOutputRequestArgs extends FileRequestArgs {
                includeLinePosition?: boolean;
                /** if true - return response as object with emitSkipped and diagnostics */
                richResponse?: boolean;
            }
            /** @internal */
            interface EmitOutputResponse extends Response {
                readonly body: EmitOutput | ts.EmitOutput;
            }
            /** @internal */
            interface EmitOutput {
                outputFiles: OutputFile[];
                emitSkipped: boolean;
                diagnostics: Diagnostic[] | DiagnosticWithLinePosition[];
            }
            /**
             * Go to type request; value of command field is
             * "typeDefinition". Return response giving the file locations that
             * define the type for the symbol found in file at location line, col.
             */
            interface TypeDefinitionRequest extends FileLocationRequest {
                command: CommandTypes.TypeDefinition;
            }
            /**
             * Go to implementation request; value of command field is
             * "implementation". Return response giving the file locations that
             * implement the symbol found in file at location line, col.
             */
            interface ImplementationRequest extends FileLocationRequest {
                command: CommandTypes.Implementation;
            }
            /**
             * Location in source code expressed as (one-based) line and (one-based) column offset.
             */
            interface Location {
                line: number;
                offset: number;
            }
            /**
             * Object found in response messages defining a span of text in source code.
             */
            interface TextSpan {
                /**
                 * First character of the definition.
                 */
                start: Location;
                /**
                 * One character past last character of the definition.
                 */
                end: Location;
            }
            /**
             * Object found in response messages defining a span of text in a specific source file.
             */
            interface FileSpan extends TextSpan {
                /**
                 * File containing text span.
                 */
                file: string;
            }
            interface JSDocTagInfo {
                /** Name of the JSDoc tag */
                name: string;
                /**
                 * Comment text after the JSDoc tag -- the text after the tag name until the next tag or end of comment
                 * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.
                 */
                text?: string | SymbolDisplayPart[];
            }
            interface TextSpanWithContext extends TextSpan {
                contextStart?: Location;
                contextEnd?: Location;
            }
            interface FileSpanWithContext extends FileSpan, TextSpanWithContext {
            }
            interface DefinitionInfo extends FileSpanWithContext {
                /**
                 * When true, the file may or may not exist.
                 */
                unverified?: boolean;
            }
            interface DefinitionInfoAndBoundSpan {
                definitions: readonly DefinitionInfo[];
                textSpan: TextSpan;
            }
            /**
             * Definition response message.  Gives text range for definition.
             */
            interface DefinitionResponse extends Response {
                body?: DefinitionInfo[];
            }
            interface DefinitionInfoAndBoundSpanResponse extends Response {
                body?: DefinitionInfoAndBoundSpan;
            }
            /** @deprecated Use `DefinitionInfoAndBoundSpanResponse` instead. */
            type DefinitionInfoAndBoundSpanReponse = DefinitionInfoAndBoundSpanResponse;
            /**
             * Definition response message.  Gives text range for definition.
             */
            interface TypeDefinitionResponse extends Response {
                body?: FileSpanWithContext[];
            }
            /**
             * Implementation response message.  Gives text range for implementations.
             */
            interface ImplementationResponse extends Response {
                body?: FileSpanWithContext[];
            }
            /**
             * Request to get brace completion for a location in the file.
             */
            interface BraceCompletionRequest extends FileLocationRequest {
                command: CommandTypes.BraceCompletion;
                arguments: BraceCompletionRequestArgs;
            }
            /**
             * Argument for BraceCompletionRequest request.
             */
            interface BraceCompletionRequestArgs extends FileLocationRequestArgs {
                /**
                 * Kind of opening brace
                 */
                openingBrace: string;
            }
            interface JsxClosingTagRequest extends FileLocationRequest {
                readonly command: CommandTypes.JsxClosingTag;
                readonly arguments: JsxClosingTagRequestArgs;
            }
            interface JsxClosingTagRequestArgs extends FileLocationRequestArgs {
            }
            interface JsxClosingTagResponse extends Response {
                readonly body: TextInsertion;
            }
            /**
             * @deprecated
             * Get occurrences request; value of command field is
             * "occurrences". Return response giving spans that are relevant
             * in the file at a given line and column.
             */
            interface OccurrencesRequest extends FileLocationRequest {
                command: CommandTypes.Occurrences;
            }
            /** @deprecated */
            interface OccurrencesResponseItem extends FileSpanWithContext {
                /**
                 * True if the occurrence is a write location, false otherwise.
                 */
                isWriteAccess: boolean;
                /**
                 * True if the occurrence is in a string, undefined otherwise;
                 */
                isInString?: true;
            }
            /** @deprecated */
            interface OccurrencesResponse extends Response {
                body?: OccurrencesResponseItem[];
            }
            /**
             * Get document highlights request; value of command field is
             * "documentHighlights". Return response giving spans that are relevant
             * in the file at a given line and column.
             */
            interface DocumentHighlightsRequest extends FileLocationRequest {
                command: CommandTypes.DocumentHighlights;
                arguments: DocumentHighlightsRequestArgs;
            }
            /**
             * Span augmented with extra information that denotes the kind of the highlighting to be used for span.
             */
            interface HighlightSpan extends TextSpanWithContext {
                kind: HighlightSpanKind;
            }
            /**
             * Represents a set of highligh spans for a give name
             */
            interface DocumentHighlightsItem {
                /**
                 * File containing highlight spans.
                 */
                file: string;
                /**
                 * Spans to highlight in file.
                 */
                highlightSpans: HighlightSpan[];
            }
            /**
             * Response for a DocumentHighlightsRequest request.
             */
            interface DocumentHighlightsResponse extends Response {
                body?: DocumentHighlightsItem[];
            }
            /**
             * Find references request; value of command field is
             * "references". Return response giving the file locations that
             * reference the symbol found in file at location line, col.
             */
            interface ReferencesRequest extends FileLocationRequest {
                command: CommandTypes.References;
            }
            interface ReferencesResponseItem extends FileSpanWithContext {
                /**
                 * Text of line containing the reference. Including this
                 * with the response avoids latency of editor loading files
                 * to show text of reference line (the server already has loaded the referencing files).
                 *
                 * If {@link UserPreferences.disableLineTextInReferences} is enabled, the property won't be filled
                 */
                lineText?: string;
                /**
                 * True if reference is a write location, false otherwise.
                 */
                isWriteAccess: boolean;
                /**
                 * Present only if the search was triggered from a declaration.
                 * True indicates that the references refers to the same symbol
                 * (i.e. has the same meaning) as the declaration that began the
                 * search.
                 */
                isDefinition?: boolean;
            }
            /**
             * The body of a "references" response message.
             */
            interface ReferencesResponseBody {
                /**
                 * The file locations referencing the symbol.
                 */
                refs: readonly ReferencesResponseItem[];
                /**
                 * The name of the symbol.
                 */
                symbolName: string;
                /**
                 * The start character offset of the symbol (on the line provided by the references request).
                 */
                symbolStartOffset: number;
                /**
                 * The full display name of the symbol.
                 */
                symbolDisplayString: string;
            }
            /**
             * Response to "references" request.
             */
            interface ReferencesResponse extends Response {
                body?: ReferencesResponseBody;
            }
            interface FileReferencesRequest extends FileRequest {
                command: CommandTypes.FileReferences;
            }
            interface FileReferencesResponseBody {
                /**
                 * The file locations referencing the symbol.
                 */
                refs: readonly ReferencesResponseItem[];
                /**
                 * The name of the symbol.
                 */
                symbolName: string;
            }
            interface FileReferencesResponse extends Response {
                body?: FileReferencesResponseBody;
            }
            /**
             * Argument for RenameRequest request.
             */
            interface RenameRequestArgs extends FileLocationRequestArgs {
                /**
                 * Should text at specified location be found/changed in comments?
                 */
                findInComments?: boolean;
                /**
                 * Should text at specified location be found/changed in strings?
                 */
                findInStrings?: boolean;
            }
            /**
             * Rename request; value of command field is "rename". Return
             * response giving the file locations that reference the symbol
             * found in file at location line, col. Also return full display
             * name of the symbol so that client can print it unambiguously.
             */
            interface RenameRequest extends FileLocationRequest {
                command: CommandTypes.Rename;
                arguments: RenameRequestArgs;
            }
            /** @internal */
            interface RenameFullRequest extends FileLocationRequest {
                readonly command: CommandTypes.RenameLocationsFull;
                readonly arguments: RenameRequestArgs;
            }
            /** @internal */
            interface RenameFullResponse extends Response {
                readonly body: readonly RenameLocation[];
            }
            /**
             * Information about the item to be renamed.
             */
            type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
            interface RenameInfoSuccess {
                /**
                 * True if item can be renamed.
                 */
                canRename: true;
                /**
                 * File or directory to rename.
                 * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.
                 */
                fileToRename?: string;
                /**
                 * Display name of the item to be renamed.
                 */
                displayName: string;
                /**
                 * Full display name of item to be renamed.
                 */
                fullDisplayName: string;
                /**
                 * The items's kind (such as 'className' or 'parameterName' or plain 'text').
                 */
                kind: ScriptElementKind;
                /**
                 * Optional modifiers for the kind (such as 'public').
                 */
                kindModifiers: string;
                /** Span of text to rename. */
                triggerSpan: TextSpan;
            }
            interface RenameInfoFailure {
                canRename: false;
                /**
                 * Error message if item can not be renamed.
                 */
                localizedErrorMessage: string;
            }
            /**
             *  A group of text spans, all in 'file'.
             */
            interface SpanGroup {
                /** The file to which the spans apply */
                file: string;
                /** The text spans in this group */
                locs: RenameTextSpan[];
            }
            interface RenameTextSpan extends TextSpanWithContext {
                readonly prefixText?: string;
                readonly suffixText?: string;
            }
            interface RenameResponseBody {
                /**
                 * Information about the item to be renamed.
                 */
                info: RenameInfo;
                /**
                 * An array of span groups (one per file) that refer to the item to be renamed.
                 */
                locs: readonly SpanGroup[];
            }
            /**
             * Rename response message.
             */
            interface RenameResponse extends Response {
                body?: RenameResponseBody;
            }
            /**
             * Represents a file in external project.
             * External project is project whose set of files, compilation options and open\close state
             * is maintained by the client (i.e. if all this data come from .csproj file in Visual Studio).
             * External project will exist even if all files in it are closed and should be closed explicitly.
             * If external project includes one or more tsconfig.json/jsconfig.json files then tsserver will
             * create configured project for every config file but will maintain a link that these projects were created
             * as a result of opening external project so they should be removed once external project is closed.
             */
            interface ExternalFile {
                /**
                 * Name of file file
                 */
                fileName: string;
                /**
                 * Script kind of the file
                 */
                scriptKind?: ScriptKindName | ScriptKind;
                /**
                 * Whether file has mixed content (i.e. .cshtml file that combines html markup with C#/JavaScript)
                 */
                hasMixedContent?: boolean;
                /**
                 * Content of the file
                 */
                content?: string;
            }
            /**
             * Represent an external project
             */
            interface ExternalProject {
                /**
                 * Project name
                 */
                projectFileName: string;
                /**
                 * List of root files in project
                 */
                rootFiles: ExternalFile[];
                /**
                 * Compiler options for the project
                 */
                options: ExternalProjectCompilerOptions;
                /**
                 * Explicitly specified type acquisition for the project
                 */
                typeAcquisition?: TypeAcquisition;
            }
            interface CompileOnSaveMixin {
                /**
                 * If compile on save is enabled for the project
                 */
                compileOnSave?: boolean;
            }
            /**
             * For external projects, some of the project settings are sent together with
             * compiler settings.
             */
            type ExternalProjectCompilerOptions = CompilerOptions & CompileOnSaveMixin & WatchOptions;
            /**
             * Contains information about current project version
             *
             * @internal
             */
            interface ProjectVersionInfo {
                /**
                 * Project name
                 */
                projectName: string;
                /**
                 * true if project is inferred or false if project is external or configured
                 */
                isInferred: boolean;
                /**
                 * Project version
                 */
                version: number;
                /**
                 * Current set of compiler options for project
                 */
                options: ts.CompilerOptions;
                /**
                 * true if project language service is disabled
                 */
                languageServiceDisabled: boolean;
                /**
                 * Filename of the last file analyzed before disabling the language service. undefined, if the language service is enabled.
                 */
                lastFileExceededProgramSize?: string;
            }
            interface FileWithProjectReferenceRedirectInfo {
                /**
                 * Name of file
                 */
                fileName: string;
                /**
                 * True if the file is primarily included in a referenced project
                 */
                isSourceOfProjectReferenceRedirect: boolean;
            }
            /**
             * Represents a set of changes that happen in project
             */
            interface ProjectChanges {
                /**
                 * List of added files
                 */
                added: string[] | FileWithProjectReferenceRedirectInfo[];
                /**
                 * List of removed files
                 */
                removed: string[] | FileWithProjectReferenceRedirectInfo[];
                /**
                 * List of updated files
                 */
                updated: string[] | FileWithProjectReferenceRedirectInfo[];
                /**
                 * List of files that have had their project reference redirect status updated
                 * Only provided when the synchronizeProjectList request has includeProjectReferenceRedirectInfo set to true
                 */
                updatedRedirects?: FileWithProjectReferenceRedirectInfo[];
            }
            /**
             * Describes set of files in the project.
             * info might be omitted in case of inferred projects
             * if files is set - then this is the entire set of files in the project
             * if changes is set - then this is the set of changes that should be applied to existing project
             * otherwise - assume that nothing is changed
             *
             * @internal
             */
            interface ProjectFiles {
                /**
                 * Information about project verison
                 */
                info?: ProjectVersionInfo;
                /**
                 * List of files in project (might be omitted if current state of project can be computed using only information from 'changes')
                 * This property will have type FileWithProjectReferenceRedirectInfo[] if includeProjectReferenceRedirectInfo is set to true in
                 * the corresponding SynchronizeProjectList request; otherwise, it will have type string[].
                 */
                files?: string[] | FileWithProjectReferenceRedirectInfo[];
                /**
                 * Set of changes in project (omitted if the entire set of files in project should be replaced)
                 */
                changes?: ProjectChanges;
            }
            /**
             * Combines project information with project level errors.
             *
             * @internal
             */
            interface ProjectFilesWithDiagnostics extends ProjectFiles {
                /**
                 * List of errors in project
                 */
                projectErrors: DiagnosticWithLinePosition[];
            }
            /**
             * Represents set of changes in open file
             *
             * @internal
             */
            interface ChangedOpenFile {
                /**
                 * Name of file
                 */
                fileName: string;
                /**
                 * List of changes that should be applied to known open file
                 */
                changes: TextChange[];
            }
            /**
             * Information found in a configure request.
             */
            interface ConfigureRequestArguments {
                /**
                 * Information about the host, for example 'Emacs 24.4' or
                 * 'Sublime Text version 3075'
                 */
                hostInfo?: string;
                /**
                 * If present, tab settings apply only to this file.
                 */
                file?: string;
                /**
                 * The format options to use during formatting and other code editing features.
                 */
                formatOptions?: FormatCodeSettings;
                preferences?: UserPreferences;
                /**
                 * The host's additional supported .js file extensions
                 */
                extraFileExtensions?: FileExtensionInfo[];
                watchOptions?: WatchOptions;
            }
            enum WatchFileKind {
                FixedPollingInterval = "FixedPollingInterval",
                PriorityPollingInterval = "PriorityPollingInterval",
                DynamicPriorityPolling = "DynamicPriorityPolling",
                FixedChunkSizePolling = "FixedChunkSizePolling",
                UseFsEvents = "UseFsEvents",
                UseFsEventsOnParentDirectory = "UseFsEventsOnParentDirectory"
            }
            enum WatchDirectoryKind {
                UseFsEvents = "UseFsEvents",
                FixedPollingInterval = "FixedPollingInterval",
                DynamicPriorityPolling = "DynamicPriorityPolling",
                FixedChunkSizePolling = "FixedChunkSizePolling"
            }
            enum PollingWatchKind {
                FixedInterval = "FixedInterval",
                PriorityInterval = "PriorityInterval",
                DynamicPriority = "DynamicPriority",
                FixedChunkSize = "FixedChunkSize"
            }
            interface WatchOptions {
                watchFile?: WatchFileKind | ts.WatchFileKind;
                watchDirectory?: WatchDirectoryKind | ts.WatchDirectoryKind;
                fallbackPolling?: PollingWatchKind | ts.PollingWatchKind;
                synchronousWatchDirectory?: boolean;
                excludeDirectories?: string[];
                excludeFiles?: string[];
                [option: string]: CompilerOptionsValue | undefined;
            }
            /**
             *  Configure request; value of command field is "configure".  Specifies
             *  host information, such as host type, tab size, and indent size.
             */
            interface ConfigureRequest extends Request {
                command: CommandTypes.Configure;
                arguments: ConfigureRequestArguments;
            }
            /**
             * Response to "configure" request.  This is just an acknowledgement, so
             * no body field is required.
             */
            interface ConfigureResponse extends Response {
            }
            interface ConfigurePluginRequestArguments {
                pluginName: string;
                configuration: any;
            }
            interface ConfigurePluginRequest extends Request {
                command: CommandTypes.ConfigurePlugin;
                arguments: ConfigurePluginRequestArguments;
            }
            interface ConfigurePluginResponse extends Response {
            }
            interface SelectionRangeRequest extends FileRequest {
                command: CommandTypes.SelectionRange;
                arguments: SelectionRangeRequestArgs;
            }
            interface SelectionRangeRequestArgs extends FileRequestArgs {
                locations: Location[];
            }
            interface SelectionRangeResponse extends Response {
                body?: SelectionRange[];
            }
            interface SelectionRange {
                textSpan: TextSpan;
                parent?: SelectionRange;
            }
            interface ToggleLineCommentRequest extends FileRequest {
                command: CommandTypes.ToggleLineComment;
                arguments: FileRangeRequestArgs;
            }
            interface ToggleMultilineCommentRequest extends FileRequest {
                command: CommandTypes.ToggleMultilineComment;
                arguments: FileRangeRequestArgs;
            }
            interface CommentSelectionRequest extends FileRequest {
                command: CommandTypes.CommentSelection;
                arguments: FileRangeRequestArgs;
            }
            interface UncommentSelectionRequest extends FileRequest {
                command: CommandTypes.UncommentSelection;
                arguments: FileRangeRequestArgs;
            }
            /**
             *  Information found in an "open" request.
             */
            interface OpenRequestArgs extends FileRequestArgs {
                /**
                 * Used when a version of the file content is known to be more up to date than the one on disk.
                 * Then the known content will be used upon opening instead of the disk copy
                 */
                fileContent?: string;
                /**
                 * Used to specify the script kind of the file explicitly. It could be one of the following:
                 *      "TS", "JS", "TSX", "JSX"
                 */
                scriptKindName?: ScriptKindName;
                /**
                 * Used to limit the searching for project config file. If given the searching will stop at this
                 * root path; otherwise it will go all the way up to the dist root path.
                 */
                projectRootPath?: string;
            }
            type ScriptKindName = "TS" | "JS" | "TSX" | "JSX";
            /**
             * Open request; value of command field is "open". Notify the
             * server that the client has file open.  The server will not
             * monitor the filesystem for changes in this file and will assume
             * that the client is updating the server (using the change and/or
             * reload messages) when the file changes. Server does not currently
             * send a response to an open request.
             */
            interface OpenRequest extends Request {
                command: CommandTypes.Open;
                arguments: OpenRequestArgs;
            }
            /**
             * Request to open or update external project
             */
            interface OpenExternalProjectRequest extends Request {
                command: CommandTypes.OpenExternalProject;
                arguments: OpenExternalProjectArgs;
            }
            /**
             * Arguments to OpenExternalProjectRequest request
             */
            type OpenExternalProjectArgs = ExternalProject;
            /**
             * Request to open multiple external projects
             */
            interface OpenExternalProjectsRequest extends Request {
                command: CommandTypes.OpenExternalProjects;
                arguments: OpenExternalProjectsArgs;
            }
            /**
             * Arguments to OpenExternalProjectsRequest
             */
            interface OpenExternalProjectsArgs {
                /**
                 * List of external projects to open or update
                 */
                projects: ExternalProject[];
            }
            /**
             * Response to OpenExternalProjectRequest request. This is just an acknowledgement, so
             * no body field is required.
             */
            interface OpenExternalProjectResponse extends Response {
            }
            /**
             * Response to OpenExternalProjectsRequest request. This is just an acknowledgement, so
             * no body field is required.
             */
            interface OpenExternalProjectsResponse extends Response {
            }
            /**
             * Request to close external project.
             */
            interface CloseExternalProjectRequest extends Request {
                command: CommandTypes.CloseExternalProject;
                arguments: CloseExternalProjectRequestArgs;
            }
            /**
             * Arguments to CloseExternalProjectRequest request
             */
            interface CloseExternalProjectRequestArgs {
                /**
                 * Name of the project to close
                 */
                projectFileName: string;
            }
            /**
             * Response to CloseExternalProjectRequest request. This is just an acknowledgement, so
             * no body field is required.
             */
            interface CloseExternalProjectResponse extends Response {
            }
            /**
             * Request to check if given list of projects is up-to-date and synchronize them if necessary
             *
             * @internal
             */
            interface SynchronizeProjectListRequest extends Request {
                arguments: SynchronizeProjectListRequestArgs;
            }
            /**
             * Arguments to SynchronizeProjectListRequest
             *
             * @internal
             */
            interface SynchronizeProjectListRequestArgs {
                /**
                 * List of last known projects
                 */
                knownProjects: ProjectVersionInfo[];
                /**
                 * If true, response specifies whether or not each file in each project
                 * is a source from a project reference redirect
                 */
                includeProjectReferenceRedirectInfo?: boolean;
            }
            /**
             * Request to synchronize list of open files with the client
             *
             * @internal
             */
            interface ApplyChangedToOpenFilesRequest extends Request {
                arguments: ApplyChangedToOpenFilesRequestArgs;
            }
            /**
             * Arguments to ApplyChangedToOpenFilesRequest
             *
             * @internal
             */
            interface ApplyChangedToOpenFilesRequestArgs {
                /**
                 * List of newly open files
                 */
                openFiles?: ExternalFile[];
                /**
                 * List of open files files that were changes
                 */
                changedFiles?: ChangedOpenFile[];
                /**
                 * List of files that were closed
                 */
                closedFiles?: string[];
            }
            /**
             * Request to synchronize list of open files with the client
             */
            interface UpdateOpenRequest extends Request {
                command: CommandTypes.UpdateOpen;
                arguments: UpdateOpenRequestArgs;
            }
            /**
             * Arguments to UpdateOpenRequest
             */
            interface UpdateOpenRequestArgs {
                /**
                 * List of newly open files
                 */
                openFiles?: OpenRequestArgs[];
                /**
                 * List of open files files that were changes
                 */
                changedFiles?: FileCodeEdits[];
                /**
                 * List of files that were closed
                 */
                closedFiles?: string[];
            }
            /**
             * External projects have a typeAcquisition option so they need to be added separately to compiler options for inferred projects.
             */
            type InferredProjectCompilerOptions = ExternalProjectCompilerOptions & TypeAcquisition;
            /**
             * Request to set compiler options for inferred projects.
             * External projects are opened / closed explicitly.
             * Configured projects are opened when user opens loose file that has 'tsconfig.json' or 'jsconfig.json' anywhere in one of containing folders.
             * This configuration file will be used to obtain a list of files and configuration settings for the project.
             * Inferred projects are created when user opens a loose file that is not the part of external project
             * or configured project and will contain only open file and transitive closure of referenced files if 'useOneInferredProject' is false,
             * or all open loose files and its transitive closure of referenced files if 'useOneInferredProject' is true.
             */
            interface SetCompilerOptionsForInferredProjectsRequest extends Request {
                command: CommandTypes.CompilerOptionsForInferredProjects;
                arguments: SetCompilerOptionsForInferredProjectsArgs;
            }
            /**
             * Argument for SetCompilerOptionsForInferredProjectsRequest request.
             */
            interface SetCompilerOptionsForInferredProjectsArgs {
                /**
                 * Compiler options to be used with inferred projects.
                 */
                options: InferredProjectCompilerOptions;
                /**
                 * Specifies the project root path used to scope compiler options.
                 * It is an error to provide this property if the server has not been started with
                 * `useInferredProjectPerProjectRoot` enabled.
                 */
                projectRootPath?: string;
            }
            /**
             * Response to SetCompilerOptionsForInferredProjectsResponse request. This is just an acknowledgement, so
             * no body field is required.
             */
            interface SetCompilerOptionsForInferredProjectsResponse extends Response {
            }
            /**
             *  Exit request; value of command field is "exit".  Ask the server process
             *  to exit.
             */
            interface ExitRequest extends Request {
                command: CommandTypes.Exit;
            }
            /**
             * Close request; value of command field is "close". Notify the
             * server that the client has closed a previously open file.  If
             * file is still referenced by open files, the server will resume
             * monitoring the filesystem for changes to file.  Server does not
             * currently send a response to a close request.
             */
            interface CloseRequest extends FileRequest {
                command: CommandTypes.Close;
            }
            /**
             * Request to obtain the list of files that should be regenerated if target file is recompiled.
             * NOTE: this us query-only operation and does not generate any output on disk.
             */
            interface CompileOnSaveAffectedFileListRequest extends FileRequest {
                command: CommandTypes.CompileOnSaveAffectedFileList;
            }
            /**
             * Contains a list of files that should be regenerated in a project
             */
            interface CompileOnSaveAffectedFileListSingleProject {
                /**
                 * Project name
                 */
                projectFileName: string;
                /**
                 * List of files names that should be recompiled
                 */
                fileNames: string[];
                /**
                 * true if project uses outFile or out compiler option
                 */
                projectUsesOutFile: boolean;
            }
            /**
             * Response for CompileOnSaveAffectedFileListRequest request;
             */
            interface CompileOnSaveAffectedFileListResponse extends Response {
                body: CompileOnSaveAffectedFileListSingleProject[];
            }
            /**
             * Request to recompile the file. All generated outputs (.js, .d.ts or .js.map files) is written on disk.
             */
            interface CompileOnSaveEmitFileRequest extends FileRequest {
                command: CommandTypes.CompileOnSaveEmitFile;
                arguments: CompileOnSaveEmitFileRequestArgs;
            }
            /**
             * Arguments for CompileOnSaveEmitFileRequest
             */
            interface CompileOnSaveEmitFileRequestArgs extends FileRequestArgs {
                /**
                 * if true - then file should be recompiled even if it does not have any changes.
                 */
                forced?: boolean;
                includeLinePosition?: boolean;
                /** if true - return response as object with emitSkipped and diagnostics */
                richResponse?: boolean;
            }
            interface CompileOnSaveEmitFileResponse extends Response {
                body: boolean | EmitResult;
            }
            interface EmitResult {
                emitSkipped: boolean;
                diagnostics: Diagnostic[] | DiagnosticWithLinePosition[];
            }
            /**
             * Quickinfo request; value of command field is
             * "quickinfo". Return response giving a quick type and
             * documentation string for the symbol found in file at location
             * line, col.
             */
            interface QuickInfoRequest extends FileLocationRequest {
                command: CommandTypes.Quickinfo;
                arguments: FileLocationRequestArgs;
            }
            /**
             * Body of QuickInfoResponse.
             */
            interface QuickInfoResponseBody {
                /**
                 * The symbol's kind (such as 'className' or 'parameterName' or plain 'text').
                 */
                kind: ScriptElementKind;
                /**
                 * Optional modifiers for the kind (such as 'public').
                 */
                kindModifiers: string;
                /**
                 * Starting file location of symbol.
                 */
                start: Location;
                /**
                 * One past last character of symbol.
                 */
                end: Location;
                /**
                 * Type and kind of symbol.
                 */
                displayString: string;
                /**
                 * Documentation associated with symbol.
                 * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.
                 */
                documentation: string | SymbolDisplayPart[];
                /**
                 * JSDoc tags associated with symbol.
                 */
                tags: JSDocTagInfo[];
            }
            /**
             * Quickinfo response message.
             */
            interface QuickInfoResponse extends Response {
                body?: QuickInfoResponseBody;
            }
            /**
             * Arguments for format messages.
             */
            interface FormatRequestArgs extends FileLocationRequestArgs {
                /**
                 * Last line of range for which to format text in file.
                 */
                endLine: number;
                /**
                 * Character offset on last line of range for which to format text in file.
                 */
                endOffset: number;
                /**
                 * End position of the range for which to format text in file.
                 *
                 * @internal
                 */
                endPosition?: number;
                /**
                 * Format options to be used.
                 */
                options?: FormatCodeSettings;
            }
            /**
             * Format request; value of command field is "format".  Return
             * response giving zero or more edit instructions.  The edit
             * instructions will be sorted in file order.  Applying the edit
             * instructions in reverse to file will result in correctly
             * reformatted text.
             */
            interface FormatRequest extends FileLocationRequest {
                command: CommandTypes.Format;
                arguments: FormatRequestArgs;
            }
            /**
             * Object found in response messages defining an editing
             * instruction for a span of text in source code.  The effect of
             * this instruction is to replace the text starting at start and
             * ending one character before end with newText. For an insertion,
             * the text span is empty.  For a deletion, newText is empty.
             */
            interface CodeEdit {
                /**
                 * First character of the text span to edit.
                 */
                start: Location;
                /**
                 * One character past last character of the text span to edit.
                 */
                end: Location;
                /**
                 * Replace the span defined above with this string (may be
                 * the empty string).
                 */
                newText: string;
            }
            interface FileCodeEdits {
                fileName: string;
                textChanges: CodeEdit[];
            }
            interface CodeFixResponse extends Response {
                /** The code actions that are available */
                body?: CodeFixAction[];
            }
            interface CodeAction {
                /** Description of the code action to display in the UI of the editor */
                description: string;
                /** Text changes to apply to each file as part of the code action */
                changes: FileCodeEdits[];
                /** A command is an opaque object that should be passed to `ApplyCodeActionCommandRequestArgs` without modification.  */
                commands?: {}[];
            }
            interface CombinedCodeActions {
                changes: readonly FileCodeEdits[];
                commands?: readonly {}[];
            }
            interface CodeFixAction extends CodeAction {
                /** Short name to identify the fix, for use by telemetry. */
                fixName: string;
                /**
                 * If present, one may call 'getCombinedCodeFix' with this fixId.
                 * This may be omitted to indicate that the code fix can't be applied in a group.
                 */
                fixId?: {};
                /** Should be present if and only if 'fixId' is. */
                fixAllDescription?: string;
            }
            /**
             * Format and format on key response message.
             */
            interface FormatResponse extends Response {
                body?: CodeEdit[];
            }
            /**
             * Arguments for format on key messages.
             */
            interface FormatOnKeyRequestArgs extends FileLocationRequestArgs {
                /**
                 * Key pressed (';', '\n', or '}').
                 */
                key: string;
                options?: FormatCodeSettings;
            }
            /**
             * Format on key request; value of command field is
             * "formatonkey". Given file location and key typed (as string),
             * return response giving zero or more edit instructions.  The
             * edit instructions will be sorted in file order.  Applying the
             * edit instructions in reverse to file will result in correctly
             * reformatted text.
             */
            interface FormatOnKeyRequest extends FileLocationRequest {
                command: CommandTypes.Formatonkey;
                arguments: FormatOnKeyRequestArgs;
            }
            type CompletionsTriggerCharacter = "." | '"' | "'" | "`" | "/" | "@" | "<" | "#" | " ";
            enum CompletionTriggerKind {
                /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */
                Invoked = 1,
                /** Completion was triggered by a trigger character. */
                TriggerCharacter = 2,
                /** Completion was re-triggered as the current completion list is incomplete. */
                TriggerForIncompleteCompletions = 3
            }
            /**
             * Arguments for completions messages.
             */
            interface CompletionsRequestArgs extends FileLocationRequestArgs {
                /**
                 * Optional prefix to apply to possible completions.
                 */
                prefix?: string;
                /**
                 * Character that was responsible for triggering completion.
                 * Should be `undefined` if a user manually requested completion.
                 */
                triggerCharacter?: CompletionsTriggerCharacter;
                triggerKind?: CompletionTriggerKind;
                /**
                 * @deprecated Use UserPreferences.includeCompletionsForModuleExports
                 */
                includeExternalModuleExports?: boolean;
                /**
                 * @deprecated Use UserPreferences.includeCompletionsWithInsertText
                 */
                includeInsertTextCompletions?: boolean;
            }
            /**
             * Completions request; value of command field is "completions".
             * Given a file location (file, line, col) and a prefix (which may
             * be the empty string), return the possible completions that
             * begin with prefix.
             */
            interface CompletionsRequest extends FileLocationRequest {
                command: CommandTypes.Completions | CommandTypes.CompletionInfo;
                arguments: CompletionsRequestArgs;
            }
            /**
             * Arguments for completion details request.
             */
            interface CompletionDetailsRequestArgs extends FileLocationRequestArgs {
                /**
                 * Names of one or more entries for which to obtain details.
                 */
                entryNames: (string | CompletionEntryIdentifier)[];
            }
            interface CompletionEntryIdentifier {
                name: string;
                source?: string;
                data?: unknown;
            }
            /**
             * Completion entry details request; value of command field is
             * "completionEntryDetails".  Given a file location (file, line,
             * col) and an array of completion entry names return more
             * detailed information for each completion entry.
             */
            interface CompletionDetailsRequest extends FileLocationRequest {
                command: CommandTypes.CompletionDetails;
                arguments: CompletionDetailsRequestArgs;
            }
            /**
             * Part of a symbol description.
             */
            interface SymbolDisplayPart {
                /**
                 * Text of an item describing the symbol.
                 */
                text: string;
                /**
                 * The symbol's kind (such as 'className' or 'parameterName' or plain 'text').
                 */
                kind: string;
            }
            /** A part of a symbol description that links from a jsdoc @link tag to a declaration */
            interface JSDocLinkDisplayPart extends SymbolDisplayPart {
                /** The location of the declaration that the @link tag links to. */
                target: FileSpan;
            }
            /**
             * An item found in a completion response.
             */
            interface CompletionEntry {
                /**
                 * The symbol's name.
                 */
                name: string;
                /**
                 * The symbol's kind (such as 'className' or 'parameterName').
                 */
                kind: ScriptElementKind;
                /**
                 * Optional modifiers for the kind (such as 'public').
                 */
                kindModifiers?: string;
                /**
                 * A string that is used for comparing completion items so that they can be ordered.  This
                 * is often the same as the name but may be different in certain circumstances.
                 */
                sortText: string;
                /**
                 * Text to insert instead of `name`.
                 * This is used to support bracketed completions; If `name` might be "a-b" but `insertText` would be `["a-b"]`,
                 * coupled with `replacementSpan` to replace a dotted access with a bracket access.
                 */
                insertText?: string;
                /**
                 * `insertText` should be interpreted as a snippet if true.
                 */
                isSnippet?: true;
                /**
                 * An optional span that indicates the text to be replaced by this completion item.
                 * If present, this span should be used instead of the default one.
                 * It will be set if the required span differs from the one generated by the default replacement behavior.
                 */
                replacementSpan?: TextSpan;
                /**
                 * Indicates whether commiting this completion entry will require additional code actions to be
                 * made to avoid errors. The CompletionEntryDetails will have these actions.
                 */
                hasAction?: true;
                /**
                 * Identifier (not necessarily human-readable) identifying where this completion came from.
                 */
                source?: string;
                /**
                 * Human-readable description of the `source`.
                 */
                sourceDisplay?: SymbolDisplayPart[];
                /**
                 * Additional details for the label.
                 */
                labelDetails?: CompletionEntryLabelDetails;
                /**
                 * If true, this completion should be highlighted as recommended. There will only be one of these.
                 * This will be set when we know the user should write an expression with a certain type and that type is an enum or constructable class.
                 * Then either that enum/class or a namespace containing it will be the recommended symbol.
                 */
                isRecommended?: true;
                /**
                 * If true, this completion was generated from traversing the name table of an unchecked JS file,
                 * and therefore may not be accurate.
                 */
                isFromUncheckedFile?: true;
                /**
                 * If true, this completion was for an auto-import of a module not yet in the program, but listed
                 * in the project package.json. Used for telemetry reporting.
                 */
                isPackageJsonImport?: true;
                /**
                 * If true, this completion was an auto-import-style completion of an import statement (i.e., the
                 * module specifier was inserted along with the imported identifier). Used for telemetry reporting.
                 */
                isImportStatementCompletion?: true;
                /**
                 * A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,
                 * that allows TS Server to look up the symbol represented by the completion item, disambiguating
                 * items with the same name.
                 */
                data?: unknown;
            }
            interface CompletionEntryLabelDetails {
                /**
                 * An optional string which is rendered less prominently directly after
                 * {@link CompletionEntry.name name}, without any spacing. Should be
                 * used for function signatures or type annotations.
                 */
                detail?: string;
                /**
                 * An optional string which is rendered less prominently after
                 * {@link CompletionEntryLabelDetails.detail}. Should be used for fully qualified
                 * names or file path.
                 */
                description?: string;
            }
            /**
             * Additional completion entry details, available on demand
             */
            interface CompletionEntryDetails {
                /**
                 * The symbol's name.
                 */
                name: string;
                /**
                 * The symbol's kind (such as 'className' or 'parameterName').
                 */
                kind: ScriptElementKind;
                /**
                 * Optional modifiers for the kind (such as 'public').
                 */
                kindModifiers: string;
                /**
                 * Display parts of the symbol (similar to quick info).
                 */
                displayParts: SymbolDisplayPart[];
                /**
                 * Documentation strings for the symbol.
                 */
                documentation?: SymbolDisplayPart[];
                /**
                 * JSDoc tags for the symbol.
                 */
                tags?: JSDocTagInfo[];
                /**
                 * The associated code actions for this entry
                 */
                codeActions?: CodeAction[];
                /**
                 * @deprecated Use `sourceDisplay` instead.
                 */
                source?: SymbolDisplayPart[];
                /**
                 * Human-readable description of the `source` from the CompletionEntry.
                 */
                sourceDisplay?: SymbolDisplayPart[];
            }
            /** @deprecated Prefer CompletionInfoResponse, which supports several top-level fields in addition to the array of entries. */
            interface CompletionsResponse extends Response {
                body?: CompletionEntry[];
            }
            interface CompletionInfoResponse extends Response {
                body?: CompletionInfo;
            }
            interface CompletionInfo {
                readonly flags?: number;
                readonly isGlobalCompletion: boolean;
                readonly isMemberCompletion: boolean;
                readonly isNewIdentifierLocation: boolean;
                /**
                 * In the absence of `CompletionEntry["replacementSpan"]`, the editor may choose whether to use
                 * this span or its default one. If `CompletionEntry["replacementSpan"]` is defined, that span
                 * must be used to commit that completion entry.
                 */
                readonly optionalReplacementSpan?: TextSpan;
                readonly isIncomplete?: boolean;
                readonly entries: readonly CompletionEntry[];
            }
            interface CompletionDetailsResponse extends Response {
                body?: CompletionEntryDetails[];
            }
            /**
             * Signature help information for a single parameter
             */
            interface SignatureHelpParameter {
                /**
                 * The parameter's name
                 */
                name: string;
                /**
                 * Documentation of the parameter.
                 */
                documentation: SymbolDisplayPart[];
                /**
                 * Display parts of the parameter.
                 */
                displayParts: SymbolDisplayPart[];
                /**
                 * Whether the parameter is optional or not.
                 */
                isOptional: boolean;
            }
            /**
             * Represents a single signature to show in signature help.
             */
            interface SignatureHelpItem {
                /**
                 * Whether the signature accepts a variable number of arguments.
                 */
                isVariadic: boolean;
                /**
                 * The prefix display parts.
                 */
                prefixDisplayParts: SymbolDisplayPart[];
                /**
                 * The suffix display parts.
                 */
                suffixDisplayParts: SymbolDisplayPart[];
                /**
                 * The separator display parts.
                 */
                separatorDisplayParts: SymbolDisplayPart[];
                /**
                 * The signature helps items for the parameters.
                 */
                parameters: SignatureHelpParameter[];
                /**
                 * The signature's documentation
                 */
                documentation: SymbolDisplayPart[];
                /**
                 * The signature's JSDoc tags
                 */
                tags: JSDocTagInfo[];
            }
            /**
             * Signature help items found in the response of a signature help request.
             */
            interface SignatureHelpItems {
                /**
                 * The signature help items.
                 */
                items: SignatureHelpItem[];
                /**
                 * The span for which signature help should appear on a signature
                 */
                applicableSpan: TextSpan;
                /**
                 * The item selected in the set of available help items.
                 */
                selectedItemIndex: number;
                /**
                 * The argument selected in the set of parameters.
                 */
                argumentIndex: number;
                /**
                 * The argument count
                 */
                argumentCount: number;
            }
            type SignatureHelpTriggerCharacter = "," | "(" | "<";
            type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
            /**
             * Arguments of a signature help request.
             */
            interface SignatureHelpRequestArgs extends FileLocationRequestArgs {
                /**
                 * Reason why signature help was invoked.
                 * See each individual possible
                 */
                triggerReason?: SignatureHelpTriggerReason;
            }
            type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
            /**
             * Signals that the user manually requested signature help.
             * The language service will unconditionally attempt to provide a result.
             */
            interface SignatureHelpInvokedReason {
                kind: "invoked";
                triggerCharacter?: undefined;
            }
            /**
             * Signals that the signature help request came from a user typing a character.
             * Depending on the character and the syntactic context, the request may or may not be served a result.
             */
            interface SignatureHelpCharacterTypedReason {
                kind: "characterTyped";
                /**
                 * Character that was responsible for triggering signature help.
                 */
                triggerCharacter: SignatureHelpTriggerCharacter;
            }
            /**
             * Signals that this signature help request came from typing a character or moving the cursor.
             * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.
             * The language service will unconditionally attempt to provide a result.
             * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.
             */
            interface SignatureHelpRetriggeredReason {
                kind: "retrigger";
                /**
                 * Character that was responsible for triggering signature help.
                 */
                triggerCharacter?: SignatureHelpRetriggerCharacter;
            }
            /**
             * Signature help request; value of command field is "signatureHelp".
             * Given a file location (file, line, col), return the signature
             * help.
             */
            interface SignatureHelpRequest extends FileLocationRequest {
                command: CommandTypes.SignatureHelp;
                arguments: SignatureHelpRequestArgs;
            }
            /**
             * Response object for a SignatureHelpRequest.
             */
            interface SignatureHelpResponse extends Response {
                body?: SignatureHelpItems;
            }
            type InlayHintKind = "Type" | "Parameter" | "Enum";
            interface InlayHintsRequestArgs extends FileRequestArgs {
                /**
                 * Start position of the span.
                 */
                start: number;
                /**
                 * Length of the span.
                 */
                length: number;
            }
            interface InlayHintsRequest extends Request {
                command: CommandTypes.ProvideInlayHints;
                arguments: InlayHintsRequestArgs;
            }
            interface InlayHintItem {
                text: string;
                position: Location;
                kind: InlayHintKind;
                whitespaceBefore?: boolean;
                whitespaceAfter?: boolean;
            }
            interface InlayHintsResponse extends Response {
                body?: InlayHintItem[];
            }
            /**
             * Synchronous request for semantic diagnostics of one file.
             */
            interface SemanticDiagnosticsSyncRequest extends FileRequest {
                command: CommandTypes.SemanticDiagnosticsSync;
                arguments: SemanticDiagnosticsSyncRequestArgs;
            }
            interface SemanticDiagnosticsSyncRequestArgs extends FileRequestArgs {
                includeLinePosition?: boolean;
            }
            /**
             * Response object for synchronous sematic diagnostics request.
             */
            interface SemanticDiagnosticsSyncResponse extends Response {
                body?: Diagnostic[] | DiagnosticWithLinePosition[];
            }
            interface SuggestionDiagnosticsSyncRequest extends FileRequest {
                command: CommandTypes.SuggestionDiagnosticsSync;
                arguments: SuggestionDiagnosticsSyncRequestArgs;
            }
            type SuggestionDiagnosticsSyncRequestArgs = SemanticDiagnosticsSyncRequestArgs;
            type SuggestionDiagnosticsSyncResponse = SemanticDiagnosticsSyncResponse;
            /**
             * Synchronous request for syntactic diagnostics of one file.
             */
            interface SyntacticDiagnosticsSyncRequest extends FileRequest {
                command: CommandTypes.SyntacticDiagnosticsSync;
                arguments: SyntacticDiagnosticsSyncRequestArgs;
            }
            interface SyntacticDiagnosticsSyncRequestArgs extends FileRequestArgs {
                includeLinePosition?: boolean;
            }
            /**
             * Response object for synchronous syntactic diagnostics request.
             */
            interface SyntacticDiagnosticsSyncResponse extends Response {
                body?: Diagnostic[] | DiagnosticWithLinePosition[];
            }
            /**
             * Arguments for GeterrForProject request.
             */
            interface GeterrForProjectRequestArgs {
                /**
                 * the file requesting project error list
                 */
                file: string;
                /**
                 * Delay in milliseconds to wait before starting to compute
                 * errors for the files in the file list
                 */
                delay: number;
            }
            /**
             * GeterrForProjectRequest request; value of command field is
             * "geterrForProject". It works similarly with 'Geterr', only
             * it request for every file in this project.
             */
            interface GeterrForProjectRequest extends Request {
                command: CommandTypes.GeterrForProject;
                arguments: GeterrForProjectRequestArgs;
            }
            /**
             * Arguments for geterr messages.
             */
            interface GeterrRequestArgs {
                /**
                 * List of file names for which to compute compiler errors.
                 * The files will be checked in list order.
                 */
                files: string[];
                /**
                 * Delay in milliseconds to wait before starting to compute
                 * errors for the files in the file list
                 */
                delay: number;
            }
            /**
             * Geterr request; value of command field is "geterr". Wait for
             * delay milliseconds and then, if during the wait no change or
             * reload messages have arrived for the first file in the files
             * list, get the syntactic errors for the file, field requests,
             * and then get the semantic errors for the file.  Repeat with a
             * smaller delay for each subsequent file on the files list.  Best
             * practice for an editor is to send a file list containing each
             * file that is currently visible, in most-recently-used order.
             */
            interface GeterrRequest extends Request {
                command: CommandTypes.Geterr;
                arguments: GeterrRequestArgs;
            }
            type RequestCompletedEventName = "requestCompleted";
            /**
             * Event that is sent when server have finished processing request with specified id.
             */
            interface RequestCompletedEvent extends Event {
                event: RequestCompletedEventName;
                body: RequestCompletedEventBody;
            }
            interface RequestCompletedEventBody {
                request_seq: number;
            }
            /**
             * Item of diagnostic information found in a DiagnosticEvent message.
             */
            interface Diagnostic {
                /**
                 * Starting file location at which text applies.
                 */
                start: Location;
                /**
                 * The last file location at which the text applies.
                 */
                end: Location;
                /**
                 * Text of diagnostic message.
                 */
                text: string;
                /**
                 * The category of the diagnostic message, e.g. "error", "warning", or "suggestion".
                 */
                category: string;
                reportsUnnecessary?: {};
                reportsDeprecated?: {};
                /**
                 * Any related spans the diagnostic may have, such as other locations relevant to an error, such as declarartion sites
                 */
                relatedInformation?: DiagnosticRelatedInformation[];
                /**
                 * The error code of the diagnostic message.
                 */
                code?: number;
                /**
                 * The name of the plugin reporting the message.
                 */
                source?: string;
            }
            interface DiagnosticWithFileName extends Diagnostic {
                /**
                 * Name of the file the diagnostic is in
                 */
                fileName: string;
            }
            /**
             * Represents additional spans returned with a diagnostic which are relevant to it
             */
            interface DiagnosticRelatedInformation {
                /**
                 * The category of the related information message, e.g. "error", "warning", or "suggestion".
                 */
                category: string;
                /**
                 * The code used ot identify the related information
                 */
                code: number;
                /**
                 * Text of related or additional information.
                 */
                message: string;
                /**
                 * Associated location
                 */
                span?: FileSpan;
            }
            interface DiagnosticEventBody {
                /**
                 * The file for which diagnostic information is reported.
                 */
                file: string;
                /**
                 * An array of diagnostic information items.
                 */
                diagnostics: Diagnostic[];
            }
            type DiagnosticEventKind = "semanticDiag" | "syntaxDiag" | "suggestionDiag";
            /**
             * Event message for DiagnosticEventKind event types.
             * These events provide syntactic and semantic errors for a file.
             */
            interface DiagnosticEvent extends Event {
                body?: DiagnosticEventBody;
                event: DiagnosticEventKind;
            }
            interface ConfigFileDiagnosticEventBody {
                /**
                 * The file which trigged the searching and error-checking of the config file
                 */
                triggerFile: string;
                /**
                 * The name of the found config file.
                 */
                configFile: string;
                /**
                 * An arry of diagnostic information items for the found config file.
                 */
                diagnostics: DiagnosticWithFileName[];
            }
            /**
             * Event message for "configFileDiag" event type.
             * This event provides errors for a found config file.
             */
            interface ConfigFileDiagnosticEvent extends Event {
                body?: ConfigFileDiagnosticEventBody;
                event: "configFileDiag";
            }
            type ProjectLanguageServiceStateEventName = "projectLanguageServiceState";
            interface ProjectLanguageServiceStateEvent extends Event {
                event: ProjectLanguageServiceStateEventName;
                body?: ProjectLanguageServiceStateEventBody;
            }
            interface ProjectLanguageServiceStateEventBody {
                /**
                 * Project name that has changes in the state of language service.
                 * For configured projects this will be the config file path.
                 * For external projects this will be the name of the projects specified when project was open.
                 * For inferred projects this event is not raised.
                 */
                projectName: string;
                /**
                 * True if language service state switched from disabled to enabled
                 * and false otherwise.
                 */
                languageServiceEnabled: boolean;
            }
            type ProjectsUpdatedInBackgroundEventName = "projectsUpdatedInBackground";
            interface ProjectsUpdatedInBackgroundEvent extends Event {
                event: ProjectsUpdatedInBackgroundEventName;
                body: ProjectsUpdatedInBackgroundEventBody;
            }
            interface ProjectsUpdatedInBackgroundEventBody {
                /**
                 * Current set of open files
                 */
                openFiles: string[];
            }
            type ProjectLoadingStartEventName = "projectLoadingStart";
            interface ProjectLoadingStartEvent extends Event {
                event: ProjectLoadingStartEventName;
                body: ProjectLoadingStartEventBody;
            }
            interface ProjectLoadingStartEventBody {
                /** name of the project */
                projectName: string;
                /** reason for loading */
                reason: string;
            }
            type ProjectLoadingFinishEventName = "projectLoadingFinish";
            interface ProjectLoadingFinishEvent extends Event {
                event: ProjectLoadingFinishEventName;
                body: ProjectLoadingFinishEventBody;
            }
            interface ProjectLoadingFinishEventBody {
                /** name of the project */
                projectName: string;
            }
            type SurveyReadyEventName = "surveyReady";
            interface SurveyReadyEvent extends Event {
                event: SurveyReadyEventName;
                body: SurveyReadyEventBody;
            }
            interface SurveyReadyEventBody {
                /** Name of the survey. This is an internal machine- and programmer-friendly name */
                surveyId: string;
            }
            type LargeFileReferencedEventName = "largeFileReferenced";
            interface LargeFileReferencedEvent extends Event {
                event: LargeFileReferencedEventName;
                body: LargeFileReferencedEventBody;
            }
            interface LargeFileReferencedEventBody {
                /**
                 * name of the large file being loaded
                 */
                file: string;
                /**
                 * size of the file
                 */
                fileSize: number;
                /**
                 * max file size allowed on the server
                 */
                maxFileSize: number;
            }
            /** @internal */
            type AnyEvent = RequestCompletedEvent | DiagnosticEvent | ConfigFileDiagnosticEvent | ProjectLanguageServiceStateEvent | TelemetryEvent | ProjectsUpdatedInBackgroundEvent | ProjectLoadingStartEvent | ProjectLoadingFinishEvent | SurveyReadyEvent | LargeFileReferencedEvent;
            /**
             * Arguments for reload request.
             */
            interface ReloadRequestArgs extends FileRequestArgs {
                /**
                 * Name of temporary file from which to reload file
                 * contents. May be same as file.
                 */
                tmpfile: string;
            }
            /**
             * Reload request message; value of command field is "reload".
             * Reload contents of file with name given by the 'file' argument
             * from temporary file with name given by the 'tmpfile' argument.
             * The two names can be identical.
             */
            interface ReloadRequest extends FileRequest {
                command: CommandTypes.Reload;
                arguments: ReloadRequestArgs;
            }
            /**
             * Response to "reload" request. This is just an acknowledgement, so
             * no body field is required.
             */
            interface ReloadResponse extends Response {
            }
            /**
             * Arguments for saveto request.
             */
            interface SavetoRequestArgs extends FileRequestArgs {
                /**
                 * Name of temporary file into which to save server's view of
                 * file contents.
                 */
                tmpfile: string;
            }
            /**
             * Saveto request message; value of command field is "saveto".
             * For debugging purposes, save to a temporaryfile (named by
             * argument 'tmpfile') the contents of file named by argument
             * 'file'.  The server does not currently send a response to a
             * "saveto" request.
             */
            interface SavetoRequest extends FileRequest {
                command: CommandTypes.Saveto;
                arguments: SavetoRequestArgs;
            }
            /**
             * Arguments for navto request message.
             */
            interface NavtoRequestArgs {
                /**
                 * Search term to navigate to from current location; term can
                 * be '.*' or an identifier prefix.
                 */
                searchValue: string;
                /**
                 *  Optional limit on the number of items to return.
                 */
                maxResultCount?: number;
                /**
                 * The file for the request (absolute pathname required).
                 */
                file?: string;
                /**
                 * Optional flag to indicate we want results for just the current file
                 * or the entire project.
                 */
                currentFileOnly?: boolean;
                projectFileName?: string;
            }
            /**
             * Navto request message; value of command field is "navto".
             * Return list of objects giving file locations and symbols that
             * match the search term given in argument 'searchTerm'.  The
             * context for the search is given by the named file.
             */
            interface NavtoRequest extends Request {
                command: CommandTypes.Navto;
                arguments: NavtoRequestArgs;
            }
            /**
             * An item found in a navto response.
             */
            interface NavtoItem extends FileSpan {
                /**
                 * The symbol's name.
                 */
                name: string;
                /**
                 * The symbol's kind (such as 'className' or 'parameterName').
                 */
                kind: ScriptElementKind;
                /**
                 * exact, substring, or prefix.
                 */
                matchKind: string;
                /**
                 * If this was a case sensitive or insensitive match.
                 */
                isCaseSensitive: boolean;
                /**
                 * Optional modifiers for the kind (such as 'public').
                 */
                kindModifiers?: string;
                /**
                 * Name of symbol's container symbol (if any); for example,
                 * the class name if symbol is a class member.
                 */
                containerName?: string;
                /**
                 * Kind of symbol's container symbol (if any).
                 */
                containerKind?: ScriptElementKind;
            }
            /**
             * Navto response message. Body is an array of navto items.  Each
             * item gives a symbol that matched the search term.
             */
            interface NavtoResponse extends Response {
                body?: NavtoItem[];
            }
            /**
             * Arguments for change request message.
             */
            interface ChangeRequestArgs extends FormatRequestArgs {
                /**
                 * Optional string to insert at location (file, line, offset).
                 */
                insertString?: string;
            }
            /**
             * Change request message; value of command field is "change".
             * Update the server's view of the file named by argument 'file'.
             * Server does not currently send a response to a change request.
             */
            interface ChangeRequest extends FileLocationRequest {
                command: CommandTypes.Change;
                arguments: ChangeRequestArgs;
            }
            /**
             * Response to "brace" request.
             */
            interface BraceResponse extends Response {
                body?: TextSpan[];
            }
            /**
             * Brace matching request; value of command field is "brace".
             * Return response giving the file locations of matching braces
             * found in file at location line, offset.
             */
            interface BraceRequest extends FileLocationRequest {
                command: CommandTypes.Brace;
            }
            /**
             * NavBar items request; value of command field is "navbar".
             * Return response giving the list of navigation bar entries
             * extracted from the requested file.
             */
            interface NavBarRequest extends FileRequest {
                command: CommandTypes.NavBar;
            }
            /**
             * NavTree request; value of command field is "navtree".
             * Return response giving the navigation tree of the requested file.
             */
            interface NavTreeRequest extends FileRequest {
                command: CommandTypes.NavTree;
            }
            interface NavigationBarItem {
                /**
                 * The item's display text.
                 */
                text: string;
                /**
                 * The symbol's kind (such as 'className' or 'parameterName').
                 */
                kind: ScriptElementKind;
                /**
                 * Optional modifiers for the kind (such as 'public').
                 */
                kindModifiers?: string;
                /**
                 * The definition locations of the item.
                 */
                spans: TextSpan[];
                /**
                 * Optional children.
                 */
                childItems?: NavigationBarItem[];
                /**
                 * Number of levels deep this item should appear.
                 */
                indent: number;
            }
            /** protocol.NavigationTree is identical to ts.NavigationTree, except using protocol.TextSpan instead of ts.TextSpan */
            interface NavigationTree {
                text: string;
                kind: ScriptElementKind;
                kindModifiers: string;
                spans: TextSpan[];
                nameSpan: TextSpan | undefined;
                childItems?: NavigationTree[];
            }
            type TelemetryEventName = "telemetry";
            interface TelemetryEvent extends Event {
                event: TelemetryEventName;
                body: TelemetryEventBody;
            }
            interface TelemetryEventBody {
                telemetryEventName: string;
                payload: any;
            }
            type TypesInstallerInitializationFailedEventName = "typesInstallerInitializationFailed";
            interface TypesInstallerInitializationFailedEvent extends Event {
                event: TypesInstallerInitializationFailedEventName;
                body: TypesInstallerInitializationFailedEventBody;
            }
            interface TypesInstallerInitializationFailedEventBody {
                message: string;
            }
            type TypingsInstalledTelemetryEventName = "typingsInstalled";
            interface TypingsInstalledTelemetryEventBody extends TelemetryEventBody {
                telemetryEventName: TypingsInstalledTelemetryEventName;
                payload: TypingsInstalledTelemetryEventPayload;
            }
            interface TypingsInstalledTelemetryEventPayload {
                /**
                 * Comma separated list of installed typing packages
                 */
                installedPackages: string;
                /**
                 * true if install request succeeded, otherwise - false
                 */
                installSuccess: boolean;
                /**
                 * version of typings installer
                 */
                typingsInstallerVersion: string;
            }
            type BeginInstallTypesEventName = "beginInstallTypes";
            type EndInstallTypesEventName = "endInstallTypes";
            interface BeginInstallTypesEvent extends Event {
                event: BeginInstallTypesEventName;
                body: BeginInstallTypesEventBody;
            }
            interface EndInstallTypesEvent extends Event {
                event: EndInstallTypesEventName;
                body: EndInstallTypesEventBody;
            }
            interface InstallTypesEventBody {
                /**
                 * correlation id to match begin and end events
                 */
                eventId: number;
                /**
                 * list of packages to install
                 */
                packages: readonly string[];
            }
            interface BeginInstallTypesEventBody extends InstallTypesEventBody {
            }
            interface EndInstallTypesEventBody extends InstallTypesEventBody {
                /**
                 * true if installation succeeded, otherwise false
                 */
                success: boolean;
            }
            interface NavBarResponse extends Response {
                body?: NavigationBarItem[];
            }
            interface NavTreeResponse extends Response {
                body?: NavigationTree;
            }
            interface CallHierarchyItem {
                name: string;
                kind: ScriptElementKind;
                kindModifiers?: string;
                file: string;
                span: TextSpan;
                selectionSpan: TextSpan;
                containerName?: string;
            }
            interface CallHierarchyIncomingCall {
                from: CallHierarchyItem;
                fromSpans: TextSpan[];
            }
            interface CallHierarchyOutgoingCall {
                to: CallHierarchyItem;
                fromSpans: TextSpan[];
            }
            interface PrepareCallHierarchyRequest extends FileLocationRequest {
                command: CommandTypes.PrepareCallHierarchy;
            }
            interface PrepareCallHierarchyResponse extends Response {
                readonly body: CallHierarchyItem | CallHierarchyItem[];
            }
            interface ProvideCallHierarchyIncomingCallsRequest extends FileLocationRequest {
                command: CommandTypes.ProvideCallHierarchyIncomingCalls;
            }
            interface ProvideCallHierarchyIncomingCallsResponse extends Response {
                readonly body: CallHierarchyIncomingCall[];
            }
            interface ProvideCallHierarchyOutgoingCallsRequest extends FileLocationRequest {
                command: CommandTypes.ProvideCallHierarchyOutgoingCalls;
            }
            interface ProvideCallHierarchyOutgoingCallsResponse extends Response {
                readonly body: CallHierarchyOutgoingCall[];
            }
            enum IndentStyle {
                None = "None",
                Block = "Block",
                Smart = "Smart"
            }
            enum SemicolonPreference {
                Ignore = "ignore",
                Insert = "insert",
                Remove = "remove"
            }
            interface EditorSettings {
                baseIndentSize?: number;
                indentSize?: number;
                tabSize?: number;
                newLineCharacter?: string;
                convertTabsToSpaces?: boolean;
                indentStyle?: IndentStyle | ts.IndentStyle;
                trimTrailingWhitespace?: boolean;
            }
            interface FormatCodeSettings extends EditorSettings {
                insertSpaceAfterCommaDelimiter?: boolean;
                insertSpaceAfterSemicolonInForStatements?: boolean;
                insertSpaceBeforeAndAfterBinaryOperators?: boolean;
                insertSpaceAfterConstructor?: boolean;
                insertSpaceAfterKeywordsInControlFlowStatements?: boolean;
                insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;
                insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;
                insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;
                insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;
                insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
                insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;
                insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
                insertSpaceAfterTypeAssertion?: boolean;
                insertSpaceBeforeFunctionParenthesis?: boolean;
                placeOpenBraceOnNewLineForFunctions?: boolean;
                placeOpenBraceOnNewLineForControlBlocks?: boolean;
                insertSpaceBeforeTypeAnnotation?: boolean;
                semicolons?: SemicolonPreference;
            }
            interface UserPreferences {
                readonly disableSuggestions?: boolean;
                readonly quotePreference?: "auto" | "double" | "single";
                /**
                 * If enabled, TypeScript will search through all external modules' exports and add them to the completions list.
                 * This affects lone identifier completions but not completions on the right hand side of `obj.`.
                 */
                readonly includeCompletionsForModuleExports?: boolean;
                /**
                 * Enables auto-import-style completions on partially-typed import statements. E.g., allows
                 * `import write|` to be completed to `import { writeFile } from "fs"`.
                 */
                readonly includeCompletionsForImportStatements?: boolean;
                /**
                 * Allows completions to be formatted with snippet text, indicated by `CompletionItem["isSnippet"]`.
                 */
                readonly includeCompletionsWithSnippetText?: boolean;
                /**
                 * If enabled, the completion list will include completions with invalid identifier names.
                 * For those entries, The `insertText` and `replacementSpan` properties will be set to change from `.x` property access to `["x"]`.
                 */
                readonly includeCompletionsWithInsertText?: boolean;
                /**
                 * Unless this option is `false`, or `includeCompletionsWithInsertText` is not enabled,
                 * member completion lists triggered with `.` will include entries on potentially-null and potentially-undefined
                 * values, with insertion text to replace preceding `.` tokens with `?.`.
                 */
                readonly includeAutomaticOptionalChainCompletions?: boolean;
                /**
                 * If enabled, completions for class members (e.g. methods and properties) will include
                 * a whole declaration for the member.
                 * E.g., `class A { f| }` could be completed to `class A { foo(): number {} }`, instead of
                 * `class A { foo }`.
                 */
                readonly includeCompletionsWithClassMemberSnippets?: boolean;
                /**
                 * If enabled, object literal methods will have a method declaration completion entry in addition
                 * to the regular completion entry containing just the method name.
                 * E.g., `const objectLiteral: T = { f| }` could be completed to `const objectLiteral: T = { foo(): void {} }`,
                 * in addition to `const objectLiteral: T = { foo }`.
                 */
                readonly includeCompletionsWithObjectLiteralMethodSnippets?: boolean;
                /**
                 * Indicates whether {@link CompletionEntry.labelDetails completion entry label details} are supported.
                 * If not, contents of `labelDetails` may be included in the {@link CompletionEntry.name} property.
                 */
                readonly useLabelDetailsInCompletionEntries?: boolean;
                readonly allowIncompleteCompletions?: boolean;
                readonly importModuleSpecifierPreference?: "shortest" | "project-relative" | "relative" | "non-relative";
                /** Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js" */
                readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";
                readonly allowTextChangesInNewFiles?: boolean;
                readonly lazyConfiguredProjectsFromExternalProject?: boolean;
                readonly providePrefixAndSuffixTextForRename?: boolean;
                readonly provideRefactorNotApplicableReason?: boolean;
                readonly allowRenameOfImportPath?: boolean;
                readonly includePackageJsonAutoImports?: "auto" | "on" | "off";
                readonly jsxAttributeCompletionStyle?: "auto" | "braces" | "none";
                readonly displayPartsForJSDoc?: boolean;
                readonly generateReturnInDocTemplate?: boolean;
                readonly includeInlayParameterNameHints?: "none" | "literals" | "all";
                readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;
                readonly includeInlayFunctionParameterTypeHints?: boolean;
                readonly includeInlayVariableTypeHints?: boolean;
                readonly includeInlayVariableTypeHintsWhenTypeMatchesName?: boolean;
                readonly includeInlayPropertyDeclarationTypeHints?: boolean;
                readonly includeInlayFunctionLikeReturnTypeHints?: boolean;
                readonly includeInlayEnumMemberValueHints?: boolean;
                readonly autoImportFileExcludePatterns?: string[];
                /**
                 * Indicates whether imports should be organized in a case-insensitive manner.
                 */
                readonly organizeImportsIgnoreCase?: "auto" | boolean;
                /**
                 * Indicates whether imports should be organized via an "ordinal" (binary) comparison using the numeric value
                 * of their code points, or via "unicode" collation (via the
                 * [Unicode Collation Algorithm](https://unicode.org/reports/tr10/#Scope)) using rules associated with the locale
                 * specified in {@link organizeImportsCollationLocale}.
                 *
                 * Default: `"ordinal"`.
                 */
                readonly organizeImportsCollation?: "ordinal" | "unicode";
                /**
                 * Indicates the locale to use for "unicode" collation. If not specified, the locale `"en"` is used as an invariant
                 * for the sake of consistent sorting. Use `"auto"` to use the detected UI locale.
                 *
                 * This preference is ignored if {@link organizeImportsCollation} is not `"unicode"`.
                 *
                 * Default: `"en"`
                 */
                readonly organizeImportsCollationLocale?: string;
                /**
                 * Indicates whether numeric collation should be used for digit sequences in strings. When `true`, will collate
                 * strings such that `a1z < a2z < a100z`. When `false`, will collate strings such that `a1z < a100z < a2z`.
                 *
                 * This preference is ignored if {@link organizeImportsCollation} is not `"unicode"`.
                 *
                 * Default: `false`
                 */
                readonly organizeImportsNumericCollation?: boolean;
                /**
                 * Indicates whether accents and other diacritic marks are considered unequal for the purpose of collation. When
                 * `true`, characters with accents and other diacritics will be collated in the order defined by the locale specified
                 * in {@link organizeImportsCollationLocale}.
                 *
                 * This preference is ignored if {@link organizeImportsCollation} is not `"unicode"`.
                 *
                 * Default: `true`
                 */
                readonly organizeImportsAccentCollation?: boolean;
                /**
                 * Indicates whether upper case or lower case should sort first. When `false`, the default order for the locale
                 * specified in {@link organizeImportsCollationLocale} is used.
                 *
                 * This preference is ignored if {@link organizeImportsCollation} is not `"unicode"`. This preference is also
                 * ignored if we are using case-insensitive sorting, which occurs when {@link organizeImportsIgnoreCase} is `true`,
                 * or if {@link organizeImportsIgnoreCase} is `"auto"` and the auto-detected case sensitivity is determined to be
                 * case-insensitive.
                 *
                 * Default: `false`
                 */
                readonly organizeImportsCaseFirst?: "upper" | "lower" | false;
                /**
                 * Indicates whether {@link ReferencesResponseItem.lineText} is supported.
                 */
                readonly disableLineTextInReferences?: boolean;
            }
            interface CompilerOptions {
                allowJs?: boolean;
                allowSyntheticDefaultImports?: boolean;
                allowUnreachableCode?: boolean;
                allowUnusedLabels?: boolean;
                alwaysStrict?: boolean;
                baseUrl?: string;
                charset?: string;
                checkJs?: boolean;
                declaration?: boolean;
                declarationDir?: string;
                disableSizeLimit?: boolean;
                downlevelIteration?: boolean;
                emitBOM?: boolean;
                emitDecoratorMetadata?: boolean;
                experimentalDecorators?: boolean;
                forceConsistentCasingInFileNames?: boolean;
                importHelpers?: boolean;
                inlineSourceMap?: boolean;
                inlineSources?: boolean;
                isolatedModules?: boolean;
                jsx?: JsxEmit | ts.JsxEmit;
                lib?: string[];
                locale?: string;
                mapRoot?: string;
                maxNodeModuleJsDepth?: number;
                module?: ModuleKind | ts.ModuleKind;
                moduleResolution?: ModuleResolutionKind | ts.ModuleResolutionKind;
                newLine?: NewLineKind | ts.NewLineKind;
                noEmit?: boolean;
                noEmitHelpers?: boolean;
                noEmitOnError?: boolean;
                noErrorTruncation?: boolean;
                noFallthroughCasesInSwitch?: boolean;
                noImplicitAny?: boolean;
                noImplicitReturns?: boolean;
                noImplicitThis?: boolean;
                noUnusedLocals?: boolean;
                noUnusedParameters?: boolean;
                noImplicitUseStrict?: boolean;
                noLib?: boolean;
                noResolve?: boolean;
                out?: string;
                outDir?: string;
                outFile?: string;
                paths?: MapLike<string[]>;
                plugins?: PluginImport[];
                preserveConstEnums?: boolean;
                preserveSymlinks?: boolean;
                project?: string;
                reactNamespace?: string;
                removeComments?: boolean;
                references?: ProjectReference[];
                rootDir?: string;
                rootDirs?: string[];
                skipLibCheck?: boolean;
                skipDefaultLibCheck?: boolean;
                sourceMap?: boolean;
                sourceRoot?: string;
                strict?: boolean;
                strictNullChecks?: boolean;
                suppressExcessPropertyErrors?: boolean;
                suppressImplicitAnyIndexErrors?: boolean;
                useDefineForClassFields?: boolean;
                target?: ScriptTarget | ts.ScriptTarget;
                traceResolution?: boolean;
                resolveJsonModule?: boolean;
                types?: string[];
                /** Paths used to used to compute primary types search locations */
                typeRoots?: string[];
                [option: string]: CompilerOptionsValue | undefined;
            }
            enum JsxEmit {
                None = "None",
                Preserve = "Preserve",
                ReactNative = "ReactNative",
                React = "React"
            }
            enum ModuleKind {
                None = "None",
                CommonJS = "CommonJS",
                AMD = "AMD",
                UMD = "UMD",
                System = "System",
                ES6 = "ES6",
                ES2015 = "ES2015",
                ESNext = "ESNext"
            }
            enum ModuleResolutionKind {
                Classic = "Classic",
                Node = "Node"
            }
            enum NewLineKind {
                Crlf = "Crlf",
                Lf = "Lf"
            }
            enum ScriptTarget {
                ES3 = "ES3",
                ES5 = "ES5",
                ES6 = "ES6",
                ES2015 = "ES2015",
                ES2016 = "ES2016",
                ES2017 = "ES2017",
                ES2018 = "ES2018",
                ES2019 = "ES2019",
                ES2020 = "ES2020",
                ES2021 = "ES2021",
                ES2022 = "ES2022",
                ESNext = "ESNext"
            }
            enum ClassificationType {
                comment = 1,
                identifier = 2,
                keyword = 3,
                numericLiteral = 4,
                operator = 5,
                stringLiteral = 6,
                regularExpressionLiteral = 7,
                whiteSpace = 8,
                text = 9,
                punctuation = 10,
                className = 11,
                enumName = 12,
                interfaceName = 13,
                moduleName = 14,
                typeParameterName = 15,
                typeAliasName = 16,
                parameterName = 17,
                docCommentTagName = 18,
                jsxOpenTagName = 19,
                jsxCloseTagName = 20,
                jsxSelfClosingTagName = 21,
                jsxAttribute = 22,
                jsxText = 23,
                jsxAttributeStringLiteralValue = 24,
                bigintLiteral = 25
            }
        }
        interface CompressedData {
            length: number;
            compressionKind: string;
            data: any;
        }
        type ModuleImportResult = {
            module: {};
            error: undefined;
        } | {
            module: undefined;
            error: {
                stack?: string;
                message?: string;
            };
        };
        /** @deprecated Use {@link ModuleImportResult} instead. */
        type RequireResult = ModuleImportResult;
        interface ServerHost extends System {
            watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
            watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
            setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
            clearTimeout(timeoutId: any): void;
            setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;
            clearImmediate(timeoutId: any): void;
            gc?(): void;
            trace?(s: string): void;
            require?(initialPath: string, moduleName: string): ModuleImportResult;
            /** @internal */
            importPlugin?(root: string, moduleName: string): Promise<ModuleImportResult>;
        }
        function createInstallTypingsRequest(project: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string>, cachePath?: string): DiscoverTypings;
        function toNormalizedPath(fileName: string): NormalizedPath;
        function normalizedPathToPath(normalizedPath: NormalizedPath, currentDirectory: string, getCanonicalFileName: (f: string) => string): Path;
        function asNormalizedPath(fileName: string): NormalizedPath;
        function createNormalizedPathMap<T>(): NormalizedPathMap<T>;
        function isInferredProjectName(name: string): boolean;
        function makeInferredProjectName(counter: number): string;
        /** @internal */
        function makeAutoImportProviderProjectName(counter: number): string;
        /** @internal */
        function makeAuxiliaryProjectName(counter: number): string;
        function createSortedArray<T>(): SortedArray<T>;
        enum LogLevel {
            terse = 0,
            normal = 1,
            requestTime = 2,
            verbose = 3
        }
        const emptyArray: SortedReadonlyArray<never>;
        interface Logger {
            close(): void;
            hasLevel(level: LogLevel): boolean;
            loggingEnabled(): boolean;
            perftrc(s: string): void;
            info(s: string): void;
            startGroup(): void;
            endGroup(): void;
            msg(s: string, type?: Msg): void;
            getLogFileName(): string | undefined;
        }
        enum Msg {
            Err = "Err",
            Info = "Info",
            Perf = "Perf"
        }
        namespace Errors {
            function ThrowNoProject(): never;
            function ThrowProjectLanguageServiceDisabled(): never;
            function ThrowProjectDoesNotContainDocument(fileName: string, project: Project): never;
        }
        type NormalizedPath = string & {
            __normalizedPathTag: any;
        };
        interface NormalizedPathMap<T> {
            get(path: NormalizedPath): T | undefined;
            set(path: NormalizedPath, value: T): void;
            contains(path: NormalizedPath): boolean;
            remove(path: NormalizedPath): void;
        }
        /** @internal */
        interface ProjectOptions {
            configHasExtendsProperty: boolean;
            /**
             * true if config file explicitly listed files
             */
            configHasFilesProperty: boolean;
            configHasIncludeProperty: boolean;
            configHasExcludeProperty: boolean;
        }
        /** @internal */
        function getBaseConfigFileName(configFilePath: NormalizedPath): "tsconfig.json" | "jsconfig.json" | undefined;
        /** @internal */
        function removeSorted<T>(array: SortedArray<T>, remove: T, compare: Comparer<T>): void;
        /** @internal */
        function indent(str: string): string;
        /**
         * Put stringified JSON on the next line, indented.
         *
         * @internal
         */
        function stringifyIndented(json: {}): string;
        /** @internal */
        class ThrottledOperations {
            private readonly host;
            private readonly pendingTimeouts;
            private readonly logger?;
            constructor(host: ServerHost, logger: Logger);
            /**
             * Wait `number` milliseconds and then invoke `cb`.  If, while waiting, schedule
             * is called again with the same `operationId`, cancel this operation in favor
             * of the new one.  (Note that the amount of time the canceled operation had been
             * waiting does not affect the amount of time that the new operation waits.)
             */
            schedule(operationId: string, delay: number, cb: () => void): void;
            cancel(operationId: string): boolean;
            private static run;
        }
        /** @internal */
        class GcTimer {
            private readonly host;
            private readonly delay;
            private readonly logger;
            private timerId;
            constructor(host: ServerHost, delay: number, logger: Logger);
            scheduleCollect(): void;
            private static run;
        }
        function isDynamicFileName(fileName: NormalizedPath): boolean;
        interface ScriptInfoVersion {
            svc: number;
            text: number;
        }
        /** @internal */
        class TextStorage {
            private readonly host;
            private readonly info;
            version: ScriptInfoVersion;
            /**
             * Generated only on demand (based on edits, or information requested)
             * The property text is set to undefined when edits happen on the cache
             */
            private svc;
            /**
             * Stores the text when there are no changes to the script version cache
             * The script version cache is generated on demand and text is still retained.
             * Only on edits to the script version cache, the text will be set to undefined
             */
            private text;
            /**
             * Line map for the text when there is no script version cache present
             */
            private lineMap;
            /**
             * When a large file is loaded, text will artificially be set to "".
             * In order to be able to report correct telemetry, we store the actual
             * file size in this case.  (In other cases where text === "", e.g.
             * for mixed content or dynamic files, fileSize will be undefined.)
             */
            private fileSize;
            /**
             * True if the text is for the file thats open in the editor
             */
            isOpen: boolean;
            /**
             * True if the text present is the text from the file on the disk
             */
            private ownFileText;
            /**
             * True when reloading contents of file from the disk is pending
             */
            private pendingReloadFromDisk;
            constructor(host: ServerHost, info: ScriptInfo, initialVersion?: ScriptInfoVersion);
            getVersion(): string;
            hasScriptVersionCache_TestOnly(): boolean;
            useScriptVersionCache_TestOnly(): void;
            private resetSourceMapInfo;
            /** Public for testing */
            useText(newText?: string): void;
            edit(start: number, end: number, newText: string): void;
            /**
             * Set the contents as newText
             * returns true if text changed
             */
            reload(newText: string): boolean;
            /**
             * Reads the contents from tempFile(if supplied) or own file and sets it as contents
             * returns true if text changed
             */
            reloadWithFileText(tempFileName?: string): boolean;
            /**
             * Reloads the contents from the file if there is no pending reload from disk or the contents of file are same as file text
             * returns true if text changed
             */
            reloadFromDisk(): boolean;
            delayReloadFromFileIntoText(): void;
            /**
             * For telemetry purposes, we would like to be able to report the size of the file.
             * However, we do not want telemetry to require extra file I/O so we report a size
             * that may be stale (e.g. may not reflect change made on disk since the last reload).
             * NB: Will read from disk if the file contents have never been loaded because
             * telemetry falsely indicating size 0 would be counter-productive.
             */
            getTelemetryFileSize(): number;
            getSnapshot(): IScriptSnapshot;
            getAbsolutePositionAndLineText(line: number): AbsolutePositionAndLineText;
            /**
             *  @param line 0 based index
             */
            lineToTextSpan(line: number): TextSpan;
            /**
             * @param line 1 based index
             * @param offset 1 based index
             */
            lineOffsetToPosition(line: number, offset: number, allowEdits?: true): number;
            positionToLineOffset(position: number): protocol.Location;
            private getFileTextAndSize;
            private switchToScriptVersionCache;
            private useScriptVersionCacheIfValidOrOpen;
            private getOrLoadText;
            private getLineMap;
            getLineInfo(): LineInfo;
        }
        /** @internal */
        interface DocumentRegistrySourceFileCache {
            key: DocumentRegistryBucketKeyWithMode;
            sourceFile: SourceFile;
        }
        /** @internal */
        interface SourceMapFileWatcher {
            watcher: FileWatcher;
            sourceInfos?: Set<Path>;
        }
        class ScriptInfo {
            private readonly host;
            readonly fileName: NormalizedPath;
            readonly scriptKind: ScriptKind;
            readonly hasMixedContent: boolean;
            readonly path: Path;
            /**
             * All projects that include this file
             */
            readonly containingProjects: Project[];
            private formatSettings;
            private preferences;
            /** @internal */
            fileWatcher: FileWatcher | undefined;
            private textStorage;
            /** @internal */
            readonly isDynamic: boolean;
            /**
             * Set to real path if path is different from info.path
             *
             * @internal
             */
            private realpath;
            /** @internal */
            cacheSourceFile: DocumentRegistrySourceFileCache | undefined;
            /** @internal */
            mTime?: number;
            /** @internal */
            sourceFileLike?: SourceFileLike;
            /** @internal */
            sourceMapFilePath?: Path | SourceMapFileWatcher | false;
            /** @internal */
            declarationInfoPath?: Path;
            /** @internal */
            sourceInfos?: Set<Path>;
            /** @internal */
            documentPositionMapper?: DocumentPositionMapper | false;
            constructor(host: ServerHost, fileName: NormalizedPath, scriptKind: ScriptKind, hasMixedContent: boolean, path: Path, initialVersion?: ScriptInfoVersion);
            /** @internal */
            getVersion(): ScriptInfoVersion;
            /** @internal */
            getTelemetryFileSize(): number;
            /** @internal */
            isDynamicOrHasMixedContent(): boolean;
            isScriptOpen(): boolean;
            open(newText: string): void;
            close(fileExists?: boolean): void;
            getSnapshot(): IScriptSnapshot;
            private ensureRealPath;
            /** @internal */
            getRealpathIfDifferent(): Path | undefined;
            /**
             * @internal
             * Does not compute realpath; uses precomputed result. Use `ensureRealPath`
             * first if a definite result is needed.
             */
            isSymlink(): boolean | undefined;
            getFormatCodeSettings(): FormatCodeSettings | undefined;
            getPreferences(): protocol.UserPreferences | undefined;
            attachToProject(project: Project): boolean;
            isAttached(project: Project): boolean;
            detachFromProject(project: Project): void;
            detachAllProjects(): void;
            getDefaultProject(): Project;
            registerFileUpdate(): void;
            setOptions(formatSettings: FormatCodeSettings, preferences: protocol.UserPreferences | undefined): void;
            getLatestVersion(): string;
            saveTo(fileName: string): void;
            /** @internal */
            delayReloadNonMixedContentFile(): void;
            reloadFromFile(tempFileName?: NormalizedPath): boolean;
            /** @internal */
            getAbsolutePositionAndLineText(line: number): AbsolutePositionAndLineText;
            editContent(start: number, end: number, newText: string): void;
            markContainingProjectsAsDirty(): void;
            isOrphan(): boolean;
            /** @internal */
            isContainedByBackgroundProject(): boolean;
            /**
             *  @param line 1 based index
             */
            lineToTextSpan(line: number): TextSpan;
            /**
             * @param line 1 based index
             * @param offset 1 based index
             */
            lineOffsetToPosition(line: number, offset: number): number;
            /** @internal */
            lineOffsetToPosition(line: number, offset: number, allowEdits?: true): number;
            positionToLineOffset(position: number): protocol.Location;
            isJavaScript(): boolean;
            /** @internal */
            getLineInfo(): LineInfo;
            /** @internal */
            closeSourceMapFileWatcher(): void;
        }
        interface InstallPackageOptionsWithProject extends InstallPackageOptions {
            projectName: string;
            projectRootPath: Path;
        }
        interface ITypingsInstaller {
            isKnownTypesPackageName(name: string): boolean;
            installPackage(options: InstallPackageOptionsWithProject): Promise<ApplyCodeActionCommandResult>;
            enqueueInstallTypingsRequest(p: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string> | undefined): void;
            attach(projectService: ProjectService): void;
            onProjectClosed(p: Project): void;
            readonly globalTypingsCacheLocation: string | undefined;
        }
        const nullTypingsInstaller: ITypingsInstaller;
        /** @internal */
        class TypingsCache {
            private readonly installer;
            private readonly perProjectCache;
            constructor(installer: ITypingsInstaller);
            isKnownTypesPackageName(name: string): boolean;
            installPackage(options: InstallPackageOptionsWithProject): Promise<ApplyCodeActionCommandResult>;
            enqueueInstallTypingsForProject(project: Project, unresolvedImports: SortedReadonlyArray<string> | undefined, forceRefresh: boolean): void;
            updateTypingsForProject(projectName: string, compilerOptions: CompilerOptions, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string>, newTypings: string[]): SortedReadonlyArray<string>;
            onProjectClosed(project: Project): void;
        }
        /** @internal */
        function countEachFileTypes(infos: ScriptInfo[], includeSizes?: boolean): FileStats;
        function allRootFilesAreJsOrDts(project: Project): boolean;
        function allFilesAreJsOrDts(project: Project): boolean;
        /** @internal */
        function hasNoTypeScriptSource(fileNames: string[]): boolean;
        /** @internal */
        function isInferredProject(project: Project): project is InferredProject;
        /** @internal */
        function isConfiguredProject(project: Project): project is ConfiguredProject;
        /** @internal */
        function isExternalProject(project: Project): project is ExternalProject;
        enum ProjectKind {
            Inferred = 0,
            Configured = 1,
            External = 2,
            AutoImportProvider = 3,
            Auxiliary = 4
        }
        /** @internal */
        type Mutable<T> = {
            -readonly [K in keyof T]: T[K];
        };
        /** @internal */
        interface ProjectFilesWithTSDiagnostics extends protocol.ProjectFiles {
            projectErrors: readonly Diagnostic[];
        }
        interface PluginCreateInfo {
            project: Project;
            languageService: LanguageService;
            languageServiceHost: LanguageServiceHost;
            serverHost: ServerHost;
            session?: Session<unknown>;
            config: any;
        }
        interface PluginModule {
            create(createInfo: PluginCreateInfo): LanguageService;
            getExternalFiles?(proj: Project): string[];
            onConfigurationChanged?(config: any): void;
        }
        interface PluginModuleWithName {
            name: string;
            module: PluginModule;
        }
        type PluginModuleFactory = (mod: {
            typescript: typeof ts;
        }) => PluginModule;
        /** @internal */
        interface BeginEnablePluginResult {
            pluginConfigEntry: PluginImport;
            pluginConfigOverrides: Map<string, any> | undefined;
            resolvedModule: PluginModuleFactory | undefined;
            errorLogs: string[] | undefined;
        }
        /**
         * The project root can be script info - if root is present,
         * or it could be just normalized path if root wasn't present on the host(only for non inferred project)
         *
         * @internal
         */
        interface ProjectRootFile {
            fileName: NormalizedPath;
            info?: ScriptInfo;
        }
        /** @internal */
        interface EmitResult {
            emitSkipped: boolean;
            diagnostics: readonly Diagnostic[];
        }
        abstract class Project implements LanguageServiceHost, ModuleResolutionHost {
            readonly projectKind: ProjectKind;
            readonly projectService: ProjectService;
            private documentRegistry;
            private compilerOptions;
            compileOnSaveEnabled: boolean;
            protected watchOptions: WatchOptions | undefined;
            private rootFiles;
            private rootFilesMap;
            private program;
            private externalFiles;
            private missingFilesMap;
            private generatedFilesMap;
            /** @internal */
            protected readonly plugins: PluginModuleWithName[];
            /**
             * This is map from files to unresolved imports in it
             * Maop does not contain entries for files that do not have unresolved imports
             * This helps in containing the set of files to invalidate
             *
             * @internal
             */
            cachedUnresolvedImportsPerFile: Map<ts.Path, readonly string[]>;
            /** @internal */
            lastCachedUnresolvedImportsList: SortedReadonlyArray<string> | undefined;
            /** @internal */
            private hasAddedorRemovedFiles;
            /** @internal */
            private hasAddedOrRemovedSymlinks;
            /** @internal */
            lastFileExceededProgramSize: string | undefined;
            protected languageService: LanguageService;
            languageServiceEnabled: boolean;
            readonly trace?: (s: string) => void;
            readonly realpath?: (path: string) => string;
            /** @internal */
            hasInvalidatedResolutions: HasInvalidatedResolutions | undefined;
            /** @internal */
            resolutionCache: ResolutionCache;
            private builderState;
            /**
             * Set of files names that were updated since the last call to getChangesSinceVersion.
             */
            private updatedFileNames;
            /**
             * Set of files that was returned from the last call to getChangesSinceVersion.
             */
            private lastReportedFileNames;
            /**
             * Last version that was reported.
             */
            private lastReportedVersion;
            /**
             * Current project's program version. (incremented everytime new program is created that is not complete reuse from the old one)
             * This property is changed in 'updateGraph' based on the set of files in program
             */
            private projectProgramVersion;
            /**
             * Current version of the project state. It is changed when:
             * - new root file was added/removed
             * - edit happen in some file that is currently included in the project.
             * This property is different from projectStructureVersion since in most cases edits don't affect set of files in the project
             */
            private projectStateVersion;
            protected projectErrors: Diagnostic[] | undefined;
            protected isInitialLoadPending: () => boolean;
            /** @internal */
            dirty: boolean;
            /** @internal */
            typingFiles: SortedReadonlyArray<string>;
            /** @internal */
            originalConfiguredProjects: Set<NormalizedPath> | undefined;
            /** @internal */
            private packageJsonsForAutoImport;
            /** @internal */
            private noDtsResolutionProject?;
            /** @internal */
            getResolvedProjectReferenceToRedirect(_fileName: string): ResolvedProjectReference | undefined;
            /** @internal */ useSourceOfProjectReferenceRedirect?(): boolean;
            /** @internal */ getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
            private readonly cancellationToken;
            isNonTsProject(): boolean;
            isJsOnlyProject(): boolean;
            static resolveModule(moduleName: string, initialDir: string, host: ServerHost, log: (message: string) => void, logErrors?: (message: string) => void): {} | undefined;
            /** @internal */
            static importServicePluginAsync(moduleName: string, initialDir: string, host: ServerHost, log: (message: string) => void, logErrors?: (message: string) => void): Promise<{} | undefined>;
            /** @internal */
            readonly currentDirectory: string;
            /** @internal */
            readonly projectName: string;
            /** @internal */
            directoryStructureHost: DirectoryStructureHost;
            /** @internal */
            readonly getCanonicalFileName: GetCanonicalFileName;
            /** @internal */
            private exportMapCache;
            /** @internal */
            private changedFilesForExportMapCache;
            /** @internal */
            private moduleSpecifierCache;
            /** @internal */
            private symlinks;
            /** @internal */
            autoImportProviderHost: AutoImportProviderProject | false | undefined;
            /** @internal */
            protected typeAcquisition: TypeAcquisition | undefined;
            /** @internal */
            createHash: ((data: string) => string) | undefined;
            /** @internal */
            constructor(projectName: string, projectKind: ProjectKind, projectService: ProjectService, documentRegistry: DocumentRegistry, hasExplicitListOfFiles: boolean, lastFileExceededProgramSize: string | undefined, compilerOptions: CompilerOptions, compileOnSaveEnabled: boolean, watchOptions: WatchOptions | undefined, directoryStructureHost: DirectoryStructureHost, currentDirectory: string | undefined);
            isKnownTypesPackageName(name: string): boolean;
            installPackage(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;
            /** @internal */
            getGlobalTypingsCacheLocation(): string | undefined;
            private get typingsCache();
            /** @internal */
            getSymlinkCache(): SymlinkCache;
            getCompilationSettings(): ts.CompilerOptions;
            getCompilerOptions(): ts.CompilerOptions;
            getNewLine(): string;
            getProjectVersion(): string;
            getProjectReferences(): readonly ProjectReference[] | undefined;
            getScriptFileNames(): string[];
            private getOrCreateScriptInfoAndAttachToProject;
            getScriptKind(fileName: string): ts.ScriptKind;
            getScriptVersion(filename: string): string;
            getScriptSnapshot(filename: string): IScriptSnapshot | undefined;
            getCancellationToken(): HostCancellationToken;
            getCurrentDirectory(): string;
            getDefaultLibFileName(): string;
            useCaseSensitiveFileNames(): boolean;
            readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
            readFile(fileName: string): string | undefined;
            writeFile(fileName: string, content: string): void;
            fileExists(file: string): boolean;
            /** @internal */
            resolveModuleNameLiterals(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
            getModuleResolutionCache(): ModuleResolutionCache | undefined;
            /** @internal */
            resolveTypeReferenceDirectiveReferences<T extends string | FileReference>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
            directoryExists(path: string): boolean;
            getDirectories(path: string): string[];
            /** @internal */
            getCachedDirectoryStructureHost(): CachedDirectoryStructureHost;
            /** @internal */
            toPath(fileName: string): ts.Path;
            /** @internal */
            watchDirectoryOfFailedLookupLocation(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags): ts.FileWatcher;
            /** @internal */
            watchAffectingFileLocation(file: string, cb: FileWatcherCallback): ts.FileWatcher;
            /** @internal */
            clearInvalidateResolutionOfFailedLookupTimer(): boolean;
            /** @internal */
            scheduleInvalidateResolutionsOfFailedLookupLocations(): void;
            /** @internal */
            invalidateResolutionsOfFailedLookupLocations(): void;
            /** @internal */
            onInvalidatedResolution(): void;
            /** @internal */
            watchTypeRootsDirectory(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags): ts.FileWatcher;
            /** @internal */
            hasChangedAutomaticTypeDirectiveNames(): boolean;
            /** @internal */
            onChangedAutomaticTypeDirectiveNames(): void;
            /** @internal */
            getGlobalCache(): string | undefined;
            /** @internal */
            globalCacheResolutionModuleName: typeof JsTyping.nonRelativeModuleNameForTypingCache;
            /** @internal */
            fileIsOpen(filePath: Path): boolean;
            /** @internal */
            writeLog(s: string): void;
            log(s: string): void;
            error(s: string): void;
            private setInternalCompilerOptionsForEmittingJsFiles;
            /**
             * Get the errors that dont have any file name associated
             */
            getGlobalProjectErrors(): readonly Diagnostic[];
            /**
             * Get all the project errors
             */
            getAllProjectErrors(): readonly Diagnostic[];
            setProjectErrors(projectErrors: Diagnostic[] | undefined): void;
            getLanguageService(ensureSynchronized?: boolean): LanguageService;
            /** @internal */
            getSourceMapper(): SourceMapper;
            /** @internal */
            clearSourceMapperCache(): void;
            /** @internal */
            getDocumentPositionMapper(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined;
            /** @internal */
            getSourceFileLike(fileName: string): ts.SourceFileLike | undefined;
            /** @internal */
            shouldEmitFile(scriptInfo: ScriptInfo | undefined): boolean | undefined;
            getCompileOnSaveAffectedFileList(scriptInfo: ScriptInfo): string[];
            /**
             * Returns true if emit was conducted
             */
            emitFile(scriptInfo: ScriptInfo, writeFile: (path: string, data: string, writeByteOrderMark?: boolean) => void): EmitResult;
            enableLanguageService(): void;
            disableLanguageService(lastFileExceededProgramSize?: string): void;
            getProjectName(): string;
            protected removeLocalTypingsFromTypeAcquisition(newTypeAcquisition: TypeAcquisition): TypeAcquisition;
            getExternalFiles(): SortedReadonlyArray<string>;
            getSourceFile(path: Path): ts.SourceFile | undefined;
            /** @internal */
            getSourceFileOrConfigFile(path: Path): SourceFile | undefined;
            close(): void;
            private detachScriptInfoIfNotRoot;
            isClosed(): boolean;
            hasRoots(): boolean;
            /** @internal */
            isOrphan(): boolean;
            getRootFiles(): ts.server.NormalizedPath[];
            /** @internal */
            getRootFilesMap(): Map<string, ts.server.ProjectRootFile>;
            getRootScriptInfos(): ts.server.ScriptInfo[];
            getScriptInfos(): ScriptInfo[];
            getExcludedFiles(): readonly NormalizedPath[];
            getFileNames(excludeFilesFromExternalLibraries?: boolean, excludeConfigFiles?: boolean): ts.server.NormalizedPath[];
            /** @internal */
            getFileNamesWithRedirectInfo(includeProjectReferenceRedirectInfo: boolean): ts.server.protocol.FileWithProjectReferenceRedirectInfo[];
            hasConfigFile(configFilePath: NormalizedPath): boolean;
            containsScriptInfo(info: ScriptInfo): boolean;
            containsFile(filename: NormalizedPath, requireOpen?: boolean): boolean;
            isRoot(info: ScriptInfo): boolean;
            addRoot(info: ScriptInfo, fileName?: NormalizedPath): void;
            addMissingFileRoot(fileName: NormalizedPath): void;
            removeFile(info: ScriptInfo, fileExists: boolean, detachFromProject: boolean): void;
            registerFileUpdate(fileName: string): void;
            /** @internal */
            markFileAsDirty(changedFile: Path): void;
            markAsDirty(): void;
            /** @internal */
            onAutoImportProviderSettingsChanged(): void;
            /** @internal */
            onPackageJsonChange(packageJsonPath: Path): void;
            /** @internal */
            onFileAddedOrRemoved(isSymlink: boolean | undefined): void;
            /** @internal */
            onDiscoveredSymlink(): void;
            /**
             * Updates set of files that contribute to this project
             * @returns: true if set of files in the project stays the same and false - otherwise.
             */
            updateGraph(): boolean;
            /** @internal */
            updateTypingFiles(typingFiles: SortedReadonlyArray<string>): void;
            /** @internal */
            getCurrentProgram(): Program | undefined;
            protected removeExistingTypings(include: string[]): string[];
            private updateGraphWorker;
            /** @internal */
            sendPerformanceEvent(kind: PerformanceEvent["kind"], durationMs: number): void;
            private detachScriptInfoFromProject;
            private addMissingFileWatcher;
            private isWatchedMissingFile;
            /** @internal */
            addGeneratedFileWatch(generatedFile: string, sourceFile: string): void;
            private createGeneratedFileWatcher;
            private isValidGeneratedFileWatcher;
            private clearGeneratedFileWatch;
            getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;
            getScriptInfo(uncheckedFileName: string): ts.server.ScriptInfo | undefined;
            filesToString(writeProjectFileNames: boolean): string;
            /** @internal */
            print(writeProjectFileNames: boolean): void;
            setCompilerOptions(compilerOptions: CompilerOptions): void;
            /** @internal */
            setWatchOptions(watchOptions: WatchOptions | undefined): void;
            /** @internal */
            getWatchOptions(): WatchOptions | undefined;
            setTypeAcquisition(newTypeAcquisition: TypeAcquisition | undefined): void;
            getTypeAcquisition(): ts.TypeAcquisition;
            /** @internal */
            getChangesSinceVersion(lastKnownVersion?: number, includeProjectReferenceRedirectInfo?: boolean): ProjectFilesWithTSDiagnostics;
            protected removeRoot(info: ScriptInfo): void;
            /** @internal */
            isSourceOfProjectReferenceRedirect(fileName: string): boolean;
            /** @internal */
            protected getGlobalPluginSearchPaths(): string[];
            protected enableGlobalPlugins(options: CompilerOptions, pluginConfigOverrides: Map<string, any> | undefined): void;
            /**
             * Performs the initial steps of enabling a plugin by finding and instantiating the module for a plugin synchronously using 'require'.
             *
             * @internal
             */
            beginEnablePluginSync(pluginConfigEntry: PluginImport, searchPaths: string[], pluginConfigOverrides: Map<string, any> | undefined): BeginEnablePluginResult;
            /**
             * Performs the initial steps of enabling a plugin by finding and instantiating the module for a plugin asynchronously using dynamic `import`.
             *
             * @internal
             */
            beginEnablePluginAsync(pluginConfigEntry: PluginImport, searchPaths: string[], pluginConfigOverrides: Map<string, any> | undefined): Promise<BeginEnablePluginResult>;
            /**
             * Performs the remaining steps of enabling a plugin after its module has been instantiated.
             *
             * @internal
             */
            endEnablePlugin({ pluginConfigEntry, pluginConfigOverrides, resolvedModule, errorLogs }: BeginEnablePluginResult): void;
            protected enablePlugin(pluginConfigEntry: PluginImport, searchPaths: string[], pluginConfigOverrides: Map<string, any> | undefined): void;
            private enableProxy;
            /** @internal */
            onPluginConfigurationChanged(pluginName: string, configuration: any): void;
            /** Starts a new check for diagnostics. Call this if some file has updated that would cause diagnostics to be changed. */
            refreshDiagnostics(): void;
            /** @internal */
            getPackageJsonsVisibleToFile(fileName: string, rootDir?: string): readonly ProjectPackageJsonInfo[];
            /** @internal */
            getNearestAncestorDirectoryWithPackageJson(fileName: string): string | undefined;
            /** @internal */
            getPackageJsonsForAutoImport(rootDir?: string): readonly ProjectPackageJsonInfo[];
            /** @internal */
            getPackageJsonCache(): ts.server.PackageJsonCache;
            /** @internal */
            getCachedExportInfoMap(): ts.ExportInfoMap;
            /** @internal */
            clearCachedExportInfoMap(): void;
            /** @internal */
            getModuleSpecifierCache(): ts.ModuleSpecifierCache;
            /** @internal */
            includePackageJsonAutoImports(): PackageJsonAutoImportPreference;
            /** @internal */
            getModuleResolutionHostForAutoImportProvider(): ModuleResolutionHost;
            /** @internal */
            getPackageJsonAutoImportProvider(): Program | undefined;
            /** @internal */
            private isDefaultProjectForOpenFiles;
            /** @internal */
            watchNodeModulesForPackageJsonChanges(directoryPath: string): ts.FileWatcher;
            /** @internal */
            getIncompleteCompletionsCache(): ts.IncompleteCompletionsCache;
            /** @internal */
            getNoDtsResolutionProject(rootFileNames: readonly string[]): Project;
            /** @internal */
            private getCompilerOptionsForNoDtsResolutionProject;
        }
        /**
         * If a file is opened and no tsconfig (or jsconfig) is found,
         * the file and its imports/references are put into an InferredProject.
         */
        class InferredProject extends Project {
            private _isJsInferredProject;
            toggleJsInferredProject(isJsInferredProject: boolean): void;
            setCompilerOptions(options?: CompilerOptions): void;
            /** this is canonical project root path */
            readonly projectRootPath: string | undefined;
            /**
             * stored only if their is no projectRootPath and this isnt single inferred project
             *
             * @internal
             */
            readonly canonicalCurrentDirectory: string | undefined;
            /** @internal */
            constructor(projectService: ProjectService, documentRegistry: DocumentRegistry, compilerOptions: CompilerOptions, watchOptions: WatchOptions | undefined, projectRootPath: NormalizedPath | undefined, currentDirectory: string | undefined, pluginConfigOverrides: Map<string, any> | undefined, typeAcquisition: TypeAcquisition | undefined);
            addRoot(info: ScriptInfo): void;
            removeRoot(info: ScriptInfo): void;
            /** @internal */
            isOrphan(): boolean;
            isProjectWithSingleRoot(): boolean;
            close(): void;
            getTypeAcquisition(): TypeAcquisition;
        }
        class AutoImportProviderProject extends Project {
            private hostProject;
            /** @internal */
            private static readonly maxDependencies;
            /** @internal */
            static getRootFileNames(dependencySelection: PackageJsonAutoImportPreference, hostProject: Project, moduleResolutionHost: ModuleResolutionHost, compilerOptions: CompilerOptions): string[];
            /** @internal */
            static readonly compilerOptionsOverrides: CompilerOptions;
            /** @internal */
            static create(dependencySelection: PackageJsonAutoImportPreference, hostProject: Project, moduleResolutionHost: ModuleResolutionHost, documentRegistry: DocumentRegistry): AutoImportProviderProject | undefined;
            private rootFileNames;
            /** @internal */
            constructor(hostProject: Project, initialRootNames: string[], documentRegistry: DocumentRegistry, compilerOptions: CompilerOptions);
            /** @internal */
            isEmpty(): boolean;
            isOrphan(): boolean;
            updateGraph(): boolean;
            /** @internal */
            scheduleInvalidateResolutionsOfFailedLookupLocations(): void;
            hasRoots(): boolean;
            markAsDirty(): void;
            getScriptFileNames(): string[];
            getLanguageService(): never;
            /** @internal */
            onAutoImportProviderSettingsChanged(): never;
            /** @internal */
            onPackageJsonChange(): never;
            getModuleResolutionHostForAutoImportProvider(): never;
            getProjectReferences(): readonly ts.ProjectReference[] | undefined;
            /** @internal */
            includePackageJsonAutoImports(): ts.PackageJsonAutoImportPreference;
            getTypeAcquisition(): TypeAcquisition;
            /** @internal */
            getSymlinkCache(): ts.SymlinkCache;
            /** @internal */
            getModuleResolutionCache(): ts.ModuleResolutionCache | undefined;
        }
        /**
         * If a file is opened, the server will look for a tsconfig (or jsconfig)
         * and if successful create a ConfiguredProject for it.
         * Otherwise it will create an InferredProject.
         */
        class ConfiguredProject extends Project {
            readonly canonicalConfigFilePath: NormalizedPath;
            /** @internal */
            pendingReload: ConfigFileProgramReloadLevel | undefined;
            /** @internal */
            pendingReloadReason: string | undefined;
            /** @internal */
            openFileWatchTriggered: Map<string, ts.ConfigFileProgramReloadLevel>;
            /** @internal */
            canConfigFileJsonReportNoInputFiles: boolean;
            /** Ref count to the project when opened from external project */
            private externalProjectRefCount;
            private projectReferences;
            /**
             * Potential project references before the project is actually loaded (read config file)
             *
             * @internal
             */
            potentialProjectReferences: Set<NormalizedPath> | undefined;
            /** @internal */
            projectOptions?: ProjectOptions | true;
            /** @internal */
            isInitialLoadPending: () => boolean;
            /** @internal */
            sendLoadingProjectFinish: boolean;
            /** @internal */
            private compilerHost?;
            /** @internal */
            constructor(configFileName: NormalizedPath, canonicalConfigFilePath: NormalizedPath, projectService: ProjectService, documentRegistry: DocumentRegistry, cachedDirectoryStructureHost: CachedDirectoryStructureHost);
            /** @internal */
            setCompilerHost(host: CompilerHost): void;
            /** @internal */
            getCompilerHost(): CompilerHost | undefined;
            /** @internal */
            useSourceOfProjectReferenceRedirect(): boolean;
            /** @internal */
            getParsedCommandLine(fileName: string): ts.ParsedCommandLine | undefined;
            /** @internal */
            onReleaseParsedCommandLine(fileName: string): void;
            /** @internal */
            private releaseParsedConfig;
            /**
             * If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph
             * @returns: true if set of files in the project stays the same and false - otherwise.
             */
            updateGraph(): boolean;
            /** @internal */
            getCachedDirectoryStructureHost(): ts.CachedDirectoryStructureHost;
            getConfigFilePath(): ts.server.NormalizedPath;
            getProjectReferences(): readonly ProjectReference[] | undefined;
            updateReferences(refs: readonly ProjectReference[] | undefined): void;
            /** @internal */
            setPotentialProjectReference(canonicalConfigPath: NormalizedPath): void;
            /** @internal */
            getResolvedProjectReferenceToRedirect(fileName: string): ResolvedProjectReference | undefined;
            /** @internal */
            forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined;
            /** @internal */
            enablePluginsWithOptions(options: CompilerOptions, pluginConfigOverrides: Map<string, any> | undefined): void;
            /**
             * Get the errors that dont have any file name associated
             */
            getGlobalProjectErrors(): readonly Diagnostic[];
            /**
             * Get all the project errors
             */
            getAllProjectErrors(): readonly Diagnostic[];
            setProjectErrors(projectErrors: Diagnostic[]): void;
            close(): void;
            /** @internal */
            addExternalProjectReference(): void;
            /** @internal */
            deleteExternalProjectReference(): void;
            /** @internal */
            isSolution(): boolean;
            /**
             * Find the configured project from the project references in project which contains the info directly
             *
             * @internal
             */
            getDefaultChildProjectFromProjectWithReferences(info: ScriptInfo): ts.server.ConfiguredProject | undefined;
            /**
             * Returns true if the project is needed by any of the open script info/external project
             *
             * @internal
             */
            hasOpenRef(): boolean;
            /** @internal */
            hasExternalProjectRef(): boolean;
            getEffectiveTypeRoots(): string[];
            /** @internal */
            updateErrorOnNoInputFiles(fileNames: string[]): void;
        }
        /**
         * Project whose configuration is handled externally, such as in a '.csproj'.
         * These are created only if a host explicitly calls `openExternalProject`.
         */
        class ExternalProject extends Project {
            externalProjectName: string;
            compileOnSaveEnabled: boolean;
            excludedFiles: readonly NormalizedPath[];
            /** @internal */
            constructor(externalProjectName: string, projectService: ProjectService, documentRegistry: DocumentRegistry, compilerOptions: CompilerOptions, lastFileExceededProgramSize: string | undefined, compileOnSaveEnabled: boolean, projectFilePath?: string, pluginConfigOverrides?: Map<string, any>, watchOptions?: WatchOptions);
            updateGraph(): boolean;
            getExcludedFiles(): readonly ts.server.NormalizedPath[];
        }
        function convertFormatOptions(protocolOptions: protocol.FormatCodeSettings): FormatCodeSettings;
        function convertCompilerOptions(protocolOptions: protocol.ExternalProjectCompilerOptions): CompilerOptions & protocol.CompileOnSaveMixin;
        function convertWatchOptions(protocolOptions: protocol.ExternalProjectCompilerOptions, currentDirectory?: string): WatchOptionsAndErrors | undefined;
        function convertTypeAcquisition(protocolOptions: protocol.InferredProjectCompilerOptions): TypeAcquisition | undefined;
        function tryConvertScriptKindName(scriptKindName: protocol.ScriptKindName | ScriptKind): ScriptKind;
        function convertScriptKindName(scriptKindName: protocol.ScriptKindName): ScriptKind.Unknown | ScriptKind.JS | ScriptKind.JSX | ScriptKind.TS | ScriptKind.TSX;
        /** @internal */
        function convertUserPreferences(preferences: protocol.UserPreferences): UserPreferences;
        /** @internal */
        function forEachResolvedProjectReferenceProject<T>(project: ConfiguredProject, fileName: string | undefined, cb: (child: ConfiguredProject) => T | undefined, projectReferenceProjectLoadKind: ProjectReferenceProjectLoadKind.Find | ProjectReferenceProjectLoadKind.FindCreate): T | undefined;
        /** @internal */
        function forEachResolvedProjectReferenceProject<T>(project: ConfiguredProject, fileName: string | undefined, cb: (child: ConfiguredProject) => T | undefined, projectReferenceProjectLoadKind: ProjectReferenceProjectLoadKind, reason: string): T | undefined;
        /**
         * true if script info is part of project and is not in project because it is referenced from project reference source
         *
         * @internal
         */
        function projectContainsInfoDirectly(project: Project, info: ScriptInfo): boolean;
        /** @internal */
        function updateProjectIfDirty(project: Project): boolean;
        /** @internal */
        function isConfigFile(config: ScriptInfoOrConfig): config is TsConfigSourceFile;
        const maxProgramSizeForNonTsFiles: number;
        /** @internal */
        const maxFileSize: number;
        const ProjectsUpdatedInBackgroundEvent = "projectsUpdatedInBackground";
        interface ProjectsUpdatedInBackgroundEvent {
            eventName: typeof ProjectsUpdatedInBackgroundEvent;
            data: {
                openFiles: string[];
            };
        }
        const ProjectLoadingStartEvent = "projectLoadingStart";
        interface ProjectLoadingStartEvent {
            eventName: typeof ProjectLoadingStartEvent;
            data: {
                project: Project;
                reason: string;
            };
        }
        const ProjectLoadingFinishEvent = "projectLoadingFinish";
        interface ProjectLoadingFinishEvent {
            eventName: typeof ProjectLoadingFinishEvent;
            data: {
                project: Project;
            };
        }
        const LargeFileReferencedEvent = "largeFileReferenced";
        interface LargeFileReferencedEvent {
            eventName: typeof LargeFileReferencedEvent;
            data: {
                file: string;
                fileSize: number;
                maxFileSize: number;
            };
        }
        const ConfigFileDiagEvent = "configFileDiag";
        interface ConfigFileDiagEvent {
            eventName: typeof ConfigFileDiagEvent;
            data: {
                triggerFile: string;
                configFileName: string;
                diagnostics: readonly Diagnostic[];
            };
        }
        const ProjectLanguageServiceStateEvent = "projectLanguageServiceState";
        interface ProjectLanguageServiceStateEvent {
            eventName: typeof ProjectLanguageServiceStateEvent;
            data: {
                project: Project;
                languageServiceEnabled: boolean;
            };
        }
        const ProjectInfoTelemetryEvent = "projectInfo";
        /** This will be converted to the payload of a protocol.TelemetryEvent in session.defaultEventHandler. */
        interface ProjectInfoTelemetryEvent {
            readonly eventName: typeof ProjectInfoTelemetryEvent;
            readonly data: ProjectInfoTelemetryEventData;
        }
        const OpenFileInfoTelemetryEvent = "openFileInfo";
        /**
         * Info that we may send about a file that was just opened.
         * Info about a file will only be sent once per session, even if the file changes in ways that might affect the info.
         * Currently this is only sent for '.js' files.
         */
        interface OpenFileInfoTelemetryEvent {
            readonly eventName: typeof OpenFileInfoTelemetryEvent;
            readonly data: OpenFileInfoTelemetryEventData;
        }
        interface ProjectInfoTelemetryEventData {
            /** Cryptographically secure hash of project file location. */
            readonly projectId: string;
            /** Count of file extensions seen in the project. */
            readonly fileStats: FileStats;
            /**
             * Any compiler options that might contain paths will be taken out.
             * Enum compiler options will be converted to strings.
             */
            readonly compilerOptions: CompilerOptions;
            readonly extends: boolean | undefined;
            readonly files: boolean | undefined;
            readonly include: boolean | undefined;
            readonly exclude: boolean | undefined;
            readonly compileOnSave: boolean;
            readonly typeAcquisition: ProjectInfoTypeAcquisitionData;
            readonly configFileName: "tsconfig.json" | "jsconfig.json" | "other";
            readonly projectType: "external" | "configured";
            readonly languageServiceEnabled: boolean;
            /** TypeScript version used by the server. */
            readonly version: string;
        }
        interface OpenFileInfoTelemetryEventData {
            readonly info: OpenFileInfo;
        }
        interface ProjectInfoTypeAcquisitionData {
            readonly enable: boolean | undefined;
            readonly include: boolean;
            readonly exclude: boolean;
        }
        interface FileStats {
            readonly js: number;
            readonly jsSize?: number;
            readonly jsx: number;
            readonly jsxSize?: number;
            readonly ts: number;
            readonly tsSize?: number;
            readonly tsx: number;
            readonly tsxSize?: number;
            readonly dts: number;
            readonly dtsSize?: number;
            readonly deferred: number;
            readonly deferredSize?: number;
        }
        interface OpenFileInfo {
            readonly checkJs: boolean;
        }
        type ProjectServiceEvent = LargeFileReferencedEvent | ProjectsUpdatedInBackgroundEvent | ProjectLoadingStartEvent | ProjectLoadingFinishEvent | ConfigFileDiagEvent | ProjectLanguageServiceStateEvent | ProjectInfoTelemetryEvent | OpenFileInfoTelemetryEvent;
        type ProjectServiceEventHandler = (event: ProjectServiceEvent) => void;
        /** @internal */
        type PerformanceEventHandler = (event: PerformanceEvent) => void;
        interface SafeList {
            [name: string]: {
                match: RegExp;
                exclude?: (string | number)[][];
                types?: string[];
            };
        }
        interface TypesMapFile {
            typesMap: SafeList;
            simpleMap: {
                [libName: string]: string;
            };
        }
        interface HostConfiguration {
            formatCodeOptions: FormatCodeSettings;
            preferences: protocol.UserPreferences;
            hostInfo: string;
            extraFileExtensions?: FileExtensionInfo[];
            watchOptions?: WatchOptions;
        }
        interface OpenConfiguredProjectResult {
            configFileName?: NormalizedPath;
            configFileErrors?: readonly Diagnostic[];
        }
        /** @internal */
        interface ConfigFileExistenceInfo {
            /**
             * Cached value of existence of config file
             * It is true if there is configured project open for this file.
             * It can be either true or false if this is the config file that is being watched by inferred project
             *   to decide when to update the structure so that it knows about updating the project for its files
             *   (config file may include the inferred project files after the change and hence may be wont need to be in inferred project)
             */
            exists: boolean;
            /**
             * openFilesImpactedByConfigFiles is a map of open files that would be impacted by this config file
             *   because these are the paths being looked up for their default configured project location
             * The value in the map is true if the open file is root of the inferred project
             * It is false when the open file that would still be impacted by existence of
             *   this config file but it is not the root of inferred project
             */
            openFilesImpactedByConfigFile?: Map<Path, boolean>;
            /**
             * The file watcher watching the config file because there is open script info that is root of
             * inferred project and will be impacted by change in the status of the config file
             * or
             * Configured project for this config file is open
             * or
             * Configured project references this config file
             */
            watcher?: FileWatcher;
            /**
             * Cached parsed command line and other related information like watched directories etc
             */
            config?: ParsedConfig;
        }
        interface ProjectServiceOptions {
            host: ServerHost;
            logger: Logger;
            cancellationToken: HostCancellationToken;
            useSingleInferredProject: boolean;
            useInferredProjectPerProjectRoot: boolean;
            typingsInstaller: ITypingsInstaller;
            eventHandler?: ProjectServiceEventHandler;
            suppressDiagnosticEvents?: boolean;
            throttleWaitMilliseconds?: number;
            globalPlugins?: readonly string[];
            pluginProbeLocations?: readonly string[];
            allowLocalPluginLoads?: boolean;
            typesMapLocation?: string;
            serverMode?: LanguageServiceMode;
            session: Session<unknown> | undefined;
        }
        /**
         * Kind of operation to perform to get project reference project
         *
         * @internal
         */
        enum ProjectReferenceProjectLoadKind {
            /** Find existing project for project reference */
            Find = 0,
            /** Find existing project or create one for the project reference */
            FindCreate = 1,
            /** Find existing project or create and load it for the project reference */
            FindCreateLoad = 2
        }
        /** @internal */
        interface OpenFileArguments {
            fileName: string;
            content?: string;
            scriptKind?: protocol.ScriptKindName | ScriptKind;
            hasMixedContent?: boolean;
            projectRootPath?: string;
        }
        /** @internal */
        interface ChangeFileArguments {
            fileName: string;
            changes: Iterable<TextChange>;
        }
        interface WatchOptionsAndErrors {
            watchOptions: WatchOptions;
            errors: Diagnostic[] | undefined;
        }
        /** @internal */
        interface ParsedConfig {
            cachedDirectoryStructureHost: CachedDirectoryStructureHost;
            /**
             * The map contains
             *   - true if project is watching config file as well as wild cards
             *   - false if just config file is watched
             */
            projects: Map<NormalizedPath, boolean>;
            parsedCommandLine?: ParsedCommandLine;
            watchedDirectories?: Map<string, WildcardDirectoryWatcher>;
            /**
             * true if watchedDirectories need to be updated as per parsedCommandLine's updated watched directories
             */
            watchedDirectoriesStale?: boolean;
            reloadLevel?: ConfigFileProgramReloadLevel.Partial | ConfigFileProgramReloadLevel.Full;
        }
        class ProjectService {
            /** @internal */
            readonly typingsCache: TypingsCache;
            /** @internal */
            readonly documentRegistry: DocumentRegistry;
            /**
             * Container of all known scripts
             *
             * @internal
             */
            readonly filenameToScriptInfo: Map<string, ScriptInfo>;
            private readonly nodeModulesWatchers;
            /**
             * Contains all the deleted script info's version information so that
             * it does not reset when creating script info again
             * (and could have potentially collided with version where contents mismatch)
             */
            private readonly filenameToScriptInfoVersion;
            private readonly allJsFilesForOpenFileTelemetry;
            /**
             * Map to the real path of the infos
             *
             * @internal
             */
            readonly realpathToScriptInfos: MultiMap<Path, ScriptInfo> | undefined;
            /**
             * maps external project file name to list of config files that were the part of this project
             */
            private readonly externalProjectToConfiguredProjectMap;
            /**
             * external projects (configuration and list of root files is not controlled by tsserver)
             */
            readonly externalProjects: ExternalProject[];
            /**
             * projects built from openFileRoots
             */
            readonly inferredProjects: InferredProject[];
            /**
             * projects specified by a tsconfig.json file
             */
            readonly configuredProjects: Map<string, ConfiguredProject>;
            /** @internal */
            readonly newInferredProjectName: () => string;
            /** @internal */
            readonly newAutoImportProviderProjectName: () => string;
            /** @internal */
            readonly newAuxiliaryProjectName: () => string;
            /**
             * Open files: with value being project root path, and key being Path of the file that is open
             */
            readonly openFiles: Map<string, NormalizedPath | undefined>;
            /** @internal */
            readonly configFileForOpenFiles: Map<Path, NormalizedPath | false>;
            /**
             * Map of open files that are opened without complete path but have projectRoot as current directory
             */
            private readonly openFilesWithNonRootedDiskPath;
            private compilerOptionsForInferredProjects;
            private compilerOptionsForInferredProjectsPerProjectRoot;
            private watchOptionsForInferredProjects;
            private watchOptionsForInferredProjectsPerProjectRoot;
            private typeAcquisitionForInferredProjects;
            private typeAcquisitionForInferredProjectsPerProjectRoot;
            /**
             * Project size for configured or external projects
             */
            private readonly projectToSizeMap;
            /**
             * This is a map of config file paths existence that doesnt need query to disk
             * - The entry can be present because there is inferred project that needs to watch addition of config file to directory
             *   In this case the exists could be true/false based on config file is present or not
             * - Or it is present if we have configured project open with config file at that location
             *   In this case the exists property is always true
             *
             *
             * @internal
             */
            readonly configFileExistenceInfoCache: Map<NormalizedPath, ConfigFileExistenceInfo>;
            /** @internal */ readonly throttledOperations: ThrottledOperations;
            private readonly hostConfiguration;
            private safelist;
            private readonly legacySafelist;
            private pendingProjectUpdates;
            /** @internal */
            pendingEnsureProjectForOpenFiles: boolean;
            readonly currentDirectory: NormalizedPath;
            readonly toCanonicalFileName: (f: string) => string;
            readonly host: ServerHost;
            readonly logger: Logger;
            readonly cancellationToken: HostCancellationToken;
            readonly useSingleInferredProject: boolean;
            readonly useInferredProjectPerProjectRoot: boolean;
            readonly typingsInstaller: ITypingsInstaller;
            private readonly globalCacheLocationDirectoryPath;
            readonly throttleWaitMilliseconds?: number;
            private readonly eventHandler?;
            private readonly suppressDiagnosticEvents?;
            readonly globalPlugins: readonly string[];
            readonly pluginProbeLocations: readonly string[];
            readonly allowLocalPluginLoads: boolean;
            private currentPluginConfigOverrides;
            readonly typesMapLocation: string | undefined;
            readonly serverMode: LanguageServiceMode;
            /** Tracks projects that we have already sent telemetry for. */
            private readonly seenProjects;
            /** @internal */
            readonly watchFactory: WatchFactory<WatchType, Project | NormalizedPath>;
            /** @internal */
            private readonly sharedExtendedConfigFileWatchers;
            /** @internal */
            private readonly extendedConfigCache;
            /** @internal */
            readonly packageJsonCache: PackageJsonCache;
            /** @internal */
            private packageJsonFilesMap;
            /** @internal */
            private incompleteCompletionsCache;
            /** @internal */
            readonly session: Session<unknown> | undefined;
            private performanceEventHandler?;
            private pendingPluginEnablements?;
            private currentPluginEnablementPromise?;
            constructor(opts: ProjectServiceOptions);
            toPath(fileName: string): Path;
            /** @internal */
            getExecutingFilePath(): string;
            /** @internal */
            getNormalizedAbsolutePath(fileName: string): string;
            /** @internal */
            setDocument(key: DocumentRegistryBucketKeyWithMode, path: Path, sourceFile: SourceFile): void;
            /** @internal */
            getDocument(key: DocumentRegistryBucketKeyWithMode, path: Path): SourceFile | undefined;
            /** @internal */
            ensureInferredProjectsUpToDate_TestOnly(): void;
            /** @internal */
            getCompilerOptionsForInferredProjects(): CompilerOptions | undefined;
            /** @internal */
            onUpdateLanguageServiceStateForProject(project: Project, languageServiceEnabled: boolean): void;
            private loadTypesMap;
            updateTypingsForProject(response: SetTypings | InvalidateCachedTypings | PackageInstalledResponse): void;
            /** @internal */
            updateTypingsForProject(response: SetTypings | InvalidateCachedTypings | PackageInstalledResponse | BeginInstallTypes | EndInstallTypes): void;
            /** @internal */
            delayEnsureProjectForOpenFiles(): void;
            private delayUpdateProjectGraph;
            /** @internal */
            hasPendingProjectUpdate(project: Project): boolean;
            /** @internal */
            sendProjectsUpdatedInBackgroundEvent(): void;
            /** @internal */
            sendLargeFileReferencedEvent(file: string, fileSize: number): void;
            /** @internal */
            sendProjectLoadingStartEvent(project: ConfiguredProject, reason: string): void;
            /** @internal */
            sendProjectLoadingFinishEvent(project: ConfiguredProject): void;
            /** @internal */
            sendPerformanceEvent(kind: PerformanceEvent["kind"], durationMs: number): void;
            /** @internal */
            delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(project: Project): void;
            private delayUpdateProjectGraphs;
            setCompilerOptionsForInferredProjects(projectCompilerOptions: protocol.InferredProjectCompilerOptions, projectRootPath?: string): void;
            findProject(projectName: string): Project | undefined;
            /** @internal */
            private forEachProject;
            /** @internal */
            forEachEnabledProject(cb: (project: Project) => void): void;
            getDefaultProjectForFile(fileName: NormalizedPath, ensureProject: boolean): Project | undefined;
            /** @internal */
            tryGetDefaultProjectForFile(fileNameOrScriptInfo: NormalizedPath | ScriptInfo): Project | undefined;
            /** @internal */
            ensureDefaultProjectForFile(fileNameOrScriptInfo: NormalizedPath | ScriptInfo): Project;
            private doEnsureDefaultProjectForFile;
            getScriptInfoEnsuringProjectsUptoDate(uncheckedFileName: string): ScriptInfo | undefined;
            /**
             * Ensures the project structures are upto date
             * This means,
             * - we go through all the projects and update them if they are dirty
             * - if updates reflect some change in structure or there was pending request to ensure projects for open files
             *   ensure that each open script info has project
             */
            private ensureProjectStructuresUptoDate;
            getFormatCodeOptions(file: NormalizedPath): FormatCodeSettings;
            getPreferences(file: NormalizedPath): protocol.UserPreferences;
            getHostFormatCodeOptions(): FormatCodeSettings;
            getHostPreferences(): protocol.UserPreferences;
            private onSourceFileChanged;
            private handleSourceMapProjects;
            private delayUpdateSourceInfoProjects;
            private delayUpdateProjectsOfScriptInfoPath;
            private handleDeletedFile;
            /**
             * This is to watch whenever files are added or removed to the wildcard directories
             *
             * @internal
             */
            private watchWildcardDirectory;
            /** @internal */
            private delayUpdateProjectsFromParsedConfigOnConfigFileChange;
            /** @internal */
            private onConfigFileChanged;
            private removeProject;
            /** @internal */
            assignOrphanScriptInfoToInferredProject(info: ScriptInfo, projectRootPath: NormalizedPath | undefined): InferredProject;
            private assignOrphanScriptInfosToInferredProject;
            /**
             * Remove this file from the set of open, non-configured files.
             * @param info The file that has been closed or newly configured
             */
            private closeOpenFile;
            private deleteScriptInfo;
            private configFileExists;
            /** @internal */
            private createConfigFileWatcherForParsedConfig;
            /**
             * Returns true if the configFileExistenceInfo is needed/impacted by open files that are root of inferred project
             */
            private configFileExistenceImpactsRootOfInferredProject;
            /** @internal */
            releaseParsedConfig(canonicalConfigFilePath: NormalizedPath, forProject: ConfiguredProject): void;
            /**
             * Close the config file watcher in the cached ConfigFileExistenceInfo
             *   if there arent any open files that are root of inferred project and there is no parsed config held by any project
             *
             * @internal
             */
            private closeConfigFileWatcherOnReleaseOfOpenFile;
            /**
             * This is called on file close, so that we stop watching the config file for this script info
             */
            private stopWatchingConfigFilesForClosedScriptInfo;
            /**
             * This is called by inferred project whenever script info is added as a root
             *
             * @internal
             */
            startWatchingConfigFilesForInferredProjectRoot(info: ScriptInfo): void;
            /**
             * This is called by inferred project whenever root script info is removed from it
             *
             * @internal
             */
            stopWatchingConfigFilesForInferredProjectRoot(info: ScriptInfo): void;
            /**
             * This function tries to search for a tsconfig.json for the given file.
             * This is different from the method the compiler uses because
             * the compiler can assume it will always start searching in the
             * current directory (the directory in which tsc was invoked).
             * The server must start searching from the directory containing
             * the newly opened file.
             */
            private forEachConfigFileLocation;
            /** @internal */
            findDefaultConfiguredProject(info: ScriptInfo): ConfiguredProject | undefined;
            /**
             * This function tries to search for a tsconfig.json for the given file.
             * This is different from the method the compiler uses because
             * the compiler can assume it will always start searching in the
             * current directory (the directory in which tsc was invoked).
             * The server must start searching from the directory containing
             * the newly opened file.
             * If script info is passed in, it is asserted to be open script info
             * otherwise just file name
             */
            private getConfigFileNameForFile;
            private printProjects;
            /** @internal */
            findConfiguredProjectByProjectName(configFileName: NormalizedPath): ConfiguredProject | undefined;
            private getConfiguredProjectByCanonicalConfigFilePath;
            private findExternalProjectByProjectName;
            /** Get a filename if the language service exceeds the maximum allowed program size; otherwise returns undefined. */
            private getFilenameForExceededTotalSizeLimitForNonTsFiles;
            private createExternalProject;
            /** @internal */
            sendProjectTelemetry(project: ExternalProject | ConfiguredProject): void;
            private addFilesToNonInferredProject;
            /** @internal */
            createConfiguredProject(configFileName: NormalizedPath): ConfiguredProject;
            /** @internal */
            private createConfiguredProjectWithDelayLoad;
            /** @internal */
            createAndLoadConfiguredProject(configFileName: NormalizedPath, reason: string): ConfiguredProject;
            /** @internal */
            private createLoadAndUpdateConfiguredProject;
            /**
             * Read the config file of the project, and update the project root file names.
             *
             * @internal
             */
            private loadConfiguredProject;
            /** @internal */
            ensureParsedConfigUptoDate(configFilename: NormalizedPath, canonicalConfigFilePath: NormalizedPath, configFileExistenceInfo: ConfigFileExistenceInfo, forProject: ConfiguredProject): ConfigFileExistenceInfo;
            /** @internal */
            watchWildcards(configFileName: NormalizedPath, { exists, config }: ConfigFileExistenceInfo, forProject: ConfiguredProject): void;
            /** @internal */
            stopWatchingWildCards(canonicalConfigFilePath: NormalizedPath, forProject: ConfiguredProject): void;
            private updateNonInferredProjectFiles;
            private updateRootAndOptionsOfNonInferredProject;
            /**
             * Reload the file names from config file specs and update the project graph
             *
             * @internal
             */
            reloadFileNamesOfConfiguredProject(project: ConfiguredProject): boolean;
            /** @internal */
            private reloadFileNamesOfParsedConfig;
            /** @internal */
            setFileNamesOfAutoImportProviderProject(project: AutoImportProviderProject, fileNames: string[]): void;
            /**
             * Read the config file of the project again by clearing the cache and update the project graph
             *
             * @internal
             */
            reloadConfiguredProject(project: ConfiguredProject, reason: string, isInitialLoad: boolean, clearSemanticCache: boolean): void;
            /** @internal */
            private clearSemanticCache;
            private sendConfigFileDiagEvent;
            private getOrCreateInferredProjectForProjectRootPathIfEnabled;
            private getOrCreateSingleInferredProjectIfEnabled;
            private getOrCreateSingleInferredWithoutProjectRoot;
            private createInferredProject;
            /** @internal */
            getOrCreateScriptInfoNotOpenedByClient(uncheckedFileName: string, currentDirectory: string, hostToQueryFileExistsOn: DirectoryStructureHost): ScriptInfo | undefined;
            getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;
            /** @internal */
            getScriptInfoOrConfig(uncheckedFileName: string): ScriptInfoOrConfig | undefined;
            /** @internal */
            logErrorForScriptInfoNotFound(fileName: string): void;
            /**
             * Returns the projects that contain script info through SymLink
             * Note that this does not return projects in info.containingProjects
             *
             * @internal
             */
            getSymlinkedProjects(info: ScriptInfo): MultiMap<Path, Project> | undefined;
            private watchClosedScriptInfo;
            private createNodeModulesWatcher;
            /** @internal */
            watchPackageJsonsInNodeModules(dir: Path, project: Project): FileWatcher;
            private watchClosedScriptInfoInNodeModules;
            private getModifiedTime;
            private refreshScriptInfo;
            private refreshScriptInfosInDirectory;
            private stopWatchingScriptInfo;
            private getOrCreateScriptInfoNotOpenedByClientForNormalizedPath;
            private getOrCreateScriptInfoOpenedByClientForNormalizedPath;
            getOrCreateScriptInfoForNormalizedPath(fileName: NormalizedPath, openedByClient: boolean, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, hostToQueryFileExistsOn?: {
                fileExists(path: string): boolean;
            }): ScriptInfo | undefined;
            private getOrCreateScriptInfoWorker;
            /**
             * This gets the script info for the normalized path. If the path is not rooted disk path then the open script info with project root context is preferred
             */
            getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;
            getScriptInfoForPath(fileName: Path): ScriptInfo | undefined;
            /** @internal */
            getDocumentPositionMapper(project: Project, generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined;
            private addSourceInfoToSourceMap;
            private addMissingSourceMapFile;
            /** @internal */
            getSourceFileLike(fileName: string, projectNameOrProject: string | Project, declarationInfo?: ScriptInfo): SourceFileLike | undefined;
            /** @internal */
            setPerformanceEventHandler(performanceEventHandler: PerformanceEventHandler): void;
            setHostConfiguration(args: protocol.ConfigureRequestArguments): void;
            /** @internal */
            getWatchOptions(project: Project): WatchOptions | undefined;
            /** @internal */
            private getWatchOptionsFromProjectWatchOptions;
            closeLog(): void;
            /**
             * This function rebuilds the project for every file opened by the client
             * This does not reload contents of open files from disk. But we could do that if needed
             */
            reloadProjects(): void;
            /**
             * This function goes through all the openFiles and tries to file the config file for them.
             * If the config file is found and it refers to existing project, it reloads it either immediately
             * or schedules it for reload depending on delayReload option
             * If there is no existing project it just opens the configured project for the config file
             * reloadForInfo provides a way to filter out files to reload configured project for
             */
            private reloadConfiguredProjectForFiles;
            /**
             * Remove the root of inferred project if script info is part of another project
             */
            private removeRootOfInferredProjectIfNowPartOfOtherProject;
            /**
             * This function is to update the project structure for every inferred project.
             * It is called on the premise that all the configured projects are
             * up to date.
             * This will go through open files and assign them to inferred project if open file is not part of any other project
             * After that all the inferred project graphs are updated
             */
            private ensureProjectForOpenFiles;
            /**
             * Open file whose contents is managed by the client
             * @param filename is absolute pathname
             * @param fileContent is a known version of the file content that is more up to date than the one on disk
             */
            openClientFile(fileName: string, fileContent?: string, scriptKind?: ScriptKind, projectRootPath?: string): OpenConfiguredProjectResult;
            /** @internal */
            getOriginalLocationEnsuringConfiguredProject(project: Project, location: DocumentPosition): DocumentPosition | undefined;
            /** @internal */
            fileExists(fileName: NormalizedPath): boolean;
            private findExternalProjectContainingOpenScriptInfo;
            private getOrCreateOpenScriptInfo;
            private assignProjectToOpenedScriptInfo;
            private createAncestorProjects;
            /** @internal */
            loadAncestorProjectTree(forProjects?: ReadonlyCollection<string>): void;
            private ensureProjectChildren;
            private cleanupAfterOpeningFile;
            openClientFileWithNormalizedPath(fileName: NormalizedPath, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, projectRootPath?: NormalizedPath): OpenConfiguredProjectResult;
            private removeOrphanConfiguredProjects;
            private removeOrphanScriptInfos;
            private telemetryOnOpenFile;
            /**
             * Close file whose contents is managed by the client
             * @param filename is absolute pathname
             */
            closeClientFile(uncheckedFileName: string): void;
            /** @internal */
            closeClientFile(uncheckedFileName: string, skipAssignOrphanScriptInfosToInferredProject: true): boolean;
            private collectChanges;
            /** @internal */
            synchronizeProjectList(knownProjects: protocol.ProjectVersionInfo[], includeProjectReferenceRedirectInfo?: boolean): ProjectFilesWithTSDiagnostics[];
            /** @internal */
            applyChangesInOpenFiles(openFiles: Iterable<OpenFileArguments> | undefined, changedFiles?: Iterable<ChangeFileArguments>, closedFiles?: string[]): void;
            /** @internal */
            applyChangesToFile(scriptInfo: ScriptInfo, changes: Iterable<TextChange>): void;
            private closeConfiguredProjectReferencedFromExternalProject;
            closeExternalProject(uncheckedFileName: string): void;
            openExternalProjects(projects: protocol.ExternalProject[]): void;
            /** Makes a filename safe to insert in a RegExp */
            private static readonly filenameEscapeRegexp;
            private static escapeFilenameForRegex;
            resetSafeList(): void;
            applySafeList(proj: protocol.ExternalProject): NormalizedPath[];
            openExternalProject(proj: protocol.ExternalProject): void;
            hasDeferredExtension(): boolean;
            /** @internal */
            requestEnablePlugin(project: Project, pluginConfigEntry: PluginImport, searchPaths: string[], pluginConfigOverrides: Map<string, any> | undefined): void;
            /** @internal */
            hasNewPluginEnablementRequests(): boolean;
            /** @internal */
            hasPendingPluginEnablements(): boolean;
            /**
             * Waits for any ongoing plugin enablement requests to complete.
             *
             * @internal
             */
            waitForPendingPlugins(): Promise<void>;
            /**
             * Starts enabling any requested plugins without waiting for the result.
             *
             * @internal
             */
            enableRequestedPlugins(): void;
            private enableRequestedPluginsAsync;
            private enableRequestedPluginsWorker;
            private enableRequestedPluginsForProjectAsync;
            configurePlugin(args: protocol.ConfigurePluginRequestArguments): void;
            /** @internal */
            getPackageJsonsVisibleToFile(fileName: string, rootDir?: string): readonly ProjectPackageJsonInfo[];
            /** @internal */
            getNearestAncestorDirectoryWithPackageJson(fileName: string): string | undefined;
            /** @internal */
            private watchPackageJsonFile;
            /** @internal */
            private onAddPackageJson;
            /** @internal */
            includePackageJsonAutoImports(): PackageJsonAutoImportPreference;
            /** @internal */
            private invalidateProjectPackageJson;
            /** @internal */
            getIncompleteCompletionsCache(): IncompleteCompletionsCache;
        }
        /** @internal */
        type ScriptInfoOrConfig = ScriptInfo | TsConfigSourceFile;
        /** @internal */
        function createModuleSpecifierCache(host: ModuleSpecifierResolutionCacheHost): ModuleSpecifierCache;
        /** @internal */
        interface ModuleSpecifierResolutionCacheHost {
            watchNodeModulesForPackageJsonChanges(directoryPath: string): FileWatcher;
        }
        /** @internal */
        function createPackageJsonCache(host: ProjectService): PackageJsonCache;
        /** @internal */
        interface PackageJsonCache {
            addOrUpdate(fileName: Path): void;
            forEach(action: (info: ProjectPackageJsonInfo, fileName: Path) => void): void;
            delete(fileName: Path): void;
            get(fileName: Path): ProjectPackageJsonInfo | false | undefined;
            getInDirectory(directory: Path): ProjectPackageJsonInfo | undefined;
            directoryHasPackageJson(directory: Path): Ternary;
            searchDirectoryAndAncestors(directory: Path): void;
        }
        function formatMessage<T extends protocol.Message>(msg: T, logger: Logger, byteLength: (s: string, encoding: BufferEncoding) => number, newLine: string): string;
        /** @internal */
        function toEvent(eventName: string, body: object): protocol.Event;
        /** @internal */ function getLocationInNewDocument(oldText: string, renameFilename: string, renameLocation: number, edits: readonly FileTextChanges[]): protocol.Location;
        interface ServerCancellationToken extends HostCancellationToken {
            setRequest(requestId: number): void;
            resetRequest(requestId: number): void;
        }
        const nullCancellationToken: ServerCancellationToken;
        interface PendingErrorCheck {
            fileName: NormalizedPath;
            project: Project;
        }
        /** @deprecated use ts.server.protocol.CommandTypes */
        type CommandNames = protocol.CommandTypes;
        /** @deprecated use ts.server.protocol.CommandTypes */
        const CommandNames: any;
        type Event = <T extends object>(body: T, eventName: string) => void;
        interface EventSender {
            event: Event;
        }
        interface SessionOptions {
            host: ServerHost;
            cancellationToken: ServerCancellationToken;
            useSingleInferredProject: boolean;
            useInferredProjectPerProjectRoot: boolean;
            typingsInstaller: ITypingsInstaller;
            byteLength: (buf: string, encoding?: BufferEncoding) => number;
            hrtime: (start?: [
                number,
                number
            ]) => [
                number,
                number
            ];
            logger: Logger;
            /**
             * If falsy, all events are suppressed.
             */
            canUseEvents: boolean;
            eventHandler?: ProjectServiceEventHandler;
            /** Has no effect if eventHandler is also specified. */
            suppressDiagnosticEvents?: boolean;
            serverMode?: LanguageServiceMode;
            throttleWaitMilliseconds?: number;
            noGetErrOnBackgroundUpdate?: boolean;
            globalPlugins?: readonly string[];
            pluginProbeLocations?: readonly string[];
            allowLocalPluginLoads?: boolean;
            typesMapLocation?: string;
        }
        class Session<TMessage = string> implements EventSender {
            private readonly gcTimer;
            protected projectService: ProjectService;
            private changeSeq;
            private performanceData;
            private currentRequestId;
            private errorCheck;
            protected host: ServerHost;
            private readonly cancellationToken;
            protected readonly typingsInstaller: ITypingsInstaller;
            protected byteLength: (buf: string, encoding?: BufferEncoding) => number;
            private hrtime;
            protected logger: Logger;
            protected canUseEvents: boolean;
            private suppressDiagnosticEvents?;
            private eventHandler;
            private readonly noGetErrOnBackgroundUpdate?;
            constructor(opts: SessionOptions);
            private sendRequestCompletedEvent;
            private addPerformanceData;
            private performanceEventHandler;
            private defaultEventHandler;
            private projectsUpdatedInBackgroundEvent;
            logError(err: Error, cmd: string): void;
            private logErrorWorker;
            send(msg: protocol.Message): void;
            protected writeMessage(msg: protocol.Message): void;
            event<T extends object>(body: T, eventName: string): void;
            /** @internal */
            doOutput(info: {} | undefined, cmdName: string, reqSeq: number, success: boolean, message?: string): void;
            private semanticCheck;
            private syntacticCheck;
            private suggestionCheck;
            private sendDiagnosticsEvent;
            /** It is the caller's responsibility to verify that `!this.suppressDiagnosticEvents`. */
            private updateErrorCheck;
            private cleanProjects;
            private cleanup;
            private getEncodedSyntacticClassifications;
            private getEncodedSemanticClassifications;
            private getProject;
            private getConfigFileAndProject;
            private getConfigFileDiagnostics;
            private convertToDiagnosticsWithLinePositionFromDiagnosticFile;
            private getCompilerOptionsDiagnostics;
            private convertToDiagnosticsWithLinePosition;
            private getDiagnosticsWorker;
            private getDefinition;
            private mapDefinitionInfoLocations;
            private getDefinitionAndBoundSpan;
            private findSourceDefinition;
            private getEmitOutput;
            private mapJSDocTagInfo;
            private mapDisplayParts;
            private mapSignatureHelpItems;
            private mapDefinitionInfo;
            private static mapToOriginalLocation;
            private toFileSpan;
            private toFileSpanWithContext;
            private getTypeDefinition;
            private mapImplementationLocations;
            private getImplementation;
            private getOccurrences;
            private getSyntacticDiagnosticsSync;
            private getSemanticDiagnosticsSync;
            private getSuggestionDiagnosticsSync;
            private getJsxClosingTag;
            private getDocumentHighlights;
            private provideInlayHints;
            private setCompilerOptionsForInferredProjects;
            private getProjectInfo;
            private getProjectInfoWorker;
            private getRenameInfo;
            private getProjects;
            private getDefaultProject;
            private getRenameLocations;
            private mapRenameInfo;
            private toSpanGroups;
            private getReferences;
            private getFileReferences;
            /**
             * @param fileName is the name of the file to be opened
             * @param fileContent is a version of the file content that is known to be more up to date than the one on disk
             */
            private openClientFile;
            private getPosition;
            private getPositionInFile;
            private getFileAndProject;
            private getFileAndLanguageServiceForSyntacticOperation;
            private getFileAndProjectWorker;
            private getOutliningSpans;
            private getTodoComments;
            private getDocCommentTemplate;
            private getSpanOfEnclosingComment;
            private getIndentation;
            private getBreakpointStatement;
            private getNameOrDottedNameSpan;
            private isValidBraceCompletion;
            private getQuickInfoWorker;
            private getFormattingEditsForRange;
            private getFormattingEditsForRangeFull;
            private getFormattingEditsForDocumentFull;
            private getFormattingEditsAfterKeystrokeFull;
            private getFormattingEditsAfterKeystroke;
            private getCompletions;
            private getCompletionEntryDetails;
            private getCompileOnSaveAffectedFileList;
            private emitFile;
            private getSignatureHelpItems;
            private toPendingErrorCheck;
            private getDiagnostics;
            private change;
            private reload;
            private saveToTmp;
            private closeClientFile;
            private mapLocationNavigationBarItems;
            private getNavigationBarItems;
            private toLocationNavigationTree;
            private getNavigationTree;
            private getNavigateToItems;
            private getFullNavigateToItems;
            private getSupportedCodeFixes;
            private isLocation;
            private extractPositionOrRange;
            private getRange;
            private getApplicableRefactors;
            private getEditsForRefactor;
            private organizeImports;
            private getEditsForFileRename;
            private getCodeFixes;
            private getCombinedCodeFix;
            private applyCodeActionCommand;
            private getStartAndEndPosition;
            private mapCodeAction;
            private mapCodeFixAction;
            private mapTextChangesToCodeEdits;
            private mapTextChangeToCodeEdit;
            private convertTextChangeToCodeEdit;
            private getBraceMatching;
            private getDiagnosticsForProject;
            private configurePlugin;
            private getSmartSelectionRange;
            private toggleLineComment;
            private toggleMultilineComment;
            private commentSelection;
            private uncommentSelection;
            private mapSelectionRange;
            private getScriptInfoFromProjectService;
            private toProtocolCallHierarchyItem;
            private toProtocolCallHierarchyIncomingCall;
            private toProtocolCallHierarchyOutgoingCall;
            private prepareCallHierarchy;
            private provideCallHierarchyIncomingCalls;
            private provideCallHierarchyOutgoingCalls;
            getCanonicalFileName(fileName: string): string;
            exit(): void;
            private notRequired;
            private requiredResponse;
            private handlers;
            addProtocolHandler(command: string, handler: (request: protocol.Request) => HandlerResponse): void;
            private setCurrentRequest;
            private resetCurrentRequest;
            executeWithRequestId<T>(requestId: number, f: () => T): T;
            executeCommand(request: protocol.Request): HandlerResponse;
            onMessage(message: TMessage): void;
            protected parseMessage(message: TMessage): protocol.Request;
            protected toStringMessage(message: TMessage): string;
            private getFormatOptions;
            private getPreferences;
            private getHostFormatOptions;
            private getHostPreferences;
        }
        interface HandlerResponse {
            response?: {};
            responseRequired?: boolean;
        }
        /** @internal */
        interface LineCollection {
            charCount(): number;
            lineCount(): number;
            isLeaf(): this is LineLeaf;
            walk(rangeStart: number, rangeLength: number, walkFns: LineIndexWalker): void;
        }
        /** @internal */
        interface AbsolutePositionAndLineText {
            absolutePosition: number;
            lineText: string | undefined;
        }
        /** @internal */
        enum CharRangeSection {
            PreStart = 0,
            Start = 1,
            Entire = 2,
            Mid = 3,
            End = 4,
            PostEnd = 5
        }
        /** @internal */
        interface LineIndexWalker {
            goSubtree: boolean;
            done: boolean;
            leaf(relativeStart: number, relativeLength: number, lineCollection: LineLeaf): void;
            pre?(relativeStart: number, relativeLength: number, lineCollection: LineCollection, parent: LineNode, nodeType: CharRangeSection): void;
            post?(relativeStart: number, relativeLength: number, lineCollection: LineCollection, parent: LineNode, nodeType: CharRangeSection): void;
        }
        /** @internal */
        class ScriptVersionCache {
            private static readonly changeNumberThreshold;
            private static readonly changeLengthThreshold;
            private static readonly maxVersions;
            private changes;
            private readonly versions;
            private minVersion;
            private currentVersion;
            private versionToIndex;
            private currentVersionToIndex;
            edit(pos: number, deleteLen: number, insertedText?: string): void;
            getSnapshot(): IScriptSnapshot;
            private _getSnapshot;
            getSnapshotVersion(): number;
            getAbsolutePositionAndLineText(oneBasedLine: number): AbsolutePositionAndLineText;
            lineOffsetToPosition(line: number, column: number): number;
            positionToLineOffset(position: number): protocol.Location;
            lineToTextSpan(line: number): TextSpan;
            getTextChangesBetweenVersions(oldVersion: number, newVersion: number): TextChangeRange | undefined;
            getLineCount(): number;
            static fromString(script: string): ScriptVersionCache;
        }
        /** @internal */
        class LineIndex {
            root: LineNode;
            checkEdits: boolean;
            absolutePositionOfStartOfLine(oneBasedLine: number): number;
            positionToLineOffset(position: number): protocol.Location;
            private positionToColumnAndLineText;
            getLineCount(): number;
            lineNumberToInfo(oneBasedLine: number): AbsolutePositionAndLineText;
            load(lines: string[]): void;
            walk(rangeStart: number, rangeLength: number, walkFns: LineIndexWalker): void;
            getText(rangeStart: number, rangeLength: number): string;
            getLength(): number;
            every(f: (ll: LineLeaf, s: number, len: number) => boolean, rangeStart: number, rangeEnd?: number): boolean;
            edit(pos: number, deleteLength: number, newText?: string): LineIndex;
            private static buildTreeFromBottom;
            static linesFromText(text: string): {
                lines: string[];
                lineMap: number[];
            };
        }
        /** @internal */
        class LineNode implements LineCollection {
            private readonly children;
            totalChars: number;
            totalLines: number;
            constructor(children?: LineCollection[]);
            isLeaf(): boolean;
            updateCounts(): void;
            private execWalk;
            private skipChild;
            walk(rangeStart: number, rangeLength: number, walkFns: LineIndexWalker): void;
            charOffsetToLineInfo(lineNumberAccumulator: number, relativePosition: number): {
                oneBasedLine: number;
                zeroBasedColumn: number;
                lineText: string | undefined;
            };
            /**
             * Input line number is relative to the start of this node.
             * Output line number is relative to the child.
             * positionAccumulator will be an absolute position once relativeLineNumber reaches 0.
             */
            lineNumberToInfo(relativeOneBasedLine: number, positionAccumulator: number): {
                position: number;
                leaf: LineLeaf | undefined;
            };
            private splitAfter;
            remove(child: LineCollection): void;
            private findChildIndex;
            insertAt(child: LineCollection, nodes: LineCollection[]): LineNode[];
            add(collection: LineCollection): void;
            charCount(): number;
            lineCount(): number;
        }
        /** @internal */
        class LineLeaf implements LineCollection {
            text: string;
            constructor(text: string);
            isLeaf(): boolean;
            walk(rangeStart: number, rangeLength: number, walkFns: LineIndexWalker): void;
            charCount(): number;
            lineCount(): number;
        }
    }
    namespace moduleSpecifiers {
        /** @internal */
        function updateModuleSpecifier(compilerOptions: CompilerOptions, importingSourceFile: SourceFile, importingSourceFileName: Path, toFileName: string, host: ModuleSpecifierResolutionHost, oldImportSpecifier: string, options?: ModuleSpecifierOptions): string | undefined;
        /** @internal */
        function getModuleSpecifier(compilerOptions: CompilerOptions, importingSourceFile: SourceFile, importingSourceFileName: Path, toFileName: string, host: ModuleSpecifierResolutionHost, options?: ModuleSpecifierOptions): string;
        /** @internal */
        function getNodeModulesPackageName(compilerOptions: CompilerOptions, importingSourceFile: SourceFile, nodeModulesFileName: string, host: ModuleSpecifierResolutionHost, preferences: UserPreferences, options?: ModuleSpecifierOptions): string | undefined;
        /** @internal */
        function tryGetModuleSpecifiersFromCache(moduleSymbol: Symbol, importingSourceFile: SourceFile, host: ModuleSpecifierResolutionHost, userPreferences: UserPreferences, options?: ModuleSpecifierOptions): readonly string[] | undefined;
        /**
         * Returns an import for each symlink and for the realpath.
         *
         * @internal
         */
        function getModuleSpecifiers(moduleSymbol: Symbol, checker: TypeChecker, compilerOptions: CompilerOptions, importingSourceFile: SourceFile, host: ModuleSpecifierResolutionHost, userPreferences: UserPreferences, options?: ModuleSpecifierOptions): readonly string[];
        /** @internal */
        function getModuleSpecifiersWithCacheInfo(moduleSymbol: Symbol, checker: TypeChecker, compilerOptions: CompilerOptions, importingSourceFile: SourceFile, host: ModuleSpecifierResolutionHost, userPreferences: UserPreferences, options?: ModuleSpecifierOptions): {
            moduleSpecifiers: readonly string[];
            computedWithoutCache: boolean;
        };
        /** @internal */
        function countPathComponents(path: string): number;
        /** @internal */
        function forEachFileNameOfModule<T>(importingFileName: string, importedFileName: string, host: ModuleSpecifierResolutionHost, preferSymlinks: boolean, cb: (fileName: string, isRedirect: boolean) => T | undefined): T | undefined;
        /** @internal */
        function tryGetRealFileNameForNonJsDeclarationFileName(fileName: string): string | undefined;
        /** @internal */
        function tryGetJSExtensionForFile(fileName: string, options: CompilerOptions): Extension | undefined;
    }
    namespace performance {
        /** @internal */
        function createTimerIf(condition: boolean, measureName: string, startMarkName: string, endMarkName: string): Timer;
        /** @internal */
        function createTimer(measureName: string, startMarkName: string, endMarkName: string): Timer;
        /**
         * Marks a performance event.
         *
         * @param markName The name of the mark.
         *
         * @internal
         */
        function mark(markName: string): void;
        /**
         * Adds a performance measurement with the specified name.
         *
         * @param measureName The name of the performance measurement.
         * @param startMarkName The name of the starting mark. If not supplied, the point at which the
         *      profiler was enabled is used.
         * @param endMarkName The name of the ending mark. If not supplied, the current timestamp is
         *      used.
         *
         * @internal
         */
        function measure(measureName: string, startMarkName?: string, endMarkName?: string): void;
        /**
         * Gets the number of times a marker was encountered.
         *
         * @param markName The name of the mark.
         *
         * @internal
         */
        function getCount(markName: string): number;
        /**
         * Gets the total duration of all measurements with the supplied name.
         *
         * @param measureName The name of the measure whose durations should be accumulated.
         *
         * @internal
         */
        function getDuration(measureName: string): number;
        /**
         * Iterate over each measure, performing some action
         *
         * @param cb The action to perform for each measure
         *
         * @internal
         */
        function forEachMeasure(cb: (measureName: string, duration: number) => void): void;
        /** @internal */
        function forEachMark(cb: (markName: string) => void): void;
        /** @internal */
        function clearMeasures(name?: string): void;
        /** @internal */
        function clearMarks(name?: string): void;
        /**
         * Indicates whether the performance API is enabled.
         *
         * @internal
         */
        function isEnabled(): boolean;
        /**
         * Enables (and resets) performance measurements for the compiler.
         *
         * @internal
         */
        function enable(system?: System): boolean;
        /**
         * Disables performance measurements for the compiler.
         *
         * @internal
         */
        function disable(): void;
        /** @internal */
        interface Timer {
            enter(): void;
            exit(): void;
        }
        /** @internal */
        const nullTimer: Timer;
    }
    const versionMajorMinor = "5.0";
    /** The version of the TypeScript compiler release */
    const version: string;
    /**
     * Type of objects whose values are all of the same type.
     * The `in` and `for-in` operators can *not* be safely used,
     * since `Object.prototype` may be modified by outside code.
     */
    interface MapLike<T> {
        [index: string]: T;
    }
    interface SortedReadonlyArray<T> extends ReadonlyArray<T> {
        " __sortedArrayBrand": any;
    }
    interface SortedArray<T> extends Array<T> {
        " __sortedArrayBrand": any;
    }
    /**
     * Common read methods for ES6 Map/Set.
     *
     * @internal
     */
    interface ReadonlyCollection<K> {
        readonly size: number;
        has(key: K): boolean;
        keys(): IterableIterator<K>;
    }
    /**
     * Common write methods for ES6 Map/Set.
     *
     * @internal
     */
    interface Collection<K> extends ReadonlyCollection<K> {
        delete(key: K): boolean;
        clear(): void;
    }
    /**
     * Array that is only intended to be pushed to, never read.
     *
     * @internal
     */
    interface Push<T> {
        push(...values: T[]): void;
        readonly length: number;
    }
    /** @internal */
    type EqualityComparer<T> = (a: T, b: T) => boolean;
    /** @internal */
    type Comparer<T> = (a: T, b: T) => Comparison;
    /** @internal */
    enum Comparison {
        LessThan = -1,
        EqualTo = 0,
        GreaterThan = 1
    }
    /** @internal */
    function length(array: readonly any[] | undefined): number;
    /**
     * Iterates through 'array' by index and performs the callback on each element of array until the callback
     * returns a truthy value, then returns that value.
     * If no such value is found, the callback is applied to each element of array and undefined is returned.
     *
     * @internal
     */
    function forEach<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U | undefined): U | undefined;
    /**
     * Like `forEach`, but iterates in reverse order.
     *
     * @internal
     */
    function forEachRight<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U | undefined): U | undefined;
    /**
     * Like `forEach`, but suitable for use with numbers and strings (which may be falsy).
     *
     * @internal
     */
    function firstDefined<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U | undefined): U | undefined;
    /** @internal */
    function firstDefinedIterator<T, U>(iter: Iterable<T>, callback: (element: T) => U | undefined): U | undefined;
    /** @internal */
    function reduceLeftIterator<T, U>(iterator: Iterable<T> | undefined, f: (memo: U, value: T, i: number) => U, initial: U): U;
    /** @internal */
    function zipWith<T, U, V>(arrayA: readonly T[], arrayB: readonly U[], callback: (a: T, b: U, index: number) => V): V[];
    /**
     * Creates a new array with `element` interspersed in between each element of `input`
     * if there is more than 1 value in `input`. Otherwise, returns the existing array.
     *
     * @internal
     */
    function intersperse<T>(input: T[], element: T): T[];
    /**
     * Iterates through `array` by index and performs the callback on each element of array until the callback
     * returns a falsey value, then returns false.
     * If no such value is found, the callback is applied to each element of array and `true` is returned.
     *
     * @internal
     */
    function every<T, U extends T>(array: readonly T[], callback: (element: T, index: number) => element is U): array is readonly U[];
    /** @internal */
    function every<T, U extends T>(array: readonly T[] | undefined, callback: (element: T, index: number) => element is U): array is readonly U[] | undefined;
    /** @internal */
    function every<T>(array: readonly T[] | undefined, callback: (element: T, index: number) => boolean): boolean;
    /**
     * Works like Array.prototype.find, returning `undefined` if no element satisfying the predicate is found.
     *
     * @internal
     */
    function find<T, U extends T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => element is U, startIndex?: number): U | undefined;
    /** @internal */
    function find<T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => boolean, startIndex?: number): T | undefined;
    /** @internal */
    function findLast<T, U extends T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => element is U, startIndex?: number): U | undefined;
    /** @internal */
    function findLast<T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => boolean, startIndex?: number): T | undefined;
    /**
     * Works like Array.prototype.findIndex, returning `-1` if no element satisfying the predicate is found.
     *
     * @internal
     */
    function findIndex<T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => boolean, startIndex?: number): number;
    /** @internal */
    function findLastIndex<T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => boolean, startIndex?: number): number;
    /**
     * Returns the first truthy result of `callback`, or else fails.
     * This is like `forEach`, but never returns undefined.
     *
     * @internal
     */
    function findMap<T, U>(array: readonly T[], callback: (element: T, index: number) => U | undefined): U;
    /** @internal */
    function contains<T>(array: readonly T[] | undefined, value: T, equalityComparer?: EqualityComparer<T>): boolean;
    /** @internal */
    function arraysEqual<T>(a: readonly T[], b: readonly T[], equalityComparer?: EqualityComparer<T>): boolean;
    /** @internal */
    function indexOfAnyCharCode(text: string, charCodes: readonly number[], start?: number): number;
    /** @internal */
    function countWhere<T>(array: readonly T[] | undefined, predicate: (x: T, i: number) => boolean): number;
    /**
     * Filters an array by a predicate function. Returns the same array instance if the predicate is
     * true for all elements, otherwise returns a new array instance containing the filtered subset.
     *
     * @internal
     */
    function filter<T, U extends T>(array: T[], f: (x: T) => x is U): U[];
    /** @internal */
    function filter<T>(array: T[], f: (x: T) => boolean): T[];
    /** @internal */
    function filter<T, U extends T>(array: readonly T[], f: (x: T) => x is U): readonly U[];
    /** @internal */
    function filter<T, U extends T>(array: readonly T[], f: (x: T) => boolean): readonly T[];
    /** @internal */
    function filter<T, U extends T>(array: T[] | undefined, f: (x: T) => x is U): U[] | undefined;
    /** @internal */
    function filter<T>(array: T[] | undefined, f: (x: T) => boolean): T[] | undefined;
    /** @internal */
    function filter<T, U extends T>(array: readonly T[] | undefined, f: (x: T) => x is U): readonly U[] | undefined;
    /** @internal */
    function filter<T, U extends T>(array: readonly T[] | undefined, f: (x: T) => boolean): readonly T[] | undefined;
    /** @internal */
    function filterMutate<T>(array: T[], f: (x: T, i: number, array: T[]) => boolean): void;
    /** @internal */
    function clear(array: unknown[]): void;
    /** @internal */
    function map<T, U>(array: readonly T[], f: (x: T, i: number) => U): U[];
    /** @internal */
    function map<T, U>(array: readonly T[] | undefined, f: (x: T, i: number) => U): U[] | undefined;
    /** @internal */
    function mapIterator<T, U>(iter: Iterable<T>, mapFn: (x: T) => U): Generator<U, void, unknown>;
    /**
     * Maps from T to T and avoids allocation if all elements map to themselves
     *
     * @internal */
    function sameMap<T>(array: T[], f: (x: T, i: number) => T): T[];
    /** @internal */
    function sameMap<T>(array: readonly T[], f: (x: T, i: number) => T): readonly T[];
    /** @internal */
    function sameMap<T>(array: T[] | undefined, f: (x: T, i: number) => T): T[] | undefined;
    /** @internal */
    function sameMap<T>(array: readonly T[] | undefined, f: (x: T, i: number) => T): readonly T[] | undefined;
    /**
     * Flattens an array containing a mix of array or non-array elements.
     *
     * @param array The array to flatten.
     *
     * @internal
     */
    function flatten<T>(array: T[][] | readonly (T | readonly T[] | undefined)[]): T[];
    /**
     * Maps an array. If the mapped value is an array, it is spread into the result.
     *
     * @param array The array to map.
     * @param mapfn The callback used to map the result into one or more values.
     *
     * @internal
     */
    function flatMap<T, U>(array: readonly T[] | undefined, mapfn: (x: T, i: number) => U | readonly U[] | undefined): readonly U[];
    /** @internal */
    function flatMapToMutable<T, U>(array: readonly T[] | undefined, mapfn: (x: T, i: number) => U | readonly U[] | undefined): U[];
    /** @internal */
    function flatMapIterator<T, U>(iter: Iterable<T>, mapfn: (x: T) => readonly U[] | Iterable<U> | undefined): Generator<U, void, undefined>;
    /**
     * Maps an array. If the mapped value is an array, it is spread into the result.
     * Avoids allocation if all elements map to themselves.
     *
     * @param array The array to map.
     * @param mapfn The callback used to map the result into one or more values.
     *
     * @internal
     */
    function sameFlatMap<T>(array: T[], mapfn: (x: T, i: number) => T | readonly T[]): T[];
    /** @internal */
    function sameFlatMap<T>(array: readonly T[], mapfn: (x: T, i: number) => T | readonly T[]): readonly T[];
    /** @internal */
    function mapAllOrFail<T, U>(array: readonly T[], mapFn: (x: T, i: number) => U | undefined): U[] | undefined;
    /** @internal */
    function mapDefined<T, U>(array: readonly T[] | undefined, mapFn: (x: T, i: number) => U | undefined): U[];
    /** @internal */
    function mapDefinedIterator<T, U>(iter: Iterable<T>, mapFn: (x: T) => U | undefined): Generator<U & ({} | null), void, unknown>;
    /** @internal */
    function mapDefinedEntries<K1, V1, K2, V2>(map: ReadonlyMap<K1, V1>, f: (key: K1, value: V1) => readonly [
        K2,
        V2
    ] | undefined): Map<K2, V2>;
    /** @internal */
    function mapDefinedEntries<K1, V1, K2, V2>(map: ReadonlyMap<K1, V1> | undefined, f: (key: K1, value: V1) => readonly [
        K2 | undefined,
        V2 | undefined
    ] | undefined): Map<K2, V2> | undefined;
    /** @internal */
    function getOrUpdate<K, V>(map: Map<K, V>, key: K, callback: () => V): V;
    /** @internal */
    function tryAddToSet<T>(set: Set<T>, value: T): boolean;
    /** @internal */
    function singleIterator<T>(value: T): Generator<T, void, unknown>;
    /**
     * Maps contiguous spans of values with the same key.
     *
     * @param array The array to map.
     * @param keyfn A callback used to select the key for an element.
     * @param mapfn A callback used to map a contiguous chunk of values to a single value.
     *
     * @internal
     */
    function spanMap<T, K, U>(array: readonly T[], keyfn: (x: T, i: number) => K, mapfn: (chunk: T[], key: K, start: number, end: number) => U): U[];
    /** @internal */
    function spanMap<T, K, U>(array: readonly T[] | undefined, keyfn: (x: T, i: number) => K, mapfn: (chunk: T[], key: K, start: number, end: number) => U): U[] | undefined;
    /** @internal */
    function mapEntries<K1, V1, K2, V2>(map: ReadonlyMap<K1, V1>, f: (key: K1, value: V1) => readonly [
        K2,
        V2
    ]): Map<K2, V2>;
    /** @internal */
    function mapEntries<K1, V1, K2, V2>(map: ReadonlyMap<K1, V1> | undefined, f: (key: K1, value: V1) => readonly [
        K2,
        V2
    ]): Map<K2, V2> | undefined;
    /** @internal */
    function some<T>(array: readonly T[] | undefined): array is readonly T[];
    /** @internal */
    function some<T>(array: readonly T[] | undefined, predicate: (value: T) => boolean): boolean;
    /**
     * Calls the callback with (start, afterEnd) index pairs for each range where 'pred' is true.
     *
     * @internal
     */
    function getRangesWhere<T>(arr: readonly T[], pred: (t: T) => boolean, cb: (start: number, afterEnd: number) => void): void;
    /** @internal */
    function concatenate<T>(array1: T[], array2: T[]): T[];
    /** @internal */
    function concatenate<T>(array1: readonly T[], array2: readonly T[]): readonly T[];
    /** @internal */
    function concatenate<T>(array1: T[], array2: T[] | undefined): T[];
    /** @internal */
    function concatenate<T>(array1: T[] | undefined, array2: T[]): T[];
    /** @internal */
    function concatenate<T>(array1: readonly T[], array2: readonly T[] | undefined): readonly T[];
    /** @internal */
    function concatenate<T>(array1: readonly T[] | undefined, array2: readonly T[]): readonly T[];
    /** @internal */
    function concatenate<T>(array1: T[] | undefined, array2: T[] | undefined): T[] | undefined;
    /** @internal */
    function concatenate<T>(array1: readonly T[] | undefined, array2: readonly T[] | undefined): readonly T[] | undefined;
    /** @internal */
    function indicesOf(array: readonly unknown[]): number[];
    /**
     * Deduplicates an unsorted array.
     * @param equalityComparer An `EqualityComparer` used to determine if two values are duplicates.
     * @param comparer An optional `Comparer` used to sort entries before comparison, though the
     * result will remain in the original order in `array`.
     *
     * @internal
     */
    function deduplicate<T>(array: readonly T[], equalityComparer: EqualityComparer<T>, comparer?: Comparer<T>): T[];
    /** @internal */
    function createSortedArray<T>(): SortedArray<T>;
    /** @internal */
    function insertSorted<T>(array: SortedArray<T>, insert: T, compare: Comparer<T>, allowDuplicates?: boolean): boolean;
    /** @internal */
    function sortAndDeduplicate<T>(array: readonly string[]): SortedReadonlyArray<string>;
    /** @internal */
    function sortAndDeduplicate<T>(array: readonly T[], comparer: Comparer<T>, equalityComparer?: EqualityComparer<T>): SortedReadonlyArray<T>;
    /** @internal */
    function arrayIsSorted<T>(array: readonly T[], comparer: Comparer<T>): boolean;
    /** @internal */
    function detectSortCaseSensitivity<T>(array: readonly T[], getString: (element: T) => string, compareStringsCaseSensitive: Comparer<string>, compareStringsCaseInsensitive: Comparer<string>): SortKind;
    /** @internal */
    function arrayIsEqualTo<T>(array1: readonly T[] | undefined, array2: readonly T[] | undefined, equalityComparer?: (a: T, b: T, index: number) => boolean): boolean;
    /**
     * Compacts an array, removing any falsey elements.
     *
     * @internal
     */
    function compact<T>(array: (T | undefined | null | false | 0 | "")[]): T[];
    /** @internal */
    function compact<T>(array: readonly (T | undefined | null | false | 0 | "")[]): readonly T[];
    /** @internal */
    function compact<T>(array: T[]): T[];
    /** @internal */
    function compact<T>(array: readonly T[]): readonly T[];
    /**
     * Gets the relative complement of `arrayA` with respect to `arrayB`, returning the elements that
     * are not present in `arrayA` but are present in `arrayB`. Assumes both arrays are sorted
     * based on the provided comparer.
     *
     * @internal
     */
    function relativeComplement<T>(arrayA: T[] | undefined, arrayB: T[] | undefined, comparer: Comparer<T>): T[] | undefined;
    /**
     * Appends a value to an array, returning the array.
     *
     * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array
     * is created if `value` was appended.
     * @param value The value to append to the array. If `value` is `undefined`, nothing is
     * appended.
     *
     * @internal
     */
    function append<TArray extends any[] | undefined, TValue extends NonNullable<TArray>[number] | undefined>(to: TArray, value: TValue): [
        undefined,
        undefined
    ] extends [
        TArray,
        TValue
    ] ? TArray : NonNullable<TArray>[number][];
    /** @internal */
    function append<T>(to: T[], value: T | undefined): T[];
    /** @internal */
    function append<T>(to: T[] | undefined, value: T): T[];
    /** @internal */
    function append<T>(to: T[] | undefined, value: T | undefined): T[] | undefined;
    /** @internal */
    function append<T>(to: Push<T>, value: T | undefined): void;
    /**
     * Combines two arrays, values, or undefineds into the smallest container that can accommodate the resulting set:
     *
     * ```
     * undefined -> undefined -> undefined
     * T -> undefined -> T
     * T -> T -> T[]
     * T[] -> undefined -> T[] (no-op)
     * T[] -> T -> T[]         (append)
     * T[] -> T[] -> T[]       (concatenate)
     * ```
     *
     * @internal
     */
    function combine<T>(xs: T[] | undefined, ys: T[] | undefined): T[] | undefined;
    /** @internal */
    function combine<T>(xs: T | readonly T[] | undefined, ys: T | readonly T[] | undefined): T | readonly T[] | undefined;
    /** @internal */
    function combine<T>(xs: T | T[] | undefined, ys: T | T[] | undefined): T | T[] | undefined;
    /**
     * Appends a range of value to an array, returning the array.
     *
     * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array
     * is created if `value` was appended.
     * @param from The values to append to the array. If `from` is `undefined`, nothing is
     * appended. If an element of `from` is `undefined`, that element is not appended.
     * @param start The offset in `from` at which to start copying values.
     * @param end The offset in `from` at which to stop copying values (non-inclusive).
     *
     * @internal
     */
    function addRange<T>(to: T[], from: readonly T[] | undefined, start?: number, end?: number): T[];
    /** @internal */
    function addRange<T>(to: T[] | undefined, from: readonly T[] | undefined, start?: number, end?: number): T[] | undefined;
    /**
     * @return Whether the value was added.
     *
     * @internal
     */
    function pushIfUnique<T>(array: T[], toAdd: T, equalityComparer?: EqualityComparer<T>): boolean;
    /**
     * Unlike `pushIfUnique`, this can take `undefined` as an input, and returns a new array.
     *
     * @internal
     */
    function appendIfUnique<T>(array: T[] | undefined, toAdd: T, equalityComparer?: EqualityComparer<T>): T[];
    /**
     * Returns a new sorted array.
     *
     * @internal
     */
    function sort<T>(array: readonly T[], comparer?: Comparer<T>): SortedReadonlyArray<T>;
    /** @internal */
    function arrayReverseIterator<T>(array: readonly T[]): Generator<T, void, unknown>;
    /**
     * Stable sort of an array. Elements equal to each other maintain their relative position in the array.
     *
     * @internal
     */
    function stableSort<T>(array: readonly T[], comparer: Comparer<T>): SortedReadonlyArray<T>;
    /** @internal */
    function rangeEquals<T>(array1: readonly T[], array2: readonly T[], pos: number, end: number): boolean;
    /**
     * Returns the first element of an array if non-empty, `undefined` otherwise.
     *
     * @internal
     */
    function firstOrUndefined<T>(array: readonly T[] | undefined): T | undefined;
    /** @internal */
    function firstOrUndefinedIterator<T>(iter: Iterable<T> | undefined): T | undefined;
    /** @internal */
    function first<T>(array: readonly T[]): T;
    /** @internal */
    function firstIterator<T>(iter: Iterable<T>): T;
    /**
     * Returns the last element of an array if non-empty, `undefined` otherwise.
     *
     * @internal
     */
    function lastOrUndefined<T>(array: readonly T[] | undefined): T | undefined;
    /** @internal */
    function last<T>(array: readonly T[]): T;
    /**
     * Returns the only element of an array if it contains only one element, `undefined` otherwise.
     *
     * @internal
     */
    function singleOrUndefined<T>(array: readonly T[] | undefined): T | undefined;
    /**
     * Returns the only element of an array if it contains only one element; throws otherwise.
     *
     * @internal
     */
    function single<T>(array: readonly T[]): T;
    /**
     * Returns the only element of an array if it contains only one element; otherwise, returns the
     * array.
     *
     * @internal
     */
    function singleOrMany<T>(array: T[]): T | T[];
    /** @internal */
    function singleOrMany<T>(array: readonly T[]): T | readonly T[];
    /** @internal */
    function singleOrMany<T>(array: T[] | undefined): T | T[] | undefined;
    /** @internal */
    function singleOrMany<T>(array: readonly T[] | undefined): T | readonly T[] | undefined;
    /** @internal */
    function replaceElement<T>(array: readonly T[], index: number, value: T): T[];
    /**
     * Performs a binary search, finding the index at which `value` occurs in `array`.
     * If no such index is found, returns the 2's-complement of first index at which
     * `array[index]` exceeds `value`.
     * @param array A sorted array whose first element must be no larger than number
     * @param value The value to be searched for in the array.
     * @param keySelector A callback used to select the search key from `value` and each element of
     * `array`.
     * @param keyComparer A callback used to compare two keys in a sorted array.
     * @param offset An offset into `array` at which to start the search.
     *
     * @internal
     */
    function binarySearch<T, U>(array: readonly T[], value: T, keySelector: (v: T) => U, keyComparer: Comparer<U>, offset?: number): number;
    /**
     * Performs a binary search, finding the index at which an object with `key` occurs in `array`.
     * If no such index is found, returns the 2's-complement of first index at which
     * `array[index]` exceeds `key`.
     * @param array A sorted array whose first element must be no larger than number
     * @param key The key to be searched for in the array.
     * @param keySelector A callback used to select the search key from each element of `array`.
     * @param keyComparer A callback used to compare two keys in a sorted array.
     * @param offset An offset into `array` at which to start the search.
     *
     * @internal
     */
    function binarySearchKey<T, U>(array: readonly T[], key: U, keySelector: (v: T, i: number) => U, keyComparer: Comparer<U>, offset?: number): number;
    /** @internal */
    function reduceLeft<T, U>(array: readonly T[] | undefined, f: (memo: U, value: T, i: number) => U, initial: U, start?: number, count?: number): U;
    /** @internal */
    function reduceLeft<T>(array: readonly T[], f: (memo: T, value: T, i: number) => T): T | undefined;
    /**
     * Indicates whether a map-like contains an own property with the specified key.
     *
     * @param map A map-like.
     * @param key A property key.
     *
     * @internal
     */
    function hasProperty(map: MapLike<any>, key: string): boolean;
    /**
     * Gets the value of an owned property in a map-like.
     *
     * @param map A map-like.
     * @param key A property key.
     *
     * @internal
     */
    function getProperty<T>(map: MapLike<T>, key: string): T | undefined;
    /**
     * Gets the owned, enumerable property keys of a map-like.
     *
     * @internal
     */
    function getOwnKeys<T>(map: MapLike<T>): string[];
    /** @internal */
    function getAllKeys(obj: object): string[];
    /** @internal */
    function getOwnValues<T>(collection: MapLike<T> | T[]): T[];
    /** @internal */
    function arrayOf<T>(count: number, f: (index: number) => T): T[];
    /**
     * Shims `Array.from`.
     *
     * @internal
     */
    function arrayFrom<T, U>(iterator: Iterable<T>, map: (t: T) => U): U[];
    /** @internal */
    function arrayFrom<T>(iterator: Iterable<T>): T[];
    /** @internal */
    function assign<T extends object>(t: T, ...args: (T | undefined)[]): T;
    /**
     * Performs a shallow equality comparison of the contents of two map-likes.
     *
     * @param left A map-like whose properties should be compared.
     * @param right A map-like whose properties should be compared.
     *
     * @internal
     */
    function equalOwnProperties<T>(left: MapLike<T> | undefined, right: MapLike<T> | undefined, equalityComparer?: EqualityComparer<T>): boolean;
    /**
     * Creates a map from the elements of an array.
     *
     * @param array the array of input elements.
     * @param makeKey a function that produces a key for a given element.
     *
     * This function makes no effort to avoid collisions; if any two elements produce
     * the same key with the given 'makeKey' function, then the element with the higher
     * index in the array will be the one associated with the produced key.
     *
     * @internal
     */
    function arrayToMap<K, V>(array: readonly V[], makeKey: (value: V) => K | undefined): Map<K, V>;
    /** @internal */
    function arrayToMap<K, V1, V2>(array: readonly V1[], makeKey: (value: V1) => K | undefined, makeValue: (value: V1) => V2): Map<K, V2>;
    /** @internal */
    function arrayToMap<T>(array: readonly T[], makeKey: (value: T) => string | undefined): Map<string, T>;
    /** @internal */
    function arrayToMap<T, U>(array: readonly T[], makeKey: (value: T) => string | undefined, makeValue: (value: T) => U): Map<string, U>;
    /** @internal */
    function arrayToNumericMap<T>(array: readonly T[], makeKey: (value: T) => number): T[];
    /** @internal */
    function arrayToNumericMap<T, U>(array: readonly T[], makeKey: (value: T) => number, makeValue: (value: T) => U): U[];
    /** @internal */
    function arrayToMultiMap<K, V>(values: readonly V[], makeKey: (value: V) => K): MultiMap<K, V>;
    /** @internal */
    function arrayToMultiMap<K, V, U>(values: readonly V[], makeKey: (value: V) => K, makeValue: (value: V) => U): MultiMap<K, U>;
    /** @internal */
    function group<T, K>(values: readonly T[], getGroupId: (value: T) => K): readonly (readonly T[])[];
    /** @internal */
    function group<T, K, R>(values: readonly T[], getGroupId: (value: T) => K, resultSelector: (values: readonly T[]) => R): R[];
    /** @internal */
    function group<T>(values: readonly T[], getGroupId: (value: T) => string): readonly (readonly T[])[];
    /** @internal */
    function group<T, R>(values: readonly T[], getGroupId: (value: T) => string, resultSelector: (values: readonly T[]) => R): R[];
    /** @internal */
    function groupBy<T, U extends T>(values: readonly T[] | undefined, keySelector: (value: T) => value is U): {
        true?: U[];
        false?: Exclude<T, U>[];
    };
    /** @internal */
    function groupBy<T, K extends string | number | boolean | null | undefined>(values: readonly T[] | undefined, keySelector: (value: T) => K): {
        [P in K as `${P}`]?: T[];
    };
    /** @internal */
    function clone<T>(object: T): T;
    /**
     * Creates a new object by adding the own properties of `second`, then the own properties of `first`.
     *
     * NOTE: This means that if a property exists in both `first` and `second`, the property in `first` will be chosen.
     *
     * @internal
     */
    function extend<T1, T2>(first: T1, second: T2): T1 & T2;
    /** @internal */
    function copyProperties<T1 extends T2, T2>(first: T1, second: T2): void;
    /** @internal */
    function maybeBind<T, A extends any[], R>(obj: T, fn: ((this: T, ...args: A) => R) | undefined): ((...args: A) => R) | undefined;
    /** @internal */
    function createMultiMap<K, V>(): MultiMap<K, V>;
    /** @internal */
    function createMultiMap<V>(): MultiMap<string, V>;
    /** @internal */
    function createUnderscoreEscapedMultiMap<T>(): UnderscoreEscapedMultiMap<T>;
    /** @internal */
    function createQueue<T>(items?: readonly T[]): Queue<T>;
    /**
     * Creates a Set with custom equality and hash code functionality.  This is useful when you
     * want to use something looser than object identity - e.g. "has the same span".
     *
     * If `equals(a, b)`, it must be the case that `getHashCode(a) === getHashCode(b)`.
     * The converse is not required.
     *
     * To facilitate a perf optimization (lazy allocation of bucket arrays), `TElement` is
     * assumed not to be an array type.
     *
     * @internal
     */
    function createSet<TElement, THash = number>(getHashCode: (element: TElement) => THash, equals: EqualityComparer<TElement>): Set<TElement>;
    /**
     * Tests whether a value is an array.
     *
     * @internal
     */
    function isArray(value: any): value is readonly unknown[];
    /** @internal */
    function toArray<T>(value: T | T[]): T[];
    /** @internal */
    function toArray<T>(value: T | readonly T[]): readonly T[];
    /**
     * Tests whether a value is string
     *
     * @internal
     */
    function isString(text: unknown): text is string;
    /** @internal */
    function isNumber(x: unknown): x is number;
    /** @internal */
    function tryCast<TOut extends TIn, TIn = any>(value: TIn | undefined, test: (value: TIn) => value is TOut): TOut | undefined;
    /** @internal */
    function cast<TOut extends TIn, TIn = any>(value: TIn | undefined, test: (value: TIn) => value is TOut): TOut;
    /**
     * Does nothing.
     *
     * @internal
     */
    function noop(_?: unknown): void;
    /**
     * Do nothing and return false
     *
     * @internal
     */
    function returnFalse(): false;
    /**
     * Do nothing and return true
     *
     * @internal
     */
    function returnTrue(): true;
    /**
     * Do nothing and return undefined
     *
     * @internal
     */
    function returnUndefined(): undefined;
    /**
     * Returns its argument.
     *
     * @internal
     */
    function identity<T>(x: T): T;
    /**
     * Returns lower case string
     *
     * @internal
     */
    function toLowerCase(x: string): string;
    /**
     * Case insensitive file systems have descripencies in how they handle some characters (eg. turkish Upper case I with dot on top - \u0130)
     * This function is used in places where we want to make file name as a key on these systems
     * It is possible on mac to be able to refer to file name with I with dot on top as a fileName with its lower case form
     * But on windows we cannot. Windows can have fileName with I with dot on top next to its lower case and they can not each be referred with the lowercase forms
     * Technically we would want this function to be platform sepcific as well but
     * our api has till now only taken caseSensitive as the only input and just for some characters we dont want to update API and ensure all customers use those api
     * We could use upper case and we would still need to deal with the descripencies but
     * we want to continue using lower case since in most cases filenames are lowercasewe and wont need any case changes and avoid having to store another string for the key
     * So for this function purpose, we go ahead and assume character I with dot on top it as case sensitive since its very unlikely to use lower case form of that special character
     *
     * @internal
     */
    function toFileNameLowerCase(x: string): string;
    /**
     * Throws an error because a function is not implemented.
     *
     * @internal
     */
    function notImplemented(): never;
    /** @internal */
    function memoize<T>(callback: () => T): () => T;
    /**
     * A version of `memoize` that supports a single primitive argument
     *
     * @internal
     */
    function memoizeOne<A extends string | number | boolean | undefined, T>(callback: (arg: A) => T): (arg: A) => T;
    /**
     * A version of `memoize` that supports a single non-primitive argument, stored as keys of a WeakMap.
     *
     * @internal
     */
    function memoizeWeak<A extends object, T>(callback: (arg: A) => T): (arg: A) => T;
    /**
     * A version of `memoize` that supports multiple arguments, backed by a provided cache.
     *
     * @internal
     */
    function memoizeCached<A extends any[], T>(callback: (...args: A) => T, cache: MemoizeCache<A, T>): (...args: A) => T;
    /**
     * High-order function, composes functions. Note that functions are composed inside-out;
     * for example, `compose(a, b)` is the equivalent of `x => b(a(x))`.
     *
     * @param args The functions to compose.
     *
     * @internal
     */
    function compose<T>(...args: ((t: T) => T)[]): (t: T) => T;
    /** @internal */
    function equateValues<T>(a: T, b: T): boolean;
    /**
     * Compare the equality of two strings using a case-sensitive ordinal comparison.
     *
     * Case-sensitive comparisons compare both strings one code-point at a time using the integer
     * value of each code-point after applying `toUpperCase` to each string. We always map both
     * strings to their upper-case form as some unicode characters do not properly round-trip to
     * lowercase (such as `ẞ` (German sharp capital s)).
     *
     * @internal
     */
    function equateStringsCaseInsensitive(a: string, b: string): boolean;
    /**
     * Compare the equality of two strings using a case-sensitive ordinal comparison.
     *
     * Case-sensitive comparisons compare both strings one code-point at a time using the
     * integer value of each code-point.
     *
     * @internal
     */
    function equateStringsCaseSensitive(a: string, b: string): boolean;
    /**
     * Compare two numeric values for their order relative to each other.
     * To compare strings, use any of the `compareStrings` functions.
     *
     * @internal
     */
    function compareValues(a: number | undefined, b: number | undefined): Comparison;
    /**
     * Compare two TextSpans, first by `start`, then by `length`.
     *
     * @internal
     */
    function compareTextSpans(a: Partial<TextSpan> | undefined, b: Partial<TextSpan> | undefined): Comparison;
    /** @internal */
    function min<T>(items: readonly [
        T,
        ...T[]
    ], compare: Comparer<T>): T;
    /** @internal */
    function min<T>(items: readonly T[], compare: Comparer<T>): T | undefined;
    /**
     * Compare two strings using a case-insensitive ordinal comparison.
     *
     * Ordinal comparisons are based on the difference between the unicode code points of both
     * strings. Characters with multiple unicode representations are considered unequal. Ordinal
     * comparisons provide predictable ordering, but place "a" after "B".
     *
     * Case-insensitive comparisons compare both strings one code-point at a time using the integer
     * value of each code-point after applying `toUpperCase` to each string. We always map both
     * strings to their upper-case form as some unicode characters do not properly round-trip to
     * lowercase (such as `ẞ` (German sharp capital s)).
     *
     * @internal
     */
    function compareStringsCaseInsensitive(a: string, b: string): Comparison;
    /**
     * `compareStringsCaseInsensitive` transforms letters to uppercase for unicode reasons,
     * while eslint's `sort-imports` rule transforms letters to lowercase. Which one you choose
     * affects the relative order of letters and ASCII characters 91-96, of which `_` is a
     * valid character in an identifier. So if we used `compareStringsCaseInsensitive` for
     * import sorting, TypeScript and eslint would disagree about the correct case-insensitive
     * sort order for `__String` and `Foo`. Since eslint's whole job is to create consistency
     * by enforcing nitpicky details like this, it makes way more sense for us to just adopt
     * their convention so users can have auto-imports without making eslint angry.
     *
     * @internal
     */
    function compareStringsCaseInsensitiveEslintCompatible(a: string, b: string): Comparison;
    /**
     * Compare two strings using a case-sensitive ordinal comparison.
     *
     * Ordinal comparisons are based on the difference between the unicode code points of both
     * strings. Characters with multiple unicode representations are considered unequal. Ordinal
     * comparisons provide predictable ordering, but place "a" after "B".
     *
     * Case-sensitive comparisons compare both strings one code-point at a time using the integer
     * value of each code-point.
     *
     * @internal
     */
    function compareStringsCaseSensitive(a: string | undefined, b: string | undefined): Comparison;
    /** @internal */
    function getStringComparer(ignoreCase?: boolean): typeof compareStringsCaseInsensitive;
    /** @internal */
    function getUILocale(): string | undefined;
    /** @internal */
    function setUILocale(value: string | undefined): void;
    /**
     * Compare two strings in a using the case-sensitive sort behavior of the UI locale.
     *
     * Ordering is not predictable between different host locales, but is best for displaying
     * ordered data for UI presentation. Characters with multiple unicode representations may
     * be considered equal.
     *
     * Case-sensitive comparisons compare strings that differ in base characters, or
     * accents/diacritic marks, or case as unequal.
     *
     * @internal
     */
    function compareStringsCaseSensitiveUI(a: string, b: string): Comparison;
    /** @internal */
    function compareProperties<T extends object, K extends keyof T>(a: T | undefined, b: T | undefined, key: K, comparer: Comparer<T[K]>): Comparison;
    /**
     * True is greater than false.
     *
     * @internal
     */
    function compareBooleans(a: boolean, b: boolean): Comparison;
    /**
     * Given a name and a list of names that are *not* equal to the name, return a spelling suggestion if there is one that is close enough.
     * Names less than length 3 only check for case-insensitive equality.
     *
     * find the candidate with the smallest Levenshtein distance,
     *    except for candidates:
     *      * With no name
     *      * Whose length differs from the target name by more than 0.34 of the length of the name.
     *      * Whose levenshtein distance is more than 0.4 of the length of the name
     *        (0.4 allows 1 substitution/transposition for every 5 characters,
     *         and 1 insertion/deletion at 3 characters)
     *
     * @internal
     */
    function getSpellingSuggestion<T>(name: string, candidates: T[], getName: (candidate: T) => string | undefined): T | undefined;
    /** @internal */
    function endsWith(str: string, suffix: string): boolean;
    /** @internal */
    function removeSuffix(str: string, suffix: string): string;
    /** @internal */
    function tryRemoveSuffix(str: string, suffix: string): string | undefined;
    /** @internal */
    function stringContains(str: string, substring: string): boolean;
    /**
     * Takes a string like "jquery-min.4.2.3" and returns "jquery"
     *
     * @internal
     */
    function removeMinAndVersionNumbers(fileName: string): string;
    /**
     * Remove an item from an array, moving everything to its right one space left.
     *
     * @internal
     */
    function orderedRemoveItem<T>(array: T[], item: T): boolean;
    /**
     * Remove an item by index from an array, moving everything to its right one space left.
     *
     * @internal
     */
    function orderedRemoveItemAt<T>(array: T[], index: number): void;
    /** @internal */
    function unorderedRemoveItemAt<T>(array: T[], index: number): void;
    /**
     * Remove the *first* occurrence of `item` from the array.
     *
     * @internal
     */
    function unorderedRemoveItem<T>(array: T[], item: T): boolean;
    /** @internal */
    function createGetCanonicalFileName(useCaseSensitiveFileNames: boolean): GetCanonicalFileName;
    /** @internal */
    function patternText({ prefix, suffix }: Pattern): string;
    /**
     * Given that candidate matches pattern, returns the text matching the '*'.
     * E.g.: matchedText(tryParsePattern("foo*baz"), "foobarbaz") === "bar"
     *
     * @internal
     */
    function matchedText(pattern: Pattern, candidate: string): string;
    /**
     * Return the object corresponding to the best pattern to match `candidate`.
     *
     * @internal
     */
    function findBestPatternMatch<T>(values: readonly T[], getPattern: (value: T) => Pattern, candidate: string): T | undefined;
    /** @internal */
    function startsWith(str: string, prefix: string): boolean;
    /** @internal */
    function removePrefix(str: string, prefix: string): string;
    /** @internal */
    function tryRemovePrefix(str: string, prefix: string, getCanonicalFileName?: GetCanonicalFileName): string | undefined;
    /** @internal */
    function isPatternMatch({ prefix, suffix }: Pattern, candidate: string): boolean;
    /** @internal */
    function and<T>(f: (arg: T) => boolean, g: (arg: T) => boolean): (arg: T) => boolean;
    /** @internal */
    function or<P, R1 extends P, R2 extends P>(f1: (p1: P) => p1 is R1, f2: (p2: P) => p2 is R2): (p: P) => p is R1 | R2;
    /** @internal */
    function or<P, R1 extends P, R2 extends P, R3 extends P>(f1: (p1: P) => p1 is R1, f2: (p2: P) => p2 is R2, f3: (p3: P) => p3 is R3): (p: P) => p is R1 | R2 | R3;
    /** @internal */
    function or<T extends unknown[], U>(...fs: ((...args: T) => U)[]): (...args: T) => U;
    /** @internal */
    function not<T extends unknown[]>(fn: (...args: T) => boolean): (...args: T) => boolean;
    /** @internal */
    function assertType<T>(_: T): void;
    /** @internal */
    function singleElementArray<T>(t: T | undefined): T[] | undefined;
    /** @internal */
    function enumerateInsertsAndDeletes<T, U>(newItems: readonly T[], oldItems: readonly U[], comparer: (a: T, b: U) => Comparison, inserted: (newItem: T) => void, deleted: (oldItem: U) => void, unchanged?: (oldItem: U, newItem: T) => void): boolean;
    /** @internal */
    function cartesianProduct<T>(arrays: readonly T[][]): T[][];
    /**
     * Returns string left-padded with spaces or zeros until it reaches the given length.
     *
     * @param s String to pad.
     * @param length Final padded length. If less than or equal to 's.length', returns 's' unchanged.
     * @param padString Character to use as padding (default " ").
     *
     * @internal
     */
    function padLeft(s: string, length: number, padString?: " " | "0"): string;
    /**
     * Returns string right-padded with spaces until it reaches the given length.
     *
     * @param s String to pad.
     * @param length Final padded length. If less than or equal to 's.length', returns 's' unchanged.
     * @param padString Character to use as padding (default " ").
     *
     * @internal
     */
    function padRight(s: string, length: number, padString?: " "): string;
    /** @internal */
    function takeWhile<T, U extends T>(array: readonly T[], predicate: (element: T) => element is U): U[];
    /** @internal */
    function takeWhile<T, U extends T>(array: readonly T[] | undefined, predicate: (element: T) => element is U): U[] | undefined;
    /** @internal */
    function skipWhile<T, U extends T>(array: readonly T[], predicate: (element: T) => element is U): Exclude<T, U>[];
    /** @internal */
    function skipWhile<T, U extends T>(array: readonly T[] | undefined, predicate: (element: T) => element is U): Exclude<T, U>[] | undefined;
    /** @internal */
    function isNodeLikeSystem(): boolean;
    /** @internal */
    const emptyArray: never[];
    /** @internal */
    const emptyMap: ReadonlyMap<never, never>;
    /** @internal */
    const emptySet: ReadonlySet<never>;
    /** @internal */
    enum SortKind {
        None = 0,
        CaseSensitive = 1,
        CaseInsensitive = 2,
        Both = 3
    }
    /**
     * Returns the element at a specific offset in an array if non-empty, `undefined` otherwise.
     * A negative offset indicates the element should be retrieved from the end of the array.
     *
     * @internal
     */
    const elementAt: <T>(array: readonly T[] | undefined, offset: number) => T | undefined;
    /** @internal */
    interface MultiMap<K, V> extends Map<K, V[]> {
        /**
         * Adds the value to an array of values associated with the key, and returns the array.
         * Creates the array if it does not already exist.
         */
        add(key: K, value: V): V[];
        /**
         * Removes a value from an array of values associated with the key.
         * Does not preserve the order of those values.
         * Does nothing if `key` is not in `map`, or `value` is not in `map[key]`.
         */
        remove(key: K, value: V): void;
    }
    /** @internal */
    interface UnderscoreEscapedMultiMap<T> extends UnderscoreEscapedMap<T[]> {
        /**
         * Adds the value to an array of values associated with the key, and returns the array.
         * Creates the array if it does not already exist.
         */
        add(key: __String, value: T): T[];
        /**
         * Removes a value from an array of values associated with the key.
         * Does not preserve the order of those values.
         * Does nothing if `key` is not in `map`, or `value` is not in `map[key]`.
         */
        remove(key: __String, value: T): void;
    }
    /** @internal */
    const noopPush: Push<any>;
    /** @internal */
    interface MemoizeCache<A extends any[], T> {
        has(args: A): boolean;
        get(args: A): T | undefined;
        set(args: A, value: T): void;
    }
    /** @internal */
    enum AssertionLevel {
        None = 0,
        Normal = 1,
        Aggressive = 2,
        VeryAggressive = 3
    }
    /**
     * Safer version of `Function` which should not be called.
     * Every function should be assignable to this, but this should not be assignable to every function.
     *
     * @internal
     */
    type AnyFunction = (...args: never[]) => void;
    /** @internal */
    type AnyConstructor = new (...args: unknown[]) => unknown;
    /** @internal */
    type GetCanonicalFileName = (fileName: string) => string;
    /**
     * Represents a "prefix*suffix" pattern.
     *
     * @internal
     */
    interface Pattern {
        prefix: string;
        suffix: string;
    }
    /**
     * Removes the leading and trailing white space and line terminator characters from a string.
     *
     * @internal
     */
    const trimString: (s: string) => string;
    /**
     * Returns a copy with trailing whitespace removed.
     *
     * @internal
     */
    const trimStringEnd: (s: string) => string;
    /**
     * Returns a copy with leading whitespace removed.
     *
     * @internal
     */
    const trimStringStart: (s: string) => string;
    /** @internal */
    enum LogLevel {
        Off = 0,
        Error = 1,
        Warning = 2,
        Info = 3,
        Verbose = 4
    }
    /** @internal */
    interface LoggingHost {
        log(level: LogLevel, s: string): void;
    }
    /** @internal */
    namespace Debug {
        let currentLogLevel: ts.LogLevel;
        let isDebugging: boolean;
        let loggingHost: LoggingHost | undefined;
        function shouldLog(level: LogLevel): boolean;
        function log(s: string): void;
        namespace log {
            function error(s: string): void;
            function warn(s: string): void;
            function log(s: string): void;
            function trace(s: string): void;
        }
        function getAssertionLevel(): ts.AssertionLevel;
        function setAssertionLevel(level: AssertionLevel): void;
        function shouldAssert(level: AssertionLevel): boolean;
        function fail(message?: string, stackCrawlMark?: AnyFunction): never;
        function failBadSyntaxKind(node: Node, message?: string, stackCrawlMark?: AnyFunction): never;
        function assert(expression: unknown, message?: string, verboseDebugInfo?: string | (() => string), stackCrawlMark?: AnyFunction): asserts expression;
        function assertEqual<T>(a: T, b: T, msg?: string, msg2?: string, stackCrawlMark?: AnyFunction): void;
        function assertLessThan(a: number, b: number, msg?: string, stackCrawlMark?: AnyFunction): void;
        function assertLessThanOrEqual(a: number, b: number, stackCrawlMark?: AnyFunction): void;
        function assertGreaterThanOrEqual(a: number, b: number, stackCrawlMark?: AnyFunction): void;
        function assertIsDefined<T>(value: T, message?: string, stackCrawlMark?: AnyFunction): asserts value is NonNullable<T>;
        function checkDefined<T>(value: T | null | undefined, message?: string, stackCrawlMark?: AnyFunction): T;
        function assertEachIsDefined<T extends Node>(value: NodeArray<T>, message?: string, stackCrawlMark?: AnyFunction): asserts value is NodeArray<T>;
        function assertEachIsDefined<T>(value: readonly T[], message?: string, stackCrawlMark?: AnyFunction): asserts value is readonly NonNullable<T>[];
        function checkEachDefined<T, A extends readonly T[]>(value: A, message?: string, stackCrawlMark?: AnyFunction): A;
        function assertNever(member: never, message?: string, stackCrawlMark?: AnyFunction): never;
        function assertEachNode<T extends Node, U extends T>(nodes: NodeArray<T>, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts nodes is NodeArray<U>;
        function assertEachNode<T extends Node, U extends T>(nodes: readonly T[], test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts nodes is readonly U[];
        function assertEachNode<T extends Node, U extends T>(nodes: NodeArray<T> | undefined, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts nodes is NodeArray<U> | undefined;
        function assertEachNode<T extends Node, U extends T>(nodes: readonly T[] | undefined, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts nodes is readonly U[] | undefined;
        function assertEachNode(nodes: readonly Node[], test: ((node: Node) => boolean) | undefined, message?: string, stackCrawlMark?: AnyFunction): void;
        function assertNode<T extends Node, U extends T>(node: T | undefined, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts node is U;
        function assertNode(node: Node | undefined, test: ((node: Node) => boolean) | undefined, message?: string, stackCrawlMark?: AnyFunction): void;
        function assertNotNode<T extends Node, U extends T>(node: T | undefined, test: (node: Node) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts node is Exclude<T, U>;
        function assertNotNode(node: Node | undefined, test: ((node: Node) => boolean) | undefined, message?: string, stackCrawlMark?: AnyFunction): void;
        function assertOptionalNode<T extends Node, U extends T>(node: T, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts node is U;
        function assertOptionalNode<T extends Node, U extends T>(node: T | undefined, test: (node: T) => node is U, message?: string, stackCrawlMark?: AnyFunction): asserts node is U | undefined;
        function assertOptionalNode(node: Node | undefined, test: ((node: Node) => boolean) | undefined, message?: string, stackCrawlMark?: AnyFunction): void;
        function assertOptionalToken<T extends Node, K extends SyntaxKind>(node: T, kind: K, message?: string, stackCrawlMark?: AnyFunction): asserts node is Extract<T, {
            readonly kind: K;
        }>;
        function assertOptionalToken<T extends Node, K extends SyntaxKind>(node: T | undefined, kind: K, message?: string, stackCrawlMark?: AnyFunction): asserts node is Extract<T, {
            readonly kind: K;
        }> | undefined;
        function assertOptionalToken(node: Node | undefined, kind: SyntaxKind | undefined, message?: string, stackCrawlMark?: AnyFunction): void;
        function assertMissingNode(node: Node | undefined, message?: string, stackCrawlMark?: AnyFunction): asserts node is undefined;
        /**
         * Asserts a value has the specified type in typespace only (does not perform a runtime assertion).
         * This is useful in cases where we switch on `node.kind` and can be reasonably sure the type is accurate, and
         * as a result can reduce the number of unnecessary casts.
         */
        function type<T>(value: unknown): asserts value is T;
        function getFunctionName(func: AnyFunction): any;
        function formatSymbol(symbol: Symbol): string;
        /**
         * Formats an enum value as a string for debugging and debug assertions.
         */
        function formatEnum(value: number | undefined, enumObject: any, isFlags?: boolean): string;
        function formatSyntaxKind(kind: SyntaxKind | undefined): string;
        function formatSnippetKind(kind: SnippetKind | undefined): string;
        function formatNodeFlags(flags: NodeFlags | undefined): string;
        function formatModifierFlags(flags: ModifierFlags | undefined): string;
        function formatTransformFlags(flags: TransformFlags | undefined): string;
        function formatEmitFlags(flags: EmitFlags | undefined): string;
        function formatSymbolFlags(flags: SymbolFlags | undefined): string;
        function formatTypeFlags(flags: TypeFlags | undefined): string;
        function formatSignatureFlags(flags: SignatureFlags | undefined): string;
        function formatObjectFlags(flags: ObjectFlags | undefined): string;
        function formatFlowFlags(flags: FlowFlags | undefined): string;
        function formatRelationComparisonResult(result: RelationComparisonResult | undefined): string;
        function formatCheckMode(mode: CheckMode | undefined): string;
        function formatSignatureCheckMode(mode: SignatureCheckMode | undefined): string;
        function formatTypeFacts(facts: TypeFacts | undefined): string;
        function attachFlowNodeDebugInfo(flowNode: FlowNodeBase): void;
        function attachNodeArrayDebugInfo(array: NodeArray<Node>): void;
        /**
         * Injects debug information into frequently used types.
         */
        function enableDebugInfo(): void;
        function formatVariance(varianceFlags: VarianceFlags): string;
        type DebugType = Type & {
            __debugTypeToString(): string;
        };
        class DebugTypeMapper {
            kind: TypeMapKind;
            __debugToString(): string;
        }
        function attachDebugPrototypeIfDebug(mapper: TypeMapper): TypeMapper;
        function printControlFlowGraph(flowNode: FlowNode): void;
        function formatControlFlowGraph(flowNode: FlowNode): string;
    }
    /**
     * Describes a precise semantic version number, https://semver.org
     *
     * @internal
     */
    class Version {
        static readonly zero: Version;
        readonly major: number;
        readonly minor: number;
        readonly patch: number;
        readonly prerelease: readonly string[];
        readonly build: readonly string[];
        constructor(text: string);
        constructor(major: number, minor?: number, patch?: number, prerelease?: string | readonly string[], build?: string | readonly string[]);
        static tryParse(text: string): Version | undefined;
        compareTo(other: Version | undefined): Comparison;
        increment(field: "major" | "minor" | "patch"): Version;
        with(fields: {
            major?: number;
            minor?: number;
            patch?: number;
            prerelease?: string | readonly string[];
            build?: string | readonly string[];
        }): Version;
        toString(): string;
    }
    /**
     * Describes a semantic version range, per https://github.com/npm/node-semver#ranges
     *
     * @internal
     */
    class VersionRange {
        private _alternatives;
        constructor(spec: string);
        static tryParse(text: string): VersionRange | undefined;
        /**
         * Tests whether a version matches the range. This is equivalent to `satisfies(version, range, { includePrerelease: true })`.
         * in `node-semver`.
         */
        test(version: Version | string): boolean;
        toString(): string;
    }
    /** @internal */
    function tryGetNativePerformanceHooks(): PerformanceHooks | undefined;
    /** @internal */
    interface PerformanceHooks {
        /** Indicates whether we should write native performance events */
        shouldWriteNativeEvents: boolean;
        performance: Performance;
        PerformanceObserver: PerformanceObserverConstructor;
    }
    /** @internal */
    interface Performance {
        mark(name: string): void;
        measure(name: string, startMark?: string, endMark?: string): void;
        clearMeasures(name?: string): void;
        clearMarks(name?: string): void;
        now(): number;
        timeOrigin: number;
    }
    /** @internal */
    interface PerformanceEntry {
        name: string;
        entryType: string;
        startTime: number;
        duration: number;
    }
    /** @internal */
    interface PerformanceObserverEntryList {
        getEntries(): PerformanceEntryList;
        getEntriesByName(name: string, type?: string): PerformanceEntryList;
        getEntriesByType(type: string): PerformanceEntryList;
    }
    /** @internal */
    interface PerformanceObserver {
        disconnect(): void;
        observe(options: {
            entryTypes: readonly ("mark" | "measure")[];
        }): void;
    }
    /** @internal */
    type PerformanceObserverConstructor = new (callback: (list: PerformanceObserverEntryList, observer: PerformanceObserver) => void) => PerformanceObserver;
    /** @internal */
    type PerformanceEntryList = PerformanceEntry[];
    /**
     * Gets a timestamp with (at least) ms resolution
     *
     * @internal
     */
    const timestamp: () => number;
    /** @internal */
    interface PerfLogger {
        logEvent(msg: string): void;
        logErrEvent(msg: string): void;
        logPerfEvent(msg: string): void;
        logInfoEvent(msg: string): void;
        logStartCommand(command: string, msg: string): void;
        logStopCommand(command: string, msg: string): void;
        logStartUpdateProgram(msg: string): void;
        logStopUpdateProgram(msg: string): void;
        logStartUpdateGraph(): void;
        logStopUpdateGraph(): void;
        logStartResolveModule(name: string): void;
        logStopResolveModule(success: string): void;
        logStartParseSourceFile(filename: string): void;
        logStopParseSourceFile(): void;
        logStartReadFile(filename: string): void;
        logStopReadFile(): void;
        logStartBindFile(filename: string): void;
        logStopBindFile(): void;
        logStartScheduledOperation(operationId: string): void;
        logStopScheduledOperation(): void;
    }
    /**
     * Performance logger that will generate ETW events if possible - check for `logEvent` member, as `etwModule` will be `{}` when browserified
     *
     * @internal
     */
    const perfLogger: PerfLogger;
    /** @internal */
    let tracing: typeof tracingEnabled | undefined;
    /**
     * Do not use this directly; instead @see {tracing}.
     * @internal
     */
    namespace tracingEnabled {
        type Mode = "project" | "build" | "server";
        interface Args {
            [key: string]: string | number | boolean | null | undefined | Args | readonly (string | number | boolean | null | undefined | Args)[];
        }
        /** Starts tracing for the given project. */
        export function startTracing(tracingMode: Mode, traceDir: string, configFilePath?: string): void;
        /** Stops tracing for the in-progress project and dumps the type catalog. */
        export function stopTracing(): void;
        export function recordType(type: Type): void;
        export const enum Phase {
            Parse = "parse",
            Program = "program",
            Bind = "bind",
            Check = "check",
            CheckTypes = "checkTypes",
            Emit = "emit",
            Session = "session"
        }
        export function instant(phase: Phase, name: string, args?: Args): void;
        /**
         * @param separateBeginAndEnd - used for special cases where we need the trace point even if the event
         * never terminates (typically for reducing a scenario too big to trace to one that can be completed).
         * In the future we might implement an exit handler to dump unfinished events which would deprecate
         * these operations.
         */
        export function push(phase: Phase, name: string, args?: Args, separateBeginAndEnd?: boolean): void;
        export function pop(results?: Args): void;
        export function popAll(): void;
        export function dumpLegend(): void;
        export {};
    }
    /** @internal */
    const startTracing: typeof tracingEnabled.startTracing;
    /** @internal */
    const dumpTracingLegend: typeof tracingEnabled.dumpLegend;
    /** @internal */
    interface TracingNode {
        tracingPath?: Path;
    }
    /** @internal */
    function diagnosticCategoryName(d: {
        category: DiagnosticCategory;
    }, lowerCase?: boolean): string;
    type Path = string & {
        __pathBrand: any;
    };
    /** @internal */
    type MatchingKeys<TRecord, TMatch, K extends keyof TRecord = keyof TRecord> = K extends (TRecord[K] extends TMatch ? K : never) ? K : never;
    interface TextRange {
        pos: number;
        end: number;
    }
    interface ReadonlyTextRange {
        readonly pos: number;
        readonly end: number;
    }
    enum SyntaxKind {
        Unknown = 0,
        EndOfFileToken = 1,
        SingleLineCommentTrivia = 2,
        MultiLineCommentTrivia = 3,
        NewLineTrivia = 4,
        WhitespaceTrivia = 5,
        ShebangTrivia = 6,
        ConflictMarkerTrivia = 7,
        NumericLiteral = 8,
        BigIntLiteral = 9,
        StringLiteral = 10,
        JsxText = 11,
        JsxTextAllWhiteSpaces = 12,
        RegularExpressionLiteral = 13,
        NoSubstitutionTemplateLiteral = 14,
        TemplateHead = 15,
        TemplateMiddle = 16,
        TemplateTail = 17,
        OpenBraceToken = 18,
        CloseBraceToken = 19,
        OpenParenToken = 20,
        CloseParenToken = 21,
        OpenBracketToken = 22,
        CloseBracketToken = 23,
        DotToken = 24,
        DotDotDotToken = 25,
        SemicolonToken = 26,
        CommaToken = 27,
        QuestionDotToken = 28,
        LessThanToken = 29,
        LessThanSlashToken = 30,
        GreaterThanToken = 31,
        LessThanEqualsToken = 32,
        GreaterThanEqualsToken = 33,
        EqualsEqualsToken = 34,
        ExclamationEqualsToken = 35,
        EqualsEqualsEqualsToken = 36,
        ExclamationEqualsEqualsToken = 37,
        EqualsGreaterThanToken = 38,
        PlusToken = 39,
        MinusToken = 40,
        AsteriskToken = 41,
        AsteriskAsteriskToken = 42,
        SlashToken = 43,
        PercentToken = 44,
        PlusPlusToken = 45,
        MinusMinusToken = 46,
        LessThanLessThanToken = 47,
        GreaterThanGreaterThanToken = 48,
        GreaterThanGreaterThanGreaterThanToken = 49,
        AmpersandToken = 50,
        BarToken = 51,
        CaretToken = 52,
        ExclamationToken = 53,
        TildeToken = 54,
        AmpersandAmpersandToken = 55,
        BarBarToken = 56,
        QuestionToken = 57,
        ColonToken = 58,
        AtToken = 59,
        QuestionQuestionToken = 60,
        /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
        BacktickToken = 61,
        /** Only the JSDoc scanner produces HashToken. The normal scanner produces PrivateIdentifier. */
        HashToken = 62,
        EqualsToken = 63,
        PlusEqualsToken = 64,
        MinusEqualsToken = 65,
        AsteriskEqualsToken = 66,
        AsteriskAsteriskEqualsToken = 67,
        SlashEqualsToken = 68,
        PercentEqualsToken = 69,
        LessThanLessThanEqualsToken = 70,
        GreaterThanGreaterThanEqualsToken = 71,
        GreaterThanGreaterThanGreaterThanEqualsToken = 72,
        AmpersandEqualsToken = 73,
        BarEqualsToken = 74,
        BarBarEqualsToken = 75,
        AmpersandAmpersandEqualsToken = 76,
        QuestionQuestionEqualsToken = 77,
        CaretEqualsToken = 78,
        Identifier = 79,
        PrivateIdentifier = 80,
        BreakKeyword = 81,
        CaseKeyword = 82,
        CatchKeyword = 83,
        ClassKeyword = 84,
        ConstKeyword = 85,
        ContinueKeyword = 86,
        DebuggerKeyword = 87,
        DefaultKeyword = 88,
        DeleteKeyword = 89,
        DoKeyword = 90,
        ElseKeyword = 91,
        EnumKeyword = 92,
        ExportKeyword = 93,
        ExtendsKeyword = 94,
        FalseKeyword = 95,
        FinallyKeyword = 96,
        ForKeyword = 97,
        FunctionKeyword = 98,
        IfKeyword = 99,
        ImportKeyword = 100,
        InKeyword = 101,
        InstanceOfKeyword = 102,
        NewKeyword = 103,
        NullKeyword = 104,
        ReturnKeyword = 105,
        SuperKeyword = 106,
        SwitchKeyword = 107,
        ThisKeyword = 108,
        ThrowKeyword = 109,
        TrueKeyword = 110,
        TryKeyword = 111,
        TypeOfKeyword = 112,
        VarKeyword = 113,
        VoidKeyword = 114,
        WhileKeyword = 115,
        WithKeyword = 116,
        ImplementsKeyword = 117,
        InterfaceKeyword = 118,
        LetKeyword = 119,
        PackageKeyword = 120,
        PrivateKeyword = 121,
        ProtectedKeyword = 122,
        PublicKeyword = 123,
        StaticKeyword = 124,
        YieldKeyword = 125,
        AbstractKeyword = 126,
        AccessorKeyword = 127,
        AsKeyword = 128,
        AssertsKeyword = 129,
        AssertKeyword = 130,
        AnyKeyword = 131,
        AsyncKeyword = 132,
        AwaitKeyword = 133,
        BooleanKeyword = 134,
        ConstructorKeyword = 135,
        DeclareKeyword = 136,
        GetKeyword = 137,
        InferKeyword = 138,
        IntrinsicKeyword = 139,
        IsKeyword = 140,
        KeyOfKeyword = 141,
        ModuleKeyword = 142,
        NamespaceKeyword = 143,
        NeverKeyword = 144,
        OutKeyword = 145,
        ReadonlyKeyword = 146,
        RequireKeyword = 147,
        NumberKeyword = 148,
        ObjectKeyword = 149,
        SatisfiesKeyword = 150,
        SetKeyword = 151,
        StringKeyword = 152,
        SymbolKeyword = 153,
        TypeKeyword = 154,
        UndefinedKeyword = 155,
        UniqueKeyword = 156,
        UnknownKeyword = 157,
        FromKeyword = 158,
        GlobalKeyword = 159,
        BigIntKeyword = 160,
        OverrideKeyword = 161,
        OfKeyword = 162,
        QualifiedName = 163,
        ComputedPropertyName = 164,
        TypeParameter = 165,
        Parameter = 166,
        Decorator = 167,
        PropertySignature = 168,
        PropertyDeclaration = 169,
        MethodSignature = 170,
        MethodDeclaration = 171,
        ClassStaticBlockDeclaration = 172,
        Constructor = 173,
        GetAccessor = 174,
        SetAccessor = 175,
        CallSignature = 176,
        ConstructSignature = 177,
        IndexSignature = 178,
        TypePredicate = 179,
        TypeReference = 180,
        FunctionType = 181,
        ConstructorType = 182,
        TypeQuery = 183,
        TypeLiteral = 184,
        ArrayType = 185,
        TupleType = 186,
        OptionalType = 187,
        RestType = 188,
        UnionType = 189,
        IntersectionType = 190,
        ConditionalType = 191,
        InferType = 192,
        ParenthesizedType = 193,
        ThisType = 194,
        TypeOperator = 195,
        IndexedAccessType = 196,
        MappedType = 197,
        LiteralType = 198,
        NamedTupleMember = 199,
        TemplateLiteralType = 200,
        TemplateLiteralTypeSpan = 201,
        ImportType = 202,
        ObjectBindingPattern = 203,
        ArrayBindingPattern = 204,
        BindingElement = 205,
        ArrayLiteralExpression = 206,
        ObjectLiteralExpression = 207,
        PropertyAccessExpression = 208,
        ElementAccessExpression = 209,
        CallExpression = 210,
        NewExpression = 211,
        TaggedTemplateExpression = 212,
        TypeAssertionExpression = 213,
        ParenthesizedExpression = 214,
        FunctionExpression = 215,
        ArrowFunction = 216,
        DeleteExpression = 217,
        TypeOfExpression = 218,
        VoidExpression = 219,
        AwaitExpression = 220,
        PrefixUnaryExpression = 221,
        PostfixUnaryExpression = 222,
        BinaryExpression = 223,
        ConditionalExpression = 224,
        TemplateExpression = 225,
        YieldExpression = 226,
        SpreadElement = 227,
        ClassExpression = 228,
        OmittedExpression = 229,
        ExpressionWithTypeArguments = 230,
        AsExpression = 231,
        NonNullExpression = 232,
        MetaProperty = 233,
        SyntheticExpression = 234,
        SatisfiesExpression = 235,
        TemplateSpan = 236,
        SemicolonClassElement = 237,
        Block = 238,
        EmptyStatement = 239,
        VariableStatement = 240,
        ExpressionStatement = 241,
        IfStatement = 242,
        DoStatement = 243,
        WhileStatement = 244,
        ForStatement = 245,
        ForInStatement = 246,
        ForOfStatement = 247,
        ContinueStatement = 248,
        BreakStatement = 249,
        ReturnStatement = 250,
        WithStatement = 251,
        SwitchStatement = 252,
        LabeledStatement = 253,
        ThrowStatement = 254,
        TryStatement = 255,
        DebuggerStatement = 256,
        VariableDeclaration = 257,
        VariableDeclarationList = 258,
        FunctionDeclaration = 259,
        ClassDeclaration = 260,
        InterfaceDeclaration = 261,
        TypeAliasDeclaration = 262,
        EnumDeclaration = 263,
        ModuleDeclaration = 264,
        ModuleBlock = 265,
        CaseBlock = 266,
        NamespaceExportDeclaration = 267,
        ImportEqualsDeclaration = 268,
        ImportDeclaration = 269,
        ImportClause = 270,
        NamespaceImport = 271,
        NamedImports = 272,
        ImportSpecifier = 273,
        ExportAssignment = 274,
        ExportDeclaration = 275,
        NamedExports = 276,
        NamespaceExport = 277,
        ExportSpecifier = 278,
        MissingDeclaration = 279,
        ExternalModuleReference = 280,
        JsxElement = 281,
        JsxSelfClosingElement = 282,
        JsxOpeningElement = 283,
        JsxClosingElement = 284,
        JsxFragment = 285,
        JsxOpeningFragment = 286,
        JsxClosingFragment = 287,
        JsxAttribute = 288,
        JsxAttributes = 289,
        JsxSpreadAttribute = 290,
        JsxExpression = 291,
        CaseClause = 292,
        DefaultClause = 293,
        HeritageClause = 294,
        CatchClause = 295,
        AssertClause = 296,
        AssertEntry = 297,
        ImportTypeAssertionContainer = 298,
        PropertyAssignment = 299,
        ShorthandPropertyAssignment = 300,
        SpreadAssignment = 301,
        EnumMember = 302,
        /** @deprecated */ UnparsedPrologue = 303,
        /** @deprecated */ UnparsedPrepend = 304,
        /** @deprecated */ UnparsedText = 305,
        /** @deprecated */ UnparsedInternalText = 306,
        /** @deprecated */ UnparsedSyntheticReference = 307,
        SourceFile = 308,
        Bundle = 309,
        /** @deprecated */ UnparsedSource = 310,
        /** @deprecated */ InputFiles = 311,
        JSDocTypeExpression = 312,
        JSDocNameReference = 313,
        JSDocMemberName = 314,
        JSDocAllType = 315,
        JSDocUnknownType = 316,
        JSDocNullableType = 317,
        JSDocNonNullableType = 318,
        JSDocOptionalType = 319,
        JSDocFunctionType = 320,
        JSDocVariadicType = 321,
        JSDocNamepathType = 322,
        JSDoc = 323,
        /** @deprecated Use SyntaxKind.JSDoc */
        JSDocComment = 323,
        JSDocText = 324,
        JSDocTypeLiteral = 325,
        JSDocSignature = 326,
        JSDocLink = 327,
        JSDocLinkCode = 328,
        JSDocLinkPlain = 329,
        JSDocTag = 330,
        JSDocAugmentsTag = 331,
        JSDocImplementsTag = 332,
        JSDocAuthorTag = 333,
        JSDocDeprecatedTag = 334,
        JSDocClassTag = 335,
        JSDocPublicTag = 336,
        JSDocPrivateTag = 337,
        JSDocProtectedTag = 338,
        JSDocReadonlyTag = 339,
        JSDocOverrideTag = 340,
        JSDocCallbackTag = 341,
        JSDocOverloadTag = 342,
        JSDocEnumTag = 343,
        JSDocParameterTag = 344,
        JSDocReturnTag = 345,
        JSDocThisTag = 346,
        JSDocTypeTag = 347,
        JSDocTemplateTag = 348,
        JSDocTypedefTag = 349,
        JSDocSeeTag = 350,
        JSDocPropertyTag = 351,
        JSDocThrowsTag = 352,
        JSDocSatisfiesTag = 353,
        SyntaxList = 354,
        NotEmittedStatement = 355,
        PartiallyEmittedExpression = 356,
        CommaListExpression = 357,
        MergeDeclarationMarker = 358,
        EndOfDeclarationMarker = 359,
        SyntheticReferenceExpression = 360,
        Count = 361,
        FirstAssignment = 63,
        LastAssignment = 78,
        FirstCompoundAssignment = 64,
        LastCompoundAssignment = 78,
        FirstReservedWord = 81,
        LastReservedWord = 116,
        FirstKeyword = 81,
        LastKeyword = 162,
        FirstFutureReservedWord = 117,
        LastFutureReservedWord = 125,
        FirstTypeNode = 179,
        LastTypeNode = 202,
        FirstPunctuation = 18,
        LastPunctuation = 78,
        FirstToken = 0,
        LastToken = 162,
        FirstTriviaToken = 2,
        LastTriviaToken = 7,
        FirstLiteralToken = 8,
        LastLiteralToken = 14,
        FirstTemplateToken = 14,
        LastTemplateToken = 17,
        FirstBinaryOperator = 29,
        LastBinaryOperator = 78,
        FirstStatement = 240,
        LastStatement = 256,
        FirstNode = 163,
        FirstJSDocNode = 312,
        LastJSDocNode = 353,
        FirstJSDocTagNode = 330,
        LastJSDocTagNode = 353,
        /** @internal */ FirstContextualKeyword = 126,
        /** @internal */ LastContextualKeyword = 162
    }
    type TriviaSyntaxKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia | SyntaxKind.NewLineTrivia | SyntaxKind.WhitespaceTrivia | SyntaxKind.ShebangTrivia | SyntaxKind.ConflictMarkerTrivia;
    type LiteralSyntaxKind = SyntaxKind.NumericLiteral | SyntaxKind.BigIntLiteral | SyntaxKind.StringLiteral | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.RegularExpressionLiteral | SyntaxKind.NoSubstitutionTemplateLiteral;
    type PseudoLiteralSyntaxKind = SyntaxKind.TemplateHead | SyntaxKind.TemplateMiddle | SyntaxKind.TemplateTail;
    type PunctuationSyntaxKind = SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.OpenParenToken | SyntaxKind.CloseParenToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.DotToken | SyntaxKind.DotDotDotToken | SyntaxKind.SemicolonToken | SyntaxKind.CommaToken | SyntaxKind.QuestionDotToken | SyntaxKind.LessThanToken | SyntaxKind.LessThanSlashToken | SyntaxKind.GreaterThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.EqualsEqualsToken | SyntaxKind.ExclamationEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.EqualsGreaterThanToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.AsteriskToken | SyntaxKind.AsteriskAsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken | SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken | SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken | SyntaxKind.ExclamationToken | SyntaxKind.TildeToken | SyntaxKind.AmpersandAmpersandToken | SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.BarBarToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.QuestionQuestionToken | SyntaxKind.QuestionQuestionEqualsToken | SyntaxKind.QuestionToken | SyntaxKind.ColonToken | SyntaxKind.AtToken | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.EqualsToken | SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken;
    type KeywordSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AccessorKeyword | SyntaxKind.AnyKeyword | SyntaxKind.AsKeyword | SyntaxKind.AssertsKeyword | SyntaxKind.AssertKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.AwaitKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.BreakKeyword | SyntaxKind.CaseKeyword | SyntaxKind.CatchKeyword | SyntaxKind.ClassKeyword | SyntaxKind.ConstKeyword | SyntaxKind.ConstructorKeyword | SyntaxKind.ContinueKeyword | SyntaxKind.DebuggerKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.DeleteKeyword | SyntaxKind.DoKeyword | SyntaxKind.ElseKeyword | SyntaxKind.EnumKeyword | SyntaxKind.ExportKeyword | SyntaxKind.ExtendsKeyword | SyntaxKind.FalseKeyword | SyntaxKind.FinallyKeyword | SyntaxKind.ForKeyword | SyntaxKind.FromKeyword | SyntaxKind.FunctionKeyword | SyntaxKind.GetKeyword | SyntaxKind.GlobalKeyword | SyntaxKind.IfKeyword | SyntaxKind.ImplementsKeyword | SyntaxKind.ImportKeyword | SyntaxKind.InferKeyword | SyntaxKind.InKeyword | SyntaxKind.InstanceOfKeyword | SyntaxKind.InterfaceKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.IsKeyword | SyntaxKind.KeyOfKeyword | SyntaxKind.LetKeyword | SyntaxKind.ModuleKeyword | SyntaxKind.NamespaceKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NewKeyword | SyntaxKind.NullKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.OfKeyword | SyntaxKind.PackageKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OutKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.RequireKeyword | SyntaxKind.ReturnKeyword | SyntaxKind.SatisfiesKeyword | SyntaxKind.SetKeyword | SyntaxKind.StaticKeyword | SyntaxKind.StringKeyword | SyntaxKind.SuperKeyword | SyntaxKind.SwitchKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.ThisKeyword | SyntaxKind.ThrowKeyword | SyntaxKind.TrueKeyword | SyntaxKind.TryKeyword | SyntaxKind.TypeKeyword | SyntaxKind.TypeOfKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VarKeyword | SyntaxKind.VoidKeyword | SyntaxKind.WhileKeyword | SyntaxKind.WithKeyword | SyntaxKind.YieldKeyword;
    type ModifierSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AccessorKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.ConstKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.ExportKeyword | SyntaxKind.InKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OutKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.StaticKeyword;
    type KeywordTypeSyntaxKind = SyntaxKind.AnyKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.StringKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VoidKeyword;
    /** @internal */
    type TypeNodeSyntaxKind = KeywordTypeSyntaxKind | SyntaxKind.TypePredicate | SyntaxKind.TypeReference | SyntaxKind.FunctionType | SyntaxKind.ConstructorType | SyntaxKind.TypeQuery | SyntaxKind.TypeLiteral | SyntaxKind.ArrayType | SyntaxKind.TupleType | SyntaxKind.NamedTupleMember | SyntaxKind.OptionalType | SyntaxKind.RestType | SyntaxKind.UnionType | SyntaxKind.IntersectionType | SyntaxKind.ConditionalType | SyntaxKind.InferType | SyntaxKind.ParenthesizedType | SyntaxKind.ThisType | SyntaxKind.TypeOperator | SyntaxKind.IndexedAccessType | SyntaxKind.MappedType | SyntaxKind.LiteralType | SyntaxKind.TemplateLiteralType | SyntaxKind.TemplateLiteralTypeSpan | SyntaxKind.ImportType | SyntaxKind.ExpressionWithTypeArguments | SyntaxKind.JSDocTypeExpression | SyntaxKind.JSDocAllType | SyntaxKind.JSDocUnknownType | SyntaxKind.JSDocNonNullableType | SyntaxKind.JSDocNullableType | SyntaxKind.JSDocOptionalType | SyntaxKind.JSDocFunctionType | SyntaxKind.JSDocVariadicType | SyntaxKind.JSDocNamepathType | SyntaxKind.JSDocSignature | SyntaxKind.JSDocTypeLiteral;
    type TokenSyntaxKind = SyntaxKind.Unknown | SyntaxKind.EndOfFileToken | TriviaSyntaxKind | LiteralSyntaxKind | PseudoLiteralSyntaxKind | PunctuationSyntaxKind | SyntaxKind.Identifier | KeywordSyntaxKind;
    type JsxTokenSyntaxKind = SyntaxKind.LessThanSlashToken | SyntaxKind.EndOfFileToken | SyntaxKind.ConflictMarkerTrivia | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.OpenBraceToken | SyntaxKind.LessThanToken;
    type JSDocSyntaxKind = SyntaxKind.EndOfFileToken | SyntaxKind.WhitespaceTrivia | SyntaxKind.AtToken | SyntaxKind.NewLineTrivia | SyntaxKind.AsteriskToken | SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.LessThanToken | SyntaxKind.GreaterThanToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.EqualsToken | SyntaxKind.CommaToken | SyntaxKind.DotToken | SyntaxKind.Identifier | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.Unknown | KeywordSyntaxKind;
    enum NodeFlags {
        None = 0,
        Let = 1,
        Const = 2,
        NestedNamespace = 4,
        Synthesized = 8,
        Namespace = 16,
        OptionalChain = 32,
        ExportContext = 64,
        ContainsThis = 128,
        HasImplicitReturn = 256,
        HasExplicitReturn = 512,
        GlobalAugmentation = 1024,
        HasAsyncFunctions = 2048,
        DisallowInContext = 4096,
        YieldContext = 8192,
        DecoratorContext = 16384,
        AwaitContext = 32768,
        DisallowConditionalTypesContext = 65536,
        ThisNodeHasError = 131072,
        JavaScriptFile = 262144,
        ThisNodeOrAnySubNodesHasError = 524288,
        HasAggregatedChildData = 1048576,
        /** @internal */ PossiblyContainsDynamicImport = 2097152,
        /** @internal */ PossiblyContainsImportMeta = 4194304,
        JSDoc = 8388608,
        /** @internal */ Ambient = 16777216,
        /** @internal */ InWithStatement = 33554432,
        JsonFile = 67108864,
        /** @internal */ TypeCached = 134217728,
        /** @internal */ Deprecated = 268435456,
        BlockScoped = 3,
        ReachabilityCheckFlags = 768,
        ReachabilityAndEmitFlags = 2816,
        ContextFlags = 50720768,
        TypeExcludesFlags = 40960,
        /** @internal */ PermanentlySetIncrementalFlags = 6291456,
        /** @internal */ IdentifierHasExtendedUnicodeEscape = 128,
        /** @internal */ IdentifierIsInJSDocNamespace = 2048
    }
    enum ModifierFlags {
        None = 0,
        Export = 1,
        Ambient = 2,
        Public = 4,
        Private = 8,
        Protected = 16,
        Static = 32,
        Readonly = 64,
        Accessor = 128,
        Abstract = 256,
        Async = 512,
        Default = 1024,
        Const = 2048,
        HasComputedJSDocModifiers = 4096,
        Deprecated = 8192,
        Override = 16384,
        In = 32768,
        Out = 65536,
        Decorator = 131072,
        HasComputedFlags = 536870912,
        AccessibilityModifier = 28,
        ParameterPropertyModifier = 16476,
        NonPublicAccessibilityModifier = 24,
        TypeScriptModifier = 117086,
        ExportDefault = 1025,
        All = 258047,
        Modifier = 126975
    }
    enum JsxFlags {
        None = 0,
        /** An element from a named property of the JSX.IntrinsicElements interface */
        IntrinsicNamedElement = 1,
        /** An element inferred from the string index signature of the JSX.IntrinsicElements interface */
        IntrinsicIndexedElement = 2,
        IntrinsicElement = 3
    }
    /** @internal */
    enum RelationComparisonResult {
        Succeeded = 1,
        Failed = 2,
        Reported = 4,
        ReportsUnmeasurable = 8,
        ReportsUnreliable = 16,
        ReportsMask = 24
    }
    /** @internal */
    type NodeId = number;
    interface Node extends ReadonlyTextRange {
        readonly kind: SyntaxKind;
        readonly flags: NodeFlags;
        /** @internal */ modifierFlagsCache: ModifierFlags;
        /** @internal */ readonly transformFlags: TransformFlags;
        /** @internal */ id?: NodeId;
        readonly parent: Node;
        /** @internal */ original?: Node;
        /** @internal */ emitNode?: EmitNode;
    }
    interface Node {
        getSourceFile(): SourceFile;
        getChildCount(sourceFile?: SourceFile): number;
        getChildAt(index: number, sourceFile?: SourceFile): Node;
        getChildren(sourceFile?: SourceFile): Node[];
        /** @internal */
        getChildren(sourceFile?: SourceFileLike): Node[];
        getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;
        /** @internal */
        getStart(sourceFile?: SourceFileLike, includeJsDocComment?: boolean): number;
        getFullStart(): number;
        getEnd(): number;
        getWidth(sourceFile?: SourceFileLike): number;
        getFullWidth(): number;
        getLeadingTriviaWidth(sourceFile?: SourceFile): number;
        getFullText(sourceFile?: SourceFile): string;
        getText(sourceFile?: SourceFile): string;
        getFirstToken(sourceFile?: SourceFile): Node | undefined;
        /** @internal */
        getFirstToken(sourceFile?: SourceFileLike): Node | undefined;
        getLastToken(sourceFile?: SourceFile): Node | undefined;
        /** @internal */
        getLastToken(sourceFile?: SourceFileLike): Node | undefined;
        forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
    }
    interface JSDocContainer extends Node {
        _jsdocContainerBrand: any;
        /** @internal */ jsDoc?: JSDocArray;
    }
    /** @internal */
    interface JSDocArray extends Array<JSDoc> {
        jsDocCache?: readonly JSDocTag[];
    }
    interface LocalsContainer extends Node {
        _localsContainerBrand: any;
        /** @internal */ locals?: SymbolTable;
        /** @internal */ nextContainer?: HasLocals;
    }
    interface FlowContainer extends Node {
        _flowContainerBrand: any;
        /** @internal */ flowNode?: FlowNode;
    }
    /** @internal */
    type HasFlowNode = Identifier | ThisExpression | SuperExpression | QualifiedName | MetaProperty | ElementAccessExpression | PropertyAccessExpression | BindingElement | FunctionExpression | ArrowFunction | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | VariableStatement | ExpressionStatement | IfStatement | DoStatement | WhileStatement | ForStatement | ForInStatement | ForOfStatement | ContinueStatement | BreakStatement | ReturnStatement | WithStatement | SwitchStatement | LabeledStatement | ThrowStatement | TryStatement | DebuggerStatement;
    /** @internal */
    type ForEachChildNodes = HasChildren | MissingDeclaration | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType | JSDocFunctionType | JSDoc | JSDocSeeTag | JSDocNameReference | JSDocMemberName | JSDocParameterTag | JSDocPropertyTag | JSDocAuthorTag | JSDocImplementsTag | JSDocAugmentsTag | JSDocTemplateTag | JSDocTypedefTag | JSDocCallbackTag | JSDocReturnTag | JSDocTypeTag | JSDocThisTag | JSDocEnumTag | JSDocSignature | JSDocLink | JSDocLinkCode | JSDocLinkPlain | JSDocTypeLiteral | JSDocUnknownTag | JSDocClassTag | JSDocPublicTag | JSDocPrivateTag | JSDocProtectedTag | JSDocReadonlyTag | JSDocDeprecatedTag | JSDocThrowsTag | JSDocOverrideTag | JSDocSatisfiesTag | JSDocOverloadTag;
    /** @internal */
    type HasChildren = QualifiedName | ComputedPropertyName | TypeParameterDeclaration | ParameterDeclaration | Decorator | PropertySignature | PropertyDeclaration | MethodSignature | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassStaticBlockDeclaration | CallSignatureDeclaration | ConstructSignatureDeclaration | IndexSignatureDeclaration | TypePredicateNode | TypeReferenceNode | FunctionTypeNode | ConstructorTypeNode | TypeQueryNode | TypeLiteralNode | ArrayTypeNode | TupleTypeNode | OptionalTypeNode | RestTypeNode | UnionTypeNode | IntersectionTypeNode | ConditionalTypeNode | InferTypeNode | ImportTypeNode | ImportTypeAssertionContainer | NamedTupleMember | ParenthesizedTypeNode | TypeOperatorNode | IndexedAccessTypeNode | MappedTypeNode | LiteralTypeNode | TemplateLiteralTypeNode | TemplateLiteralTypeSpan | ObjectBindingPattern | ArrayBindingPattern | BindingElement | ArrayLiteralExpression | ObjectLiteralExpression | PropertyAccessExpression | ElementAccessExpression | CallExpression | NewExpression | TaggedTemplateExpression | TypeAssertion | ParenthesizedExpression | FunctionExpression | ArrowFunction | DeleteExpression | TypeOfExpression | VoidExpression | AwaitExpression | PrefixUnaryExpression | PostfixUnaryExpression | BinaryExpression | ConditionalExpression | TemplateExpression | YieldExpression | SpreadElement | ClassExpression | ExpressionWithTypeArguments | AsExpression | NonNullExpression | SatisfiesExpression | MetaProperty | TemplateSpan | Block | VariableStatement | ExpressionStatement | IfStatement | DoStatement | WhileStatement | ForStatement | ForInStatement | ForOfStatement | ContinueStatement | BreakStatement | ReturnStatement | WithStatement | SwitchStatement | LabeledStatement | ThrowStatement | TryStatement | VariableDeclaration | VariableDeclarationList | FunctionDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ModuleDeclaration | ModuleBlock | CaseBlock | NamespaceExportDeclaration | ImportEqualsDeclaration | ImportDeclaration | AssertClause | AssertEntry | ImportClause | NamespaceImport | NamespaceExport | NamedImports | ImportSpecifier | ExportAssignment | ExportDeclaration | NamedExports | ExportSpecifier | ExternalModuleReference | JsxElement | JsxSelfClosingElement | JsxOpeningElement | JsxClosingElement | JsxFragment | JsxAttribute | JsxAttributes | JsxSpreadAttribute | JsxExpression | CaseClause | DefaultClause | HeritageClause | CatchClause | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | EnumMember | SourceFile | PartiallyEmittedExpression | CommaListExpression;
    type HasJSDoc = AccessorDeclaration | ArrowFunction | BinaryExpression | Block | BreakStatement | CallSignatureDeclaration | CaseClause | ClassLikeDeclaration | ClassStaticBlockDeclaration | ConstructorDeclaration | ConstructorTypeNode | ConstructSignatureDeclaration | ContinueStatement | DebuggerStatement | DoStatement | ElementAccessExpression | EmptyStatement | EndOfFileToken | EnumDeclaration | EnumMember | ExportAssignment | ExportDeclaration | ExportSpecifier | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | FunctionTypeNode | Identifier | IfStatement | ImportDeclaration | ImportEqualsDeclaration | IndexSignatureDeclaration | InterfaceDeclaration | JSDocFunctionType | JSDocSignature | LabeledStatement | MethodDeclaration | MethodSignature | ModuleDeclaration | NamedTupleMember | NamespaceExportDeclaration | ObjectLiteralExpression | ParameterDeclaration | ParenthesizedExpression | PropertyAccessExpression | PropertyAssignment | PropertyDeclaration | PropertySignature | ReturnStatement | ShorthandPropertyAssignment | SpreadAssignment | SwitchStatement | ThrowStatement | TryStatement | TypeAliasDeclaration | TypeParameterDeclaration | VariableDeclaration | VariableStatement | WhileStatement | WithStatement;
    type HasType = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertySignature | PropertyDeclaration | TypePredicateNode | ParenthesizedTypeNode | TypeOperatorNode | MappedTypeNode | AssertionExpression | TypeAliasDeclaration | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType;
    /** @internal */
    type HasIllegalType = ConstructorDeclaration | SetAccessorDeclaration;
    /** @internal */
    type HasIllegalTypeParameters = ConstructorDeclaration | SetAccessorDeclaration | GetAccessorDeclaration;
    type HasTypeArguments = CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement | JsxSelfClosingElement;
    type HasInitializer = HasExpressionInitializer | ForStatement | ForInStatement | ForOfStatement | JsxAttribute;
    type HasExpressionInitializer = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | EnumMember;
    /** @internal */
    type HasIllegalExpressionInitializer = PropertySignature;
    type HasDecorators = ParameterDeclaration | PropertyDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassExpression | ClassDeclaration;
    /** @internal */
    type HasIllegalDecorators = PropertyAssignment | ShorthandPropertyAssignment | FunctionDeclaration | ConstructorDeclaration | IndexSignatureDeclaration | ClassStaticBlockDeclaration | MissingDeclaration | VariableStatement | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | NamespaceExportDeclaration | ExportDeclaration | ExportAssignment;
    type HasModifiers = TypeParameterDeclaration | ParameterDeclaration | ConstructorTypeNode | PropertySignature | PropertyDeclaration | MethodSignature | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | IndexSignatureDeclaration | FunctionExpression | ArrowFunction | ClassExpression | VariableStatement | FunctionDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | ExportAssignment | ExportDeclaration;
    /** @internal */
    type HasIllegalModifiers = ClassStaticBlockDeclaration | PropertyAssignment | ShorthandPropertyAssignment | MissingDeclaration | NamespaceExportDeclaration;
    /**
     * Declarations that can contain other declarations. Corresponds with `ContainerFlags.IsContainer` in binder.ts.
     *
     * @internal
     */
    type IsContainer = ClassExpression | ClassDeclaration | EnumDeclaration | ObjectLiteralExpression | TypeLiteralNode | JSDocTypeLiteral | JsxAttributes | InterfaceDeclaration | ModuleDeclaration | TypeAliasDeclaration | MappedTypeNode | IndexSignatureDeclaration | SourceFile | GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | ConstructorDeclaration | FunctionDeclaration | MethodSignature | CallSignatureDeclaration | JSDocSignature | JSDocFunctionType | FunctionTypeNode | ConstructSignatureDeclaration | ConstructorTypeNode | ClassStaticBlockDeclaration | FunctionExpression | ArrowFunction;
    /**
     * Nodes that introduce a new block scope. Corresponds with `ContainerFlags.IsBlockScopedContainer` in binder.ts.
     *
     * @internal
     */
    type IsBlockScopedContainer = IsContainer | CatchClause | ForStatement | ForInStatement | ForOfStatement | CaseBlock | Block;
    /**
     * Corresponds with `ContainerFlags.IsControlFlowContainer` in binder.ts.
     *
     * @internal
     */
    type IsControlFlowContainer = SourceFile | GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | ConstructorDeclaration | FunctionDeclaration | MethodSignature | CallSignatureDeclaration | JSDocSignature | JSDocFunctionType | FunctionTypeNode | ConstructSignatureDeclaration | ConstructorTypeNode | ClassStaticBlockDeclaration | FunctionExpression | ArrowFunction | ModuleBlock | PropertyDeclaration;
    /**
     * Corresponds with `ContainerFlags.IsFunctionLike` in binder.ts.
     *
     * @internal
     */
    type IsFunctionLike = GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | ConstructorDeclaration | FunctionDeclaration | MethodSignature | CallSignatureDeclaration | JSDocSignature | JSDocFunctionType | FunctionTypeNode | ConstructSignatureDeclaration | ConstructorTypeNode | ClassStaticBlockDeclaration | FunctionExpression | ArrowFunction;
    /**
     * Corresponds with `ContainerFlags.IsFunctionExpression` in binder.ts.
     *
     * @internal
     */
    type IsFunctionExpression = FunctionExpression | ArrowFunction;
    /**
     * Nodes that can have local symbols. Corresponds with `ContainerFlags.HasLocals`. Constituents should extend
     * {@link LocalsContainer}.
     *
     * @internal
     */
    type HasLocals = ArrowFunction | Block | CallSignatureDeclaration | CaseBlock | CatchClause | ClassStaticBlockDeclaration | ConditionalTypeNode | ConstructorDeclaration | ConstructorTypeNode | ConstructSignatureDeclaration | ForStatement | ForInStatement | ForOfStatement | FunctionDeclaration | FunctionExpression | FunctionTypeNode | GetAccessorDeclaration | IndexSignatureDeclaration | JSDocCallbackTag | JSDocEnumTag | JSDocFunctionType | JSDocSignature | JSDocTypedefTag | MappedTypeNode | MethodDeclaration | MethodSignature | ModuleDeclaration | SetAccessorDeclaration | SourceFile | TypeAliasDeclaration;
    /**
     * Corresponds with `ContainerFlags.IsInterface` in binder.ts.
     *
     * @internal
     */
    type IsInterface = InterfaceDeclaration;
    /**
     * Corresponds with `ContainerFlags.IsObjectLiteralOrClassExpressionMethodOrAccessor` in binder.ts.
     *
     * @internal
     */
    type IsObjectLiteralOrClassExpressionMethodOrAccessor = GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration;
    /**
     * Corresponds with `ContainerFlags` in binder.ts.
     *
     * @internal
     */
    type HasContainerFlags = IsContainer | IsBlockScopedContainer | IsControlFlowContainer | IsFunctionLike | IsFunctionExpression | HasLocals | IsInterface | IsObjectLiteralOrClassExpressionMethodOrAccessor;
    /** @internal */
    interface MutableNodeArray<T extends Node> extends Array<T>, TextRange {
        hasTrailingComma: boolean;
        /** @internal */ transformFlags: TransformFlags;
    }
    interface NodeArray<T extends Node> extends ReadonlyArray<T>, ReadonlyTextRange {
        readonly hasTrailingComma: boolean;
        /** @internal */ transformFlags: TransformFlags;
    }
    interface Token<TKind extends SyntaxKind> extends Node {
        readonly kind: TKind;
    }
    type EndOfFileToken = Token<SyntaxKind.EndOfFileToken> & JSDocContainer;
    interface PunctuationToken<TKind extends PunctuationSyntaxKind> extends Token<TKind> {
    }
    type DotToken = PunctuationToken<SyntaxKind.DotToken>;
    type DotDotDotToken = PunctuationToken<SyntaxKind.DotDotDotToken>;
    type QuestionToken = PunctuationToken<SyntaxKind.QuestionToken>;
    type ExclamationToken = PunctuationToken<SyntaxKind.ExclamationToken>;
    type ColonToken = PunctuationToken<SyntaxKind.ColonToken>;
    type EqualsToken = PunctuationToken<SyntaxKind.EqualsToken>;
    type AmpersandAmpersandEqualsToken = PunctuationToken<SyntaxKind.AmpersandAmpersandEqualsToken>;
    type BarBarEqualsToken = PunctuationToken<SyntaxKind.BarBarEqualsToken>;
    type QuestionQuestionEqualsToken = PunctuationToken<SyntaxKind.QuestionQuestionEqualsToken>;
    type AsteriskToken = PunctuationToken<SyntaxKind.AsteriskToken>;
    type EqualsGreaterThanToken = PunctuationToken<SyntaxKind.EqualsGreaterThanToken>;
    type PlusToken = PunctuationToken<SyntaxKind.PlusToken>;
    type MinusToken = PunctuationToken<SyntaxKind.MinusToken>;
    type QuestionDotToken = PunctuationToken<SyntaxKind.QuestionDotToken>;
    interface KeywordToken<TKind extends KeywordSyntaxKind> extends Token<TKind> {
    }
    type AssertsKeyword = KeywordToken<SyntaxKind.AssertsKeyword>;
    type AssertKeyword = KeywordToken<SyntaxKind.AssertKeyword>;
    type AwaitKeyword = KeywordToken<SyntaxKind.AwaitKeyword>;
    type CaseKeyword = KeywordToken<SyntaxKind.CaseKeyword>;
    interface ModifierToken<TKind extends ModifierSyntaxKind> extends KeywordToken<TKind> {
    }
    type AbstractKeyword = ModifierToken<SyntaxKind.AbstractKeyword>;
    type AccessorKeyword = ModifierToken<SyntaxKind.AccessorKeyword>;
    type AsyncKeyword = ModifierToken<SyntaxKind.AsyncKeyword>;
    type ConstKeyword = ModifierToken<SyntaxKind.ConstKeyword>;
    type DeclareKeyword = ModifierToken<SyntaxKind.DeclareKeyword>;
    type DefaultKeyword = ModifierToken<SyntaxKind.DefaultKeyword>;
    type ExportKeyword = ModifierToken<SyntaxKind.ExportKeyword>;
    type InKeyword = ModifierToken<SyntaxKind.InKeyword>;
    type PrivateKeyword = ModifierToken<SyntaxKind.PrivateKeyword>;
    type ProtectedKeyword = ModifierToken<SyntaxKind.ProtectedKeyword>;
    type PublicKeyword = ModifierToken<SyntaxKind.PublicKeyword>;
    type ReadonlyKeyword = ModifierToken<SyntaxKind.ReadonlyKeyword>;
    type OutKeyword = ModifierToken<SyntaxKind.OutKeyword>;
    type OverrideKeyword = ModifierToken<SyntaxKind.OverrideKeyword>;
    type StaticKeyword = ModifierToken<SyntaxKind.StaticKeyword>;
    type Modifier = AbstractKeyword | AccessorKeyword | AsyncKeyword | ConstKeyword | DeclareKeyword | DefaultKeyword | ExportKeyword | InKeyword | PrivateKeyword | ProtectedKeyword | PublicKeyword | OutKeyword | OverrideKeyword | ReadonlyKeyword | StaticKeyword;
    type ModifierLike = Modifier | Decorator;
    type AccessibilityModifier = PublicKeyword | PrivateKeyword | ProtectedKeyword;
    type ParameterPropertyModifier = AccessibilityModifier | ReadonlyKeyword;
    type ClassMemberModifier = AccessibilityModifier | ReadonlyKeyword | StaticKeyword | AccessorKeyword;
    type ModifiersArray = NodeArray<Modifier>;
    enum GeneratedIdentifierFlags {
        None = 0,
        /** @internal */ Auto = 1,
        /** @internal */ Loop = 2,
        /** @internal */ Unique = 3,
        /** @internal */ Node = 4,
        /** @internal */ KindMask = 7,
        ReservedInNestedScopes = 8,
        Optimistic = 16,
        FileLevel = 32,
        AllowNameSubstitution = 64
    }
    interface Identifier extends PrimaryExpression, Declaration, JSDocContainer, FlowContainer {
        readonly kind: SyntaxKind.Identifier;
        /**
         * Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)
         * Text of identifier, but if the identifier begins with two underscores, this will begin with three.
         */
        readonly escapedText: __String;
    }
    interface Identifier {
        readonly text: string;
    }
    interface Identifier {
        /** @deprecated Use `idKeyword(identifier)` instead. */
        readonly originalKeywordKind?: SyntaxKind;
        /** @deprecated Use `.parent` or the surrounding context to determine this instead. */
        readonly isInJSDocNamespace?: boolean;
    }
    interface TransientIdentifier extends Identifier {
        resolvedSymbol: Symbol;
    }
    /** @internal */
    interface AutoGenerateInfo {
        flags: GeneratedIdentifierFlags;
        readonly id: number;
        readonly prefix?: string | GeneratedNamePart;
        readonly suffix?: string;
    }
    /** @internal */
    interface GeneratedIdentifier extends Identifier {
        readonly emitNode: EmitNode & {
            autoGenerate: AutoGenerateInfo;
        };
    }
    interface QualifiedName extends Node, FlowContainer {
        readonly kind: SyntaxKind.QualifiedName;
        readonly left: EntityName;
        readonly right: Identifier;
    }
    type EntityName = Identifier | QualifiedName;
    type PropertyName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName | PrivateIdentifier;
    type MemberName = Identifier | PrivateIdentifier;
    type DeclarationName = Identifier | PrivateIdentifier | StringLiteralLike | NumericLiteral | ComputedPropertyName | ElementAccessExpression | BindingPattern | EntityNameExpression;
    interface Declaration extends Node {
        _declarationBrand: any;
        /** @internal */ symbol: Symbol;
        /** @internal */ localSymbol?: Symbol;
    }
    interface NamedDeclaration extends Declaration {
        readonly name?: DeclarationName;
    }
    /** @internal */
    interface DynamicNamedDeclaration extends NamedDeclaration {
        readonly name: ComputedPropertyName;
    }
    /** @internal */
    interface DynamicNamedBinaryExpression extends BinaryExpression {
        readonly left: ElementAccessExpression;
    }
    /** @internal */
    interface LateBoundDeclaration extends DynamicNamedDeclaration {
        readonly name: LateBoundName;
    }
    /** @internal */
    interface LateBoundBinaryExpressionDeclaration extends DynamicNamedBinaryExpression {
        readonly left: LateBoundElementAccessExpression;
    }
    /** @internal */
    interface LateBoundElementAccessExpression extends ElementAccessExpression {
        readonly argumentExpression: EntityNameExpression;
    }
    interface DeclarationStatement extends NamedDeclaration, Statement {
        readonly name?: Identifier | StringLiteral | NumericLiteral;
    }
    interface ComputedPropertyName extends Node {
        readonly kind: SyntaxKind.ComputedPropertyName;
        readonly parent: Declaration;
        readonly expression: Expression;
    }
    interface PrivateIdentifier extends PrimaryExpression {
        readonly kind: SyntaxKind.PrivateIdentifier;
        readonly escapedText: __String;
    }
    interface PrivateIdentifier {
        readonly text: string;
    }
    /** @internal */
    interface GeneratedPrivateIdentifier extends PrivateIdentifier {
        readonly emitNode: EmitNode & {
            autoGenerate: AutoGenerateInfo;
        };
    }
    /** @internal */
    interface LateBoundName extends ComputedPropertyName {
        readonly expression: EntityNameExpression;
    }
    interface Decorator extends Node {
        readonly kind: SyntaxKind.Decorator;
        readonly parent: NamedDeclaration;
        readonly expression: LeftHandSideExpression;
    }
    interface TypeParameterDeclaration extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.TypeParameter;
        readonly parent: DeclarationWithTypeParameterChildren | InferTypeNode;
        readonly modifiers?: NodeArray<Modifier>;
        readonly name: Identifier;
        /** Note: Consider calling `getEffectiveConstraintOfTypeParameter` */
        readonly constraint?: TypeNode;
        readonly default?: TypeNode;
        expression?: Expression;
    }
    interface SignatureDeclarationBase extends NamedDeclaration, JSDocContainer {
        readonly kind: SignatureDeclaration["kind"];
        readonly name?: PropertyName;
        readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined;
        readonly parameters: NodeArray<ParameterDeclaration>;
        readonly type?: TypeNode | undefined;
        /** @internal */ typeArguments?: NodeArray<TypeNode>;
    }
    type SignatureDeclaration = CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction;
    interface CallSignatureDeclaration extends SignatureDeclarationBase, TypeElement, LocalsContainer {
        readonly kind: SyntaxKind.CallSignature;
    }
    interface ConstructSignatureDeclaration extends SignatureDeclarationBase, TypeElement, LocalsContainer {
        readonly kind: SyntaxKind.ConstructSignature;
    }
    type BindingName = Identifier | BindingPattern;
    interface VariableDeclaration extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.VariableDeclaration;
        readonly parent: VariableDeclarationList | CatchClause;
        readonly name: BindingName;
        readonly exclamationToken?: ExclamationToken;
        readonly type?: TypeNode;
        readonly initializer?: Expression;
        callerList?: string[];
        delayInitializerList?: Expression[];
    }
    /** @internal */
    type InitializedVariableDeclaration = VariableDeclaration & {
        readonly initializer: Expression;
    };
    interface VariableDeclarationList extends Node {
        readonly kind: SyntaxKind.VariableDeclarationList;
        readonly parent: VariableStatement | ForStatement | ForOfStatement | ForInStatement;
        readonly declarations: NodeArray<VariableDeclaration>;
    }
    interface ParameterDeclaration extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.Parameter;
        readonly parent: SignatureDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly dotDotDotToken?: DotDotDotToken;
        readonly name: BindingName;
        readonly questionToken?: QuestionToken;
        readonly type?: TypeNode;
        readonly initializer?: Expression;
    }
    interface BindingElement extends NamedDeclaration, FlowContainer {
        readonly kind: SyntaxKind.BindingElement;
        readonly parent: BindingPattern;
        readonly propertyName?: PropertyName;
        readonly dotDotDotToken?: DotDotDotToken;
        readonly name: BindingName;
        readonly initializer?: Expression;
    }
    /** @internal */
    type BindingElementGrandparent = BindingElement["parent"]["parent"];
    interface PropertySignature extends TypeElement, JSDocContainer {
        readonly kind: SyntaxKind.PropertySignature;
        readonly parent: TypeLiteralNode | InterfaceDeclaration;
        readonly modifiers?: NodeArray<Modifier>;
        readonly name: PropertyName;
        readonly questionToken?: QuestionToken;
        readonly type?: TypeNode;
        /** @internal */ readonly initializer?: Expression | undefined;
    }
    interface PropertyDeclaration extends ClassElement, JSDocContainer {
        readonly kind: SyntaxKind.PropertyDeclaration;
        readonly parent: ClassLikeDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: PropertyName;
        readonly questionToken?: QuestionToken;
        readonly exclamationToken?: ExclamationToken;
        readonly type?: TypeNode;
        readonly initializer?: Expression;
    }
    interface AutoAccessorPropertyDeclaration extends PropertyDeclaration {
        _autoAccessorBrand: any;
    }
    /** @internal */
    interface PrivateIdentifierPropertyDeclaration extends PropertyDeclaration {
        name: PrivateIdentifier;
    }
    /** @internal */
    interface PrivateIdentifierAutoAccessorPropertyDeclaration extends AutoAccessorPropertyDeclaration {
        name: PrivateIdentifier;
    }
    /** @internal */
    interface PrivateIdentifierMethodDeclaration extends MethodDeclaration {
        name: PrivateIdentifier;
    }
    /** @internal */
    interface PrivateIdentifierGetAccessorDeclaration extends GetAccessorDeclaration {
        name: PrivateIdentifier;
    }
    /** @internal */
    interface PrivateIdentifierSetAccessorDeclaration extends SetAccessorDeclaration {
        name: PrivateIdentifier;
    }
    /** @internal */
    type PrivateIdentifierAccessorDeclaration = PrivateIdentifierGetAccessorDeclaration | PrivateIdentifierSetAccessorDeclaration;
    /** @internal */
    type PrivateClassElementDeclaration = PrivateIdentifierPropertyDeclaration | PrivateIdentifierAutoAccessorPropertyDeclaration | PrivateIdentifierMethodDeclaration | PrivateIdentifierGetAccessorDeclaration | PrivateIdentifierSetAccessorDeclaration;
    /** @internal */
    type InitializedPropertyDeclaration = PropertyDeclaration & {
        readonly initializer: Expression;
    };
    interface ObjectLiteralElement extends NamedDeclaration {
        _objectLiteralBrand: any;
        readonly name?: PropertyName;
    }
    /** Unlike ObjectLiteralElement, excludes JSXAttribute and JSXSpreadAttribute. */
    type ObjectLiteralElementLike = PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | AccessorDeclaration;
    interface PropertyAssignment extends ObjectLiteralElement, JSDocContainer {
        readonly kind: SyntaxKind.PropertyAssignment;
        readonly parent: ObjectLiteralExpression;
        readonly name: PropertyName;
        readonly initializer: Expression;
        /** @internal */ readonly modifiers?: NodeArray<ModifierLike> | undefined;
        /** @internal */ readonly questionToken?: QuestionToken | undefined;
        /** @internal */ readonly exclamationToken?: ExclamationToken | undefined;
    }
    interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {
        readonly kind: SyntaxKind.ShorthandPropertyAssignment;
        readonly parent: ObjectLiteralExpression;
        readonly name: Identifier;
        readonly equalsToken?: EqualsToken;
        readonly objectAssignmentInitializer?: Expression;
        /** @internal */ readonly modifiers?: NodeArray<ModifierLike> | undefined;
        /** @internal */ readonly questionToken?: QuestionToken | undefined;
        /** @internal */ readonly exclamationToken?: ExclamationToken | undefined;
    }
    interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {
        readonly kind: SyntaxKind.SpreadAssignment;
        readonly parent: ObjectLiteralExpression;
        readonly expression: Expression;
    }
    type VariableLikeDeclaration = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | PropertySignature | JsxAttribute | ShorthandPropertyAssignment | EnumMember | JSDocPropertyTag | JSDocParameterTag;
    interface ObjectBindingPattern extends Node {
        readonly kind: SyntaxKind.ObjectBindingPattern;
        readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;
        readonly elements: NodeArray<BindingElement>;
    }
    interface ArrayBindingPattern extends Node {
        readonly kind: SyntaxKind.ArrayBindingPattern;
        readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;
        readonly elements: NodeArray<ArrayBindingElement>;
    }
    type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;
    type ArrayBindingElement = BindingElement | OmittedExpression;
    /**
     * Several node kinds share function-like features such as a signature,
     * a name, and a body. These nodes should extend FunctionLikeDeclarationBase.
     * Examples:
     * - FunctionDeclaration
     * - MethodDeclaration
     * - AccessorDeclaration
     */
    interface FunctionLikeDeclarationBase extends SignatureDeclarationBase {
        _functionLikeDeclarationBrand: any;
        readonly asteriskToken?: AsteriskToken | undefined;
        readonly questionToken?: QuestionToken | undefined;
        readonly exclamationToken?: ExclamationToken | undefined;
        readonly body?: Block | Expression | undefined;
        /** @internal */ endFlowNode?: FlowNode;
        /** @internal */ returnFlowNode?: FlowNode;
    }
    type FunctionLikeDeclaration = FunctionDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration | FunctionExpression | ArrowFunction;
    /** @deprecated Use SignatureDeclaration */
    type FunctionLike = SignatureDeclaration;
    interface FunctionDeclaration extends FunctionLikeDeclarationBase, DeclarationStatement, LocalsContainer {
        readonly kind: SyntaxKind.FunctionDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name?: Identifier;
        readonly body?: FunctionBody;
    }
    interface MethodSignature extends SignatureDeclarationBase, TypeElement, LocalsContainer {
        readonly kind: SyntaxKind.MethodSignature;
        readonly parent: TypeLiteralNode | InterfaceDeclaration;
        readonly modifiers?: NodeArray<Modifier>;
        readonly name: PropertyName;
    }
    interface MethodDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.MethodDeclaration;
        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression;
        readonly modifiers?: NodeArray<ModifierLike> | undefined;
        readonly name: PropertyName;
        readonly body?: FunctionBody | undefined;
        /** @internal */ readonly exclamationToken?: ExclamationToken | undefined;
    }
    interface ConstructorDeclaration extends FunctionLikeDeclarationBase, ClassElement, JSDocContainer, LocalsContainer {
        readonly kind: SyntaxKind.Constructor;
        readonly parent: ClassLikeDeclaration;
        readonly modifiers?: NodeArray<ModifierLike> | undefined;
        readonly body?: FunctionBody | undefined;
        /** @internal */ readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
        /** @internal */ readonly type?: TypeNode;
    }
    /** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */
    interface SemicolonClassElement extends ClassElement {
        readonly kind: SyntaxKind.SemicolonClassElement;
        readonly parent: ClassLikeDeclaration;
    }
    interface GetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.GetAccessor;
        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: PropertyName;
        readonly body?: FunctionBody;
        /** @internal */ readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined;
    }
    interface SetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.SetAccessor;
        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: PropertyName;
        readonly body?: FunctionBody;
        /** @internal */ readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined;
        /** @internal */ readonly type?: TypeNode | undefined;
    }
    type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;
    interface IndexSignatureDeclaration extends SignatureDeclarationBase, ClassElement, TypeElement, LocalsContainer {
        readonly kind: SyntaxKind.IndexSignature;
        readonly parent: ObjectTypeDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly type: TypeNode;
    }
    interface ClassStaticBlockDeclaration extends ClassElement, JSDocContainer, LocalsContainer {
        readonly kind: SyntaxKind.ClassStaticBlockDeclaration;
        readonly parent: ClassDeclaration | ClassExpression;
        readonly body: Block;
        /** @internal */ endFlowNode?: FlowNode;
        /** @internal */ returnFlowNode?: FlowNode;
        /** @internal */ readonly modifiers?: NodeArray<ModifierLike> | undefined;
    }
    interface TypeNode extends Node {
        _typeNodeBrand: any;
    }
    /** @internal */
    interface TypeNode extends Node {
        readonly kind: TypeNodeSyntaxKind;
    }
    interface KeywordTypeNode<TKind extends KeywordTypeSyntaxKind = KeywordTypeSyntaxKind> extends KeywordToken<TKind>, TypeNode {
        readonly kind: TKind;
    }
    interface ImportTypeAssertionContainer extends Node {
        readonly kind: SyntaxKind.ImportTypeAssertionContainer;
        readonly parent: ImportTypeNode;
        readonly assertClause: AssertClause;
        readonly multiLine?: boolean;
    }
    interface ImportTypeNode extends NodeWithTypeArguments {
        readonly kind: SyntaxKind.ImportType;
        readonly isTypeOf: boolean;
        readonly argument: TypeNode;
        readonly assertions?: ImportTypeAssertionContainer;
        readonly qualifier?: EntityName;
    }
    /** @internal */
    type LiteralImportTypeNode = ImportTypeNode & {
        readonly argument: LiteralTypeNode & {
            readonly literal: StringLiteral;
        };
    };
    interface ThisTypeNode extends TypeNode {
        readonly kind: SyntaxKind.ThisType;
    }
    type FunctionOrConstructorTypeNode = FunctionTypeNode | ConstructorTypeNode;
    interface FunctionOrConstructorTypeNodeBase extends TypeNode, SignatureDeclarationBase {
        readonly kind: SyntaxKind.FunctionType | SyntaxKind.ConstructorType;
        readonly type: TypeNode;
    }
    interface FunctionTypeNode extends FunctionOrConstructorTypeNodeBase, LocalsContainer {
        readonly kind: SyntaxKind.FunctionType;
        /** @internal */ readonly modifiers?: undefined;
    }
    interface ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase, LocalsContainer {
        readonly kind: SyntaxKind.ConstructorType;
        readonly modifiers?: NodeArray<Modifier>;
    }
    interface NodeWithTypeArguments extends TypeNode {
        readonly typeArguments?: NodeArray<TypeNode>;
    }
    type TypeReferenceType = TypeReferenceNode | ExpressionWithTypeArguments;
    interface TypeReferenceNode extends NodeWithTypeArguments {
        readonly kind: SyntaxKind.TypeReference;
        readonly typeName: EntityName;
    }
    interface TypePredicateNode extends TypeNode {
        readonly kind: SyntaxKind.TypePredicate;
        readonly parent: SignatureDeclaration | JSDocTypeExpression;
        readonly assertsModifier?: AssertsKeyword;
        readonly parameterName: Identifier | ThisTypeNode;
        readonly type?: TypeNode;
    }
    interface TypeQueryNode extends NodeWithTypeArguments {
        readonly kind: SyntaxKind.TypeQuery;
        readonly exprName: EntityName;
    }
    interface TypeLiteralNode extends TypeNode, Declaration {
        readonly kind: SyntaxKind.TypeLiteral;
        readonly members: NodeArray<TypeElement>;
    }
    interface ArrayTypeNode extends TypeNode {
        readonly kind: SyntaxKind.ArrayType;
        readonly elementType: TypeNode;
    }
    interface TupleTypeNode extends TypeNode {
        readonly kind: SyntaxKind.TupleType;
        readonly elements: NodeArray<TypeNode | NamedTupleMember>;
    }
    interface NamedTupleMember extends TypeNode, Declaration, JSDocContainer {
        readonly kind: SyntaxKind.NamedTupleMember;
        readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;
        readonly name: Identifier;
        readonly questionToken?: Token<SyntaxKind.QuestionToken>;
        readonly type: TypeNode;
    }
    interface OptionalTypeNode extends TypeNode {
        readonly kind: SyntaxKind.OptionalType;
        readonly type: TypeNode;
    }
    interface RestTypeNode extends TypeNode {
        readonly kind: SyntaxKind.RestType;
        readonly type: TypeNode;
    }
    type UnionOrIntersectionTypeNode = UnionTypeNode | IntersectionTypeNode;
    interface UnionTypeNode extends TypeNode {
        readonly kind: SyntaxKind.UnionType;
        readonly types: NodeArray<TypeNode>;
    }
    interface IntersectionTypeNode extends TypeNode {
        readonly kind: SyntaxKind.IntersectionType;
        readonly types: NodeArray<TypeNode>;
    }
    interface ConditionalTypeNode extends TypeNode, LocalsContainer {
        readonly kind: SyntaxKind.ConditionalType;
        readonly checkType: TypeNode;
        readonly extendsType: TypeNode;
        readonly trueType: TypeNode;
        readonly falseType: TypeNode;
    }
    interface InferTypeNode extends TypeNode {
        readonly kind: SyntaxKind.InferType;
        readonly typeParameter: TypeParameterDeclaration;
    }
    interface ParenthesizedTypeNode extends TypeNode {
        readonly kind: SyntaxKind.ParenthesizedType;
        readonly type: TypeNode;
    }
    interface TypeOperatorNode extends TypeNode {
        readonly kind: SyntaxKind.TypeOperator;
        readonly operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword;
        readonly type: TypeNode;
    }
    /** @internal */
    interface UniqueTypeOperatorNode extends TypeOperatorNode {
        readonly operator: SyntaxKind.UniqueKeyword;
    }
    interface IndexedAccessTypeNode extends TypeNode {
        readonly kind: SyntaxKind.IndexedAccessType;
        readonly objectType: TypeNode;
        readonly indexType: TypeNode;
    }
    interface MappedTypeNode extends TypeNode, Declaration, LocalsContainer {
        readonly kind: SyntaxKind.MappedType;
        readonly readonlyToken?: ReadonlyKeyword | PlusToken | MinusToken;
        readonly typeParameter: TypeParameterDeclaration;
        readonly nameType?: TypeNode;
        readonly questionToken?: QuestionToken | PlusToken | MinusToken;
        readonly type?: TypeNode;
        /** Used only to produce grammar errors */
        readonly members?: NodeArray<TypeElement>;
    }
    interface LiteralTypeNode extends TypeNode {
        readonly kind: SyntaxKind.LiteralType;
        readonly literal: NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;
    }
    interface StringLiteral extends LiteralExpression, Declaration {
        readonly kind: SyntaxKind.StringLiteral;
        /** @internal */ readonly textSourceNode?: Identifier | StringLiteralLike | NumericLiteral | PrivateIdentifier;
        /**
         * Note: this is only set when synthesizing a node, not during parsing.
         *
         * @internal
         */
        readonly singleQuote?: boolean;
    }
    type StringLiteralLike = StringLiteral | NoSubstitutionTemplateLiteral;
    type PropertyNameLiteral = Identifier | StringLiteralLike | NumericLiteral;
    interface TemplateLiteralTypeNode extends TypeNode {
        kind: SyntaxKind.TemplateLiteralType;
        readonly head: TemplateHead;
        readonly templateSpans: NodeArray<TemplateLiteralTypeSpan>;
    }
    interface TemplateLiteralTypeSpan extends TypeNode {
        readonly kind: SyntaxKind.TemplateLiteralTypeSpan;
        readonly parent: TemplateLiteralTypeNode;
        readonly type: TypeNode;
        readonly literal: TemplateMiddle | TemplateTail;
    }
    interface Expression extends Node {
        _expressionBrand: any;
    }
    interface OmittedExpression extends Expression {
        readonly kind: SyntaxKind.OmittedExpression;
    }
    interface PartiallyEmittedExpression extends LeftHandSideExpression {
        readonly kind: SyntaxKind.PartiallyEmittedExpression;
        readonly expression: Expression;
    }
    interface UnaryExpression extends Expression {
        _unaryExpressionBrand: any;
    }
    /** Deprecated, please use UpdateExpression */
    type IncrementExpression = UpdateExpression;
    interface UpdateExpression extends UnaryExpression {
        _updateExpressionBrand: any;
    }
    type PrefixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.TildeToken | SyntaxKind.ExclamationToken;
    interface PrefixUnaryExpression extends UpdateExpression {
        readonly kind: SyntaxKind.PrefixUnaryExpression;
        readonly operator: PrefixUnaryOperator;
        readonly operand: UnaryExpression;
    }
    type PostfixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken;
    interface PostfixUnaryExpression extends UpdateExpression {
        readonly kind: SyntaxKind.PostfixUnaryExpression;
        readonly operand: LeftHandSideExpression;
        readonly operator: PostfixUnaryOperator;
    }
    interface LeftHandSideExpression extends UpdateExpression {
        _leftHandSideExpressionBrand: any;
    }
    interface MemberExpression extends LeftHandSideExpression {
        _memberExpressionBrand: any;
    }
    interface PrimaryExpression extends MemberExpression {
        _primaryExpressionBrand: any;
    }
    interface NullLiteral extends PrimaryExpression {
        readonly kind: SyntaxKind.NullKeyword;
    }
    interface TrueLiteral extends PrimaryExpression {
        readonly kind: SyntaxKind.TrueKeyword;
    }
    interface FalseLiteral extends PrimaryExpression {
        readonly kind: SyntaxKind.FalseKeyword;
    }
    type BooleanLiteral = TrueLiteral | FalseLiteral;
    interface ThisExpression extends PrimaryExpression, FlowContainer {
        readonly kind: SyntaxKind.ThisKeyword;
    }
    interface SuperExpression extends PrimaryExpression, FlowContainer {
        readonly kind: SyntaxKind.SuperKeyword;
    }
    interface ImportExpression extends PrimaryExpression {
        readonly kind: SyntaxKind.ImportKeyword;
    }
    interface DeleteExpression extends UnaryExpression {
        readonly kind: SyntaxKind.DeleteExpression;
        readonly expression: UnaryExpression;
    }
    interface TypeOfExpression extends UnaryExpression {
        readonly kind: SyntaxKind.TypeOfExpression;
        readonly expression: UnaryExpression;
    }
    interface VoidExpression extends UnaryExpression {
        readonly kind: SyntaxKind.VoidExpression;
        readonly expression: UnaryExpression;
    }
    interface AwaitExpression extends UnaryExpression {
        readonly kind: SyntaxKind.AwaitExpression;
        readonly expression: UnaryExpression;
    }
    interface YieldExpression extends Expression {
        readonly kind: SyntaxKind.YieldExpression;
        readonly asteriskToken?: AsteriskToken;
        readonly expression?: Expression;
    }
    interface SyntheticExpression extends Expression {
        readonly kind: SyntaxKind.SyntheticExpression;
        readonly isSpread: boolean;
        readonly type: Type;
        readonly tupleNameSource?: ParameterDeclaration | NamedTupleMember;
    }
    type ExponentiationOperator = SyntaxKind.AsteriskAsteriskToken;
    type MultiplicativeOperator = SyntaxKind.AsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken;
    type MultiplicativeOperatorOrHigher = ExponentiationOperator | MultiplicativeOperator;
    type AdditiveOperator = SyntaxKind.PlusToken | SyntaxKind.MinusToken;
    type AdditiveOperatorOrHigher = MultiplicativeOperatorOrHigher | AdditiveOperator;
    type ShiftOperator = SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken;
    type ShiftOperatorOrHigher = AdditiveOperatorOrHigher | ShiftOperator;
    type RelationalOperator = SyntaxKind.LessThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.InstanceOfKeyword | SyntaxKind.InKeyword;
    type RelationalOperatorOrHigher = ShiftOperatorOrHigher | RelationalOperator;
    type EqualityOperator = SyntaxKind.EqualsEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.ExclamationEqualsToken;
    type EqualityOperatorOrHigher = RelationalOperatorOrHigher | EqualityOperator;
    type BitwiseOperator = SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken;
    type BitwiseOperatorOrHigher = EqualityOperatorOrHigher | BitwiseOperator;
    type LogicalOperator = SyntaxKind.AmpersandAmpersandToken | SyntaxKind.BarBarToken;
    type LogicalOperatorOrHigher = BitwiseOperatorOrHigher | LogicalOperator;
    type CompoundAssignmentOperator = SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;
    type AssignmentOperator = SyntaxKind.EqualsToken | CompoundAssignmentOperator;
    type AssignmentOperatorOrHigher = SyntaxKind.QuestionQuestionToken | LogicalOperatorOrHigher | AssignmentOperator;
    type BinaryOperator = AssignmentOperatorOrHigher | SyntaxKind.CommaToken;
    type LogicalOrCoalescingAssignmentOperator = SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;
    type BinaryOperatorToken = Token<BinaryOperator>;
    interface BinaryExpression extends Expression, Declaration, JSDocContainer {
        readonly kind: SyntaxKind.BinaryExpression;
        readonly left: Expression;
        readonly operatorToken: BinaryOperatorToken;
        readonly right: Expression;
    }
    type AssignmentOperatorToken = Token<AssignmentOperator>;
    interface AssignmentExpression<TOperator extends AssignmentOperatorToken> extends BinaryExpression {
        readonly left: LeftHandSideExpression;
        readonly operatorToken: TOperator;
    }
    interface ObjectDestructuringAssignment extends AssignmentExpression<EqualsToken> {
        readonly left: ObjectLiteralExpression;
    }
    interface ArrayDestructuringAssignment extends AssignmentExpression<EqualsToken> {
        readonly left: ArrayLiteralExpression;
    }
    type DestructuringAssignment = ObjectDestructuringAssignment | ArrayDestructuringAssignment;
    type BindingOrAssignmentElement = VariableDeclaration | ParameterDeclaration | ObjectBindingOrAssignmentElement | ArrayBindingOrAssignmentElement;
    type ObjectBindingOrAssignmentElement = BindingElement | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment;
    /** @internal */
    type ObjectAssignmentElement = Exclude<ObjectBindingOrAssignmentElement, BindingElement>;
    type ArrayBindingOrAssignmentElement = BindingElement | OmittedExpression | SpreadElement | ArrayLiteralExpression | ObjectLiteralExpression | AssignmentExpression<EqualsToken> | Identifier | PropertyAccessExpression | ElementAccessExpression;
    /** @internal */
    type ArrayAssignmentElement = Exclude<ArrayBindingOrAssignmentElement, BindingElement>;
    type BindingOrAssignmentElementRestIndicator = DotDotDotToken | SpreadElement | SpreadAssignment;
    type BindingOrAssignmentElementTarget = BindingOrAssignmentPattern | Identifier | PropertyAccessExpression | ElementAccessExpression | OmittedExpression;
    /** @internal */
    type AssignmentElementTarget = Exclude<BindingOrAssignmentElementTarget, BindingPattern>;
    type ObjectBindingOrAssignmentPattern = ObjectBindingPattern | ObjectLiteralExpression;
    type ArrayBindingOrAssignmentPattern = ArrayBindingPattern | ArrayLiteralExpression;
    type AssignmentPattern = ObjectLiteralExpression | ArrayLiteralExpression;
    type BindingOrAssignmentPattern = ObjectBindingOrAssignmentPattern | ArrayBindingOrAssignmentPattern;
    interface ConditionalExpression extends Expression {
        readonly kind: SyntaxKind.ConditionalExpression;
        readonly condition: Expression;
        readonly questionToken: QuestionToken;
        readonly whenTrue: Expression;
        readonly colonToken: ColonToken;
        readonly whenFalse: Expression;
    }
    type FunctionBody = Block;
    type ConciseBody = FunctionBody | Expression;
    interface FunctionExpression extends PrimaryExpression, FunctionLikeDeclarationBase, JSDocContainer, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.FunctionExpression;
        readonly modifiers?: NodeArray<Modifier>;
        readonly name?: Identifier;
        readonly body: FunctionBody;
    }
    interface ArrowFunction extends Expression, FunctionLikeDeclarationBase, JSDocContainer, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.ArrowFunction;
        readonly modifiers?: NodeArray<Modifier>;
        readonly equalsGreaterThanToken: EqualsGreaterThanToken;
        readonly body: ConciseBody;
        readonly name: never;
    }
    interface LiteralLikeNode extends Node {
        text: string;
        isUnterminated?: boolean;
        hasExtendedUnicodeEscape?: boolean;
    }
    interface TemplateLiteralLikeNode extends LiteralLikeNode {
        rawText?: string;
        /** @internal */
        templateFlags?: TokenFlags;
    }
    interface LiteralExpression extends LiteralLikeNode, PrimaryExpression {
        _literalExpressionBrand: any;
    }
    interface RegularExpressionLiteral extends LiteralExpression {
        readonly kind: SyntaxKind.RegularExpressionLiteral;
    }
    interface NoSubstitutionTemplateLiteral extends LiteralExpression, TemplateLiteralLikeNode, Declaration {
        readonly kind: SyntaxKind.NoSubstitutionTemplateLiteral;
        /** @internal */
        templateFlags?: TokenFlags;
    }
    enum TokenFlags {
        None = 0,
        /** @internal */
        PrecedingLineBreak = 1,
        /** @internal */
        PrecedingJSDocComment = 2,
        /** @internal */
        Unterminated = 4,
        /** @internal */
        ExtendedUnicodeEscape = 8,
        Scientific = 16,
        Octal = 32,
        HexSpecifier = 64,
        BinarySpecifier = 128,
        OctalSpecifier = 256,
        /** @internal */
        ContainsSeparator = 512,
        /** @internal */
        UnicodeEscape = 1024,
        /** @internal */
        ContainsInvalidEscape = 2048,
        /** @internal */
        BinaryOrOctalSpecifier = 384,
        /** @internal */
        NumericLiteralFlags = 1008,
        /** @internal */
        TemplateLiteralLikeFlags = 2048
    }
    interface NumericLiteral extends LiteralExpression, Declaration {
        readonly kind: SyntaxKind.NumericLiteral;
        /** @internal */
        readonly numericLiteralFlags: TokenFlags;
    }
    interface BigIntLiteral extends LiteralExpression {
        readonly kind: SyntaxKind.BigIntLiteral;
    }
    type LiteralToken = NumericLiteral | BigIntLiteral | StringLiteral | JsxText | RegularExpressionLiteral | NoSubstitutionTemplateLiteral;
    interface TemplateHead extends TemplateLiteralLikeNode {
        readonly kind: SyntaxKind.TemplateHead;
        readonly parent: TemplateExpression | TemplateLiteralTypeNode;
        /** @internal */
        templateFlags?: TokenFlags;
    }
    interface TemplateMiddle extends TemplateLiteralLikeNode {
        readonly kind: SyntaxKind.TemplateMiddle;
        readonly parent: TemplateSpan | TemplateLiteralTypeSpan;
        /** @internal */
        templateFlags?: TokenFlags;
    }
    interface TemplateTail extends TemplateLiteralLikeNode {
        readonly kind: SyntaxKind.TemplateTail;
        readonly parent: TemplateSpan | TemplateLiteralTypeSpan;
        /** @internal */
        templateFlags?: TokenFlags;
    }
    type PseudoLiteralToken = TemplateHead | TemplateMiddle | TemplateTail;
    type TemplateLiteralToken = NoSubstitutionTemplateLiteral | PseudoLiteralToken;
    interface TemplateExpression extends PrimaryExpression {
        readonly kind: SyntaxKind.TemplateExpression;
        readonly head: TemplateHead;
        readonly templateSpans: NodeArray<TemplateSpan>;
    }
    type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;
    interface TemplateSpan extends Node {
        readonly kind: SyntaxKind.TemplateSpan;
        readonly parent: TemplateExpression;
        readonly expression: Expression;
        readonly literal: TemplateMiddle | TemplateTail;
    }
    interface ParenthesizedExpression extends PrimaryExpression, JSDocContainer {
        readonly kind: SyntaxKind.ParenthesizedExpression;
        readonly expression: Expression;
    }
    /** @internal */
    interface JSDocTypeAssertion extends ParenthesizedExpression {
        readonly _jsDocTypeAssertionBrand: never;
    }
    interface ArrayLiteralExpression extends PrimaryExpression {
        readonly kind: SyntaxKind.ArrayLiteralExpression;
        readonly elements: NodeArray<Expression>;
        /** @internal */
        multiLine?: boolean;
    }
    interface SpreadElement extends Expression {
        readonly kind: SyntaxKind.SpreadElement;
        readonly parent: ArrayLiteralExpression | CallExpression | NewExpression;
        readonly expression: Expression;
    }
    /**
     * This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to
     * ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes' properties can only be
     * JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type
     * ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)
     */
    interface ObjectLiteralExpressionBase<T extends ObjectLiteralElement> extends PrimaryExpression, Declaration {
        readonly properties: NodeArray<T>;
    }
    interface ObjectLiteralExpression extends ObjectLiteralExpressionBase<ObjectLiteralElementLike>, JSDocContainer {
        readonly kind: SyntaxKind.ObjectLiteralExpression;
        /** @internal */
        multiLine?: boolean;
    }
    type EntityNameExpression = Identifier | PropertyAccessEntityNameExpression;
    type EntityNameOrEntityNameExpression = EntityName | EntityNameExpression;
    type AccessExpression = PropertyAccessExpression | ElementAccessExpression;
    interface PropertyAccessExpression extends MemberExpression, NamedDeclaration, JSDocContainer, FlowContainer {
        readonly kind: SyntaxKind.PropertyAccessExpression;
        readonly expression: LeftHandSideExpression;
        readonly questionDotToken?: QuestionDotToken;
        readonly name: MemberName;
    }
    /** @internal */
    interface PrivateIdentifierPropertyAccessExpression extends PropertyAccessExpression {
        readonly name: PrivateIdentifier;
    }
    interface PropertyAccessChain extends PropertyAccessExpression {
        _optionalChainBrand: any;
        readonly name: MemberName;
    }
    /** @internal */
    interface PropertyAccessChainRoot extends PropertyAccessChain {
        readonly questionDotToken: QuestionDotToken;
    }
    interface SuperPropertyAccessExpression extends PropertyAccessExpression {
        readonly expression: SuperExpression;
    }
    /** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */
    interface PropertyAccessEntityNameExpression extends PropertyAccessExpression {
        _propertyAccessExpressionLikeQualifiedNameBrand?: any;
        readonly expression: EntityNameExpression;
        readonly name: Identifier;
    }
    interface ElementAccessExpression extends MemberExpression, Declaration, JSDocContainer, FlowContainer {
        readonly kind: SyntaxKind.ElementAccessExpression;
        readonly expression: LeftHandSideExpression;
        readonly questionDotToken?: QuestionDotToken;
        readonly argumentExpression: Expression;
    }
    interface ElementAccessChain extends ElementAccessExpression {
        _optionalChainBrand: any;
    }
    /** @internal */
    interface ElementAccessChainRoot extends ElementAccessChain {
        readonly questionDotToken: QuestionDotToken;
    }
    interface SuperElementAccessExpression extends ElementAccessExpression {
        readonly expression: SuperExpression;
    }
    type SuperProperty = SuperPropertyAccessExpression | SuperElementAccessExpression;
    interface CallExpression extends LeftHandSideExpression, Declaration {
        readonly kind: SyntaxKind.CallExpression;
        readonly expression: LeftHandSideExpression;
        readonly questionDotToken?: QuestionDotToken;
        readonly typeArguments?: NodeArray<TypeNode>;
        readonly arguments: NodeArray<Expression>;
    }
    interface CallChain extends CallExpression {
        _optionalChainBrand: any;
    }
    /** @internal */
    interface CallChainRoot extends CallChain {
        readonly questionDotToken: QuestionDotToken;
    }
    type OptionalChain = PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
    /** @internal */
    type OptionalChainRoot = PropertyAccessChainRoot | ElementAccessChainRoot | CallChainRoot;
    /** @internal */
    type BindableObjectDefinePropertyCall = CallExpression & {
        readonly arguments: readonly [
            BindableStaticNameExpression,
            StringLiteralLike | NumericLiteral,
            ObjectLiteralExpression
        ] & Readonly<TextRange>;
    };
    /** @internal */
    type BindableStaticNameExpression = EntityNameExpression | BindableStaticElementAccessExpression;
    /** @internal */
    type LiteralLikeElementAccessExpression = ElementAccessExpression & Declaration & {
        readonly argumentExpression: StringLiteralLike | NumericLiteral;
    };
    /** @internal */
    type BindableStaticElementAccessExpression = LiteralLikeElementAccessExpression & {
        readonly expression: BindableStaticNameExpression;
    };
    /** @internal */
    type BindableElementAccessExpression = ElementAccessExpression & {
        readonly expression: BindableStaticNameExpression;
    };
    /** @internal */
    type BindableStaticAccessExpression = PropertyAccessEntityNameExpression | BindableStaticElementAccessExpression;
    /** @internal */
    type BindableAccessExpression = PropertyAccessEntityNameExpression | BindableElementAccessExpression;
    /** @internal */
    interface BindableStaticPropertyAssignmentExpression extends BinaryExpression {
        readonly left: BindableStaticAccessExpression;
    }
    /** @internal */
    interface BindablePropertyAssignmentExpression extends BinaryExpression {
        readonly left: BindableAccessExpression;
    }
    interface SuperCall extends CallExpression {
        readonly expression: SuperExpression;
    }
    interface ImportCall extends CallExpression {
        readonly expression: ImportExpression;
    }
    interface ExpressionWithTypeArguments extends MemberExpression, NodeWithTypeArguments {
        readonly kind: SyntaxKind.ExpressionWithTypeArguments;
        readonly expression: LeftHandSideExpression;
    }
    interface NewExpression extends PrimaryExpression, Declaration {
        readonly kind: SyntaxKind.NewExpression;
        readonly expression: LeftHandSideExpression;
        readonly typeArguments?: NodeArray<TypeNode>;
        readonly arguments?: NodeArray<Expression>;
    }
    interface TaggedTemplateExpression extends MemberExpression {
        readonly kind: SyntaxKind.TaggedTemplateExpression;
        readonly tag: LeftHandSideExpression;
        readonly typeArguments?: NodeArray<TypeNode>;
        readonly template: TemplateLiteral;
        /** @internal */ questionDotToken?: QuestionDotToken;
    }
    type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxOpeningLikeElement;
    interface AsExpression extends Expression {
        readonly kind: SyntaxKind.AsExpression;
        readonly expression: Expression;
        readonly type: TypeNode;
    }
    interface TypeAssertion extends UnaryExpression {
        readonly kind: SyntaxKind.TypeAssertionExpression;
        readonly type: TypeNode;
        readonly expression: UnaryExpression;
    }
    interface SatisfiesExpression extends Expression {
        readonly kind: SyntaxKind.SatisfiesExpression;
        readonly expression: Expression;
        readonly type: TypeNode;
    }
    type AssertionExpression = TypeAssertion | AsExpression;
    interface NonNullExpression extends LeftHandSideExpression {
        readonly kind: SyntaxKind.NonNullExpression;
        readonly expression: Expression;
    }
    interface NonNullChain extends NonNullExpression {
        _optionalChainBrand: any;
    }
    interface MetaProperty extends PrimaryExpression, FlowContainer {
        readonly kind: SyntaxKind.MetaProperty;
        readonly keywordToken: SyntaxKind.NewKeyword | SyntaxKind.ImportKeyword;
        readonly name: Identifier;
    }
    /** @internal */
    interface ImportMetaProperty extends MetaProperty {
        readonly keywordToken: SyntaxKind.ImportKeyword;
        readonly name: Identifier & {
            readonly escapedText: __String & "meta";
        };
    }
    interface JsxElement extends PrimaryExpression {
        readonly kind: SyntaxKind.JsxElement;
        readonly openingElement: JsxOpeningElement;
        readonly children: NodeArray<JsxChild>;
        readonly closingElement: JsxClosingElement;
    }
    type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;
    type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;
    type JsxTagNameExpression = Identifier | ThisExpression | JsxTagNamePropertyAccess;
    interface JsxTagNamePropertyAccess extends PropertyAccessExpression {
        readonly expression: JsxTagNameExpression;
    }
    interface JsxAttributes extends ObjectLiteralExpressionBase<JsxAttributeLike> {
        readonly kind: SyntaxKind.JsxAttributes;
        readonly parent: JsxOpeningLikeElement;
    }
    interface JsxOpeningElement extends Expression {
        readonly kind: SyntaxKind.JsxOpeningElement;
        readonly parent: JsxElement;
        readonly tagName: JsxTagNameExpression;
        readonly typeArguments?: NodeArray<TypeNode>;
        readonly attributes: JsxAttributes;
    }
    interface JsxSelfClosingElement extends PrimaryExpression {
        readonly kind: SyntaxKind.JsxSelfClosingElement;
        readonly tagName: JsxTagNameExpression;
        readonly typeArguments?: NodeArray<TypeNode>;
        readonly attributes: JsxAttributes;
    }
    interface JsxFragment extends PrimaryExpression {
        readonly kind: SyntaxKind.JsxFragment;
        readonly openingFragment: JsxOpeningFragment;
        readonly children: NodeArray<JsxChild>;
        readonly closingFragment: JsxClosingFragment;
    }
    interface JsxOpeningFragment extends Expression {
        readonly kind: SyntaxKind.JsxOpeningFragment;
        readonly parent: JsxFragment;
    }
    interface JsxClosingFragment extends Expression {
        readonly kind: SyntaxKind.JsxClosingFragment;
        readonly parent: JsxFragment;
    }
    interface JsxAttribute extends ObjectLiteralElement {
        readonly kind: SyntaxKind.JsxAttribute;
        readonly parent: JsxAttributes;
        readonly name: Identifier;
        readonly initializer?: JsxAttributeValue;
    }
    type JsxAttributeValue = StringLiteral | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;
    interface JsxSpreadAttribute extends ObjectLiteralElement {
        readonly kind: SyntaxKind.JsxSpreadAttribute;
        readonly parent: JsxAttributes;
        readonly expression: Expression;
    }
    interface JsxClosingElement extends Node {
        readonly kind: SyntaxKind.JsxClosingElement;
        readonly parent: JsxElement;
        readonly tagName: JsxTagNameExpression;
    }
    interface JsxExpression extends Expression {
        readonly kind: SyntaxKind.JsxExpression;
        readonly parent: JsxElement | JsxFragment | JsxAttributeLike;
        readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;
        readonly expression?: Expression;
    }
    interface JsxText extends LiteralLikeNode {
        readonly kind: SyntaxKind.JsxText;
        readonly parent: JsxElement | JsxFragment;
        readonly containsOnlyTriviaWhiteSpaces: boolean;
    }
    type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;
    interface Statement extends Node, JSDocContainer {
        _statementBrand: any;
    }
    interface NotEmittedStatement extends Statement {
        readonly kind: SyntaxKind.NotEmittedStatement;
    }
    /**
     * Marks the end of transformed declaration to properly emit exports.
     *
     * @internal
     */
    interface EndOfDeclarationMarker extends Statement {
        readonly kind: SyntaxKind.EndOfDeclarationMarker;
    }
    /**
     * A list of comma-separated expressions. This node is only created by transformations.
     */
    interface CommaListExpression extends Expression {
        readonly kind: SyntaxKind.CommaListExpression;
        readonly elements: NodeArray<Expression>;
    }
    /**
     * Marks the beginning of a merged transformed declaration.
     *
     * @internal
     */
    interface MergeDeclarationMarker extends Statement {
        readonly kind: SyntaxKind.MergeDeclarationMarker;
    }
    /** @internal */
    interface SyntheticReferenceExpression extends LeftHandSideExpression {
        readonly kind: SyntaxKind.SyntheticReferenceExpression;
        readonly expression: Expression;
        readonly thisArg: Expression;
    }
    interface EmptyStatement extends Statement {
        readonly kind: SyntaxKind.EmptyStatement;
    }
    interface DebuggerStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.DebuggerStatement;
    }
    interface MissingDeclaration extends DeclarationStatement, PrimaryExpression {
        readonly kind: SyntaxKind.MissingDeclaration;
        readonly name?: Identifier;
        /** @internal */ readonly modifiers?: NodeArray<ModifierLike> | undefined;
    }
    type BlockLike = SourceFile | Block | ModuleBlock | CaseOrDefaultClause;
    interface Block extends Statement, LocalsContainer {
        readonly kind: SyntaxKind.Block;
        readonly statements: NodeArray<Statement>;
        /** @internal */ multiLine?: boolean;
    }
    interface VariableStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.VariableStatement;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly declarationList: VariableDeclarationList;
    }
    interface ExpressionStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.ExpressionStatement;
        readonly expression: Expression;
    }
    /** @internal */
    interface PrologueDirective extends ExpressionStatement {
        readonly expression: StringLiteral;
    }
    interface IfStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.IfStatement;
        readonly expression: Expression;
        readonly thenStatement: Statement;
        readonly elseStatement?: Statement;
    }
    interface IterationStatement extends Statement {
        readonly statement: Statement;
    }
    interface DoStatement extends IterationStatement, FlowContainer {
        readonly kind: SyntaxKind.DoStatement;
        readonly expression: Expression;
    }
    interface WhileStatement extends IterationStatement, FlowContainer {
        readonly kind: SyntaxKind.WhileStatement;
        readonly expression: Expression;
    }
    type ForInitializer = VariableDeclarationList | Expression;
    interface ForStatement extends IterationStatement, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.ForStatement;
        readonly initializer?: ForInitializer;
        readonly condition?: Expression;
        readonly incrementor?: Expression;
    }
    type ForInOrOfStatement = ForInStatement | ForOfStatement;
    interface ForInStatement extends IterationStatement, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.ForInStatement;
        readonly initializer: ForInitializer;
        readonly expression: Expression;
    }
    interface ForOfStatement extends IterationStatement, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.ForOfStatement;
        readonly awaitModifier?: AwaitKeyword;
        readonly initializer: ForInitializer;
        readonly expression: Expression;
    }
    interface BreakStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.BreakStatement;
        readonly label?: Identifier;
    }
    interface ContinueStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.ContinueStatement;
        readonly label?: Identifier;
    }
    type BreakOrContinueStatement = BreakStatement | ContinueStatement;
    interface ReturnStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.ReturnStatement;
        readonly expression?: Expression;
    }
    interface WithStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.WithStatement;
        readonly expression: Expression;
        readonly statement: Statement;
    }
    interface SwitchStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.SwitchStatement;
        readonly expression: Expression;
        readonly caseBlock: CaseBlock;
        possiblyExhaustive?: boolean;
    }
    interface CaseBlock extends Node, LocalsContainer {
        readonly kind: SyntaxKind.CaseBlock;
        readonly parent: SwitchStatement;
        readonly clauses: NodeArray<CaseOrDefaultClause>;
    }
    interface CaseClause extends Node, JSDocContainer {
        readonly kind: SyntaxKind.CaseClause;
        readonly parent: CaseBlock;
        readonly expression: Expression;
        readonly statements: NodeArray<Statement>;
        /** @internal */ fallthroughFlowNode?: FlowNode;
    }
    interface DefaultClause extends Node {
        readonly kind: SyntaxKind.DefaultClause;
        readonly parent: CaseBlock;
        readonly statements: NodeArray<Statement>;
        /** @internal */ fallthroughFlowNode?: FlowNode;
    }
    type CaseOrDefaultClause = CaseClause | DefaultClause;
    interface LabeledStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.LabeledStatement;
        readonly label: Identifier;
        readonly statement: Statement;
    }
    interface ThrowStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.ThrowStatement;
        readonly expression: Expression;
    }
    interface TryStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.TryStatement;
        readonly tryBlock: Block;
        readonly catchClause?: CatchClause;
        readonly finallyBlock?: Block;
    }
    interface CatchClause extends Node, LocalsContainer {
        readonly kind: SyntaxKind.CatchClause;
        readonly parent: TryStatement;
        readonly variableDeclaration?: VariableDeclaration;
        readonly block: Block;
    }
    type ObjectTypeDeclaration = ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode;
    type DeclarationWithTypeParameters = DeclarationWithTypeParameterChildren | JSDocTypedefTag | JSDocCallbackTag | JSDocSignature;
    type DeclarationWithTypeParameterChildren = SignatureDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTemplateTag;
    interface ClassLikeDeclarationBase extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression;
        readonly name?: Identifier;
        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
        readonly heritageClauses?: NodeArray<HeritageClause>;
        readonly members: NodeArray<ClassElement>;
        typeNames?: string[];
    }
    interface ClassDeclaration extends ClassLikeDeclarationBase, DeclarationStatement {
        readonly kind: SyntaxKind.ClassDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        /** May be undefined in `export default class { ... }`. */
        readonly name?: Identifier;
    }
    interface ClassExpression extends ClassLikeDeclarationBase, PrimaryExpression {
        readonly kind: SyntaxKind.ClassExpression;
        readonly modifiers?: NodeArray<ModifierLike>;
    }
    type ClassLikeDeclaration = ClassDeclaration | ClassExpression;
    interface ClassElement extends NamedDeclaration {
        _classElementBrand: any;
        readonly name?: PropertyName;
    }
    interface TypeElement extends NamedDeclaration {
        _typeElementBrand: any;
        readonly name?: PropertyName;
        readonly questionToken?: QuestionToken | undefined;
    }
    interface InterfaceDeclaration extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.InterfaceDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: Identifier;
        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
        readonly heritageClauses?: NodeArray<HeritageClause>;
        readonly members: NodeArray<TypeElement>;
    }
    interface HeritageClause extends Node {
        readonly kind: SyntaxKind.HeritageClause;
        readonly parent: InterfaceDeclaration | ClassLikeDeclaration;
        readonly token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;
        readonly types: NodeArray<ExpressionWithTypeArguments>;
    }
    interface TypeAliasDeclaration extends DeclarationStatement, JSDocContainer, LocalsContainer {
        readonly kind: SyntaxKind.TypeAliasDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: Identifier;
        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
        readonly type: TypeNode;
    }
    interface EnumMember extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.EnumMember;
        readonly parent: EnumDeclaration;
        readonly name: PropertyName;
        readonly initializer?: Expression;
    }
    interface EnumDeclaration extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.EnumDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: Identifier;
        readonly members: NodeArray<EnumMember>;
    }
    type ModuleName = Identifier | StringLiteral;
    type ModuleBody = NamespaceBody | JSDocNamespaceBody;
    /** @internal */
    interface AmbientModuleDeclaration extends ModuleDeclaration {
        readonly body?: ModuleBlock;
    }
    interface ModuleDeclaration extends DeclarationStatement, JSDocContainer, LocalsContainer {
        readonly kind: SyntaxKind.ModuleDeclaration;
        readonly parent: ModuleBody | SourceFile;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: ModuleName;
        readonly body?: ModuleBody | JSDocNamespaceDeclaration;
    }
    type NamespaceBody = ModuleBlock | NamespaceDeclaration;
    interface NamespaceDeclaration extends ModuleDeclaration {
        readonly name: Identifier;
        readonly body: NamespaceBody;
    }
    type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;
    interface JSDocNamespaceDeclaration extends ModuleDeclaration {
        readonly name: Identifier;
        readonly body?: JSDocNamespaceBody;
    }
    interface ModuleBlock extends Node, Statement {
        readonly kind: SyntaxKind.ModuleBlock;
        readonly parent: ModuleDeclaration;
        readonly statements: NodeArray<Statement>;
    }
    type ModuleReference = EntityName | ExternalModuleReference;
    /**
     * One of:
     * - import x = require("mod");
     * - import x = M.x;
     */
    interface ImportEqualsDeclaration extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.ImportEqualsDeclaration;
        readonly parent: SourceFile | ModuleBlock;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: Identifier;
        readonly isTypeOnly: boolean;
        readonly moduleReference: ModuleReference;
    }
    interface ExternalModuleReference extends Node {
        readonly kind: SyntaxKind.ExternalModuleReference;
        readonly parent: ImportEqualsDeclaration;
        readonly expression: Expression;
    }
    interface ImportDeclaration extends Statement {
        readonly kind: SyntaxKind.ImportDeclaration;
        readonly parent: SourceFile | ModuleBlock;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly importClause?: ImportClause;
        /** If this is not a StringLiteral it will be a grammar error. */
        readonly moduleSpecifier: Expression;
        readonly assertClause?: AssertClause;
    }
    type NamedImportBindings = NamespaceImport | NamedImports;
    type NamedExportBindings = NamespaceExport | NamedExports;
    interface ImportClause extends NamedDeclaration {
        readonly kind: SyntaxKind.ImportClause;
        readonly parent: ImportDeclaration;
        readonly isTypeOnly: boolean;
        readonly name?: Identifier;
        readonly namedBindings?: NamedImportBindings;
    }
    type AssertionKey = Identifier | StringLiteral;
    interface AssertEntry extends Node {
        readonly kind: SyntaxKind.AssertEntry;
        readonly parent: AssertClause;
        readonly name: AssertionKey;
        readonly value: Expression;
    }
    interface AssertClause extends Node {
        readonly kind: SyntaxKind.AssertClause;
        readonly parent: ImportDeclaration | ExportDeclaration;
        readonly elements: NodeArray<AssertEntry>;
        readonly multiLine?: boolean;
    }
    interface NamespaceImport extends NamedDeclaration {
        readonly kind: SyntaxKind.NamespaceImport;
        readonly parent: ImportClause;
        readonly name: Identifier;
    }
    interface NamespaceExport extends NamedDeclaration {
        readonly kind: SyntaxKind.NamespaceExport;
        readonly parent: ExportDeclaration;
        readonly name: Identifier;
    }
    interface NamespaceExportDeclaration extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.NamespaceExportDeclaration;
        readonly name: Identifier;
        /** @internal */ readonly modifiers?: NodeArray<ModifierLike> | undefined;
    }
    interface ExportDeclaration extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.ExportDeclaration;
        readonly parent: SourceFile | ModuleBlock;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly isTypeOnly: boolean;
        /** Will not be assigned in the case of `export * from "foo";` */
        readonly exportClause?: NamedExportBindings;
        /** If this is not a StringLiteral it will be a grammar error. */
        readonly moduleSpecifier?: Expression;
        readonly assertClause?: AssertClause;
    }
    interface NamedImports extends Node {
        readonly kind: SyntaxKind.NamedImports;
        readonly parent: ImportClause;
        readonly elements: NodeArray<ImportSpecifier>;
    }
    interface NamedExports extends Node {
        readonly kind: SyntaxKind.NamedExports;
        readonly parent: ExportDeclaration;
        readonly elements: NodeArray<ExportSpecifier>;
    }
    type NamedImportsOrExports = NamedImports | NamedExports;
    interface ImportSpecifier extends NamedDeclaration {
        readonly kind: SyntaxKind.ImportSpecifier;
        readonly parent: NamedImports;
        readonly propertyName?: Identifier;
        readonly name: Identifier;
        readonly isTypeOnly: boolean;
    }
    interface ExportSpecifier extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.ExportSpecifier;
        readonly parent: NamedExports;
        readonly isTypeOnly: boolean;
        readonly propertyName?: Identifier;
        readonly name: Identifier;
    }
    type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;
    type TypeOnlyCompatibleAliasDeclaration = ImportClause | ImportEqualsDeclaration | NamespaceImport | ImportOrExportSpecifier | ExportDeclaration | NamespaceExport;
    type TypeOnlyImportDeclaration = ImportClause & {
        readonly isTypeOnly: true;
        readonly name: Identifier;
    } | ImportEqualsDeclaration & {
        readonly isTypeOnly: true;
    } | NamespaceImport & {
        readonly parent: ImportClause & {
            readonly isTypeOnly: true;
        };
    } | ImportSpecifier & ({
        readonly isTypeOnly: true;
    } | {
        readonly parent: NamedImports & {
            readonly parent: ImportClause & {
                readonly isTypeOnly: true;
            };
        };
    });
    type TypeOnlyExportDeclaration = ExportSpecifier & ({
        readonly isTypeOnly: true;
    } | {
        readonly parent: NamedExports & {
            readonly parent: ExportDeclaration & {
                readonly isTypeOnly: true;
            };
        };
    }) | ExportDeclaration & {
        readonly isTypeOnly: true;
    } | NamespaceExport & {
        readonly parent: ExportDeclaration & {
            readonly isTypeOnly: true;
        };
    };
    type TypeOnlyAliasDeclaration = TypeOnlyImportDeclaration | TypeOnlyExportDeclaration;
    /**
     * This is either an `export =` or an `export default` declaration.
     * Unless `isExportEquals` is set, this node was parsed as an `export default`.
     */
    interface ExportAssignment extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.ExportAssignment;
        readonly parent: SourceFile;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly isExportEquals?: boolean;
        readonly expression: Expression;
    }
    interface FileReference extends TextRange {
        fileName: string;
        resolutionMode?: ResolutionMode;
    }
    interface CheckJsDirective extends TextRange {
        enabled: boolean;
    }
    type CommentKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;
    interface CommentRange extends TextRange {
        hasTrailingNewLine?: boolean;
        kind: CommentKind;
    }
    interface SynthesizedComment extends CommentRange {
        text: string;
        pos: -1;
        end: -1;
        hasLeadingNewline?: boolean;
    }
    interface JSDocTypeExpression extends TypeNode {
        readonly kind: SyntaxKind.JSDocTypeExpression;
        readonly type: TypeNode;
    }
    interface JSDocNameReference extends Node {
        readonly kind: SyntaxKind.JSDocNameReference;
        readonly name: EntityName | JSDocMemberName;
    }
    /** Class#method reference in JSDoc */
    interface JSDocMemberName extends Node {
        readonly kind: SyntaxKind.JSDocMemberName;
        readonly left: EntityName | JSDocMemberName;
        readonly right: Identifier;
    }
    interface JSDocType extends TypeNode {
        _jsDocTypeBrand: any;
    }
    interface JSDocAllType extends JSDocType {
        readonly kind: SyntaxKind.JSDocAllType;
    }
    interface JSDocUnknownType extends JSDocType {
        readonly kind: SyntaxKind.JSDocUnknownType;
    }
    interface JSDocNonNullableType extends JSDocType {
        readonly kind: SyntaxKind.JSDocNonNullableType;
        readonly type: TypeNode;
        readonly postfix: boolean;
    }
    interface JSDocNullableType extends JSDocType {
        readonly kind: SyntaxKind.JSDocNullableType;
        readonly type: TypeNode;
        readonly postfix: boolean;
    }
    interface JSDocOptionalType extends JSDocType {
        readonly kind: SyntaxKind.JSDocOptionalType;
        readonly type: TypeNode;
    }
    interface JSDocFunctionType extends JSDocType, SignatureDeclarationBase, LocalsContainer {
        readonly kind: SyntaxKind.JSDocFunctionType;
    }
    interface JSDocVariadicType extends JSDocType {
        readonly kind: SyntaxKind.JSDocVariadicType;
        readonly type: TypeNode;
    }
    interface JSDocNamepathType extends JSDocType {
        readonly kind: SyntaxKind.JSDocNamepathType;
        readonly type: TypeNode;
    }
    type JSDocTypeReferencingNode = JSDocVariadicType | JSDocOptionalType | JSDocNullableType | JSDocNonNullableType;
    interface JSDoc extends Node {
        readonly kind: SyntaxKind.JSDoc;
        readonly parent: HasJSDoc;
        readonly tags?: NodeArray<JSDocTag>;
        readonly comment?: string | NodeArray<JSDocComment>;
    }
    interface JSDocTag extends Node {
        readonly parent: JSDoc | JSDocTypeLiteral;
        readonly tagName: Identifier;
        readonly comment?: string | NodeArray<JSDocComment>;
    }
    interface JSDocLink extends Node {
        readonly kind: SyntaxKind.JSDocLink;
        readonly name?: EntityName | JSDocMemberName;
        text: string;
    }
    interface JSDocLinkCode extends Node {
        readonly kind: SyntaxKind.JSDocLinkCode;
        readonly name?: EntityName | JSDocMemberName;
        text: string;
    }
    interface JSDocLinkPlain extends Node {
        readonly kind: SyntaxKind.JSDocLinkPlain;
        readonly name?: EntityName | JSDocMemberName;
        text: string;
    }
    type JSDocComment = JSDocText | JSDocLink | JSDocLinkCode | JSDocLinkPlain;
    interface JSDocText extends Node {
        readonly kind: SyntaxKind.JSDocText;
        text: string;
    }
    interface JSDocUnknownTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocTag;
    }
    /**
     * Note that `@extends` is a synonym of `@augments`.
     * Both tags are represented by this interface.
     */
    interface JSDocAugmentsTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocAugmentsTag;
        readonly class: ExpressionWithTypeArguments & {
            readonly expression: Identifier | PropertyAccessEntityNameExpression;
        };
    }
    interface JSDocImplementsTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocImplementsTag;
        readonly class: ExpressionWithTypeArguments & {
            readonly expression: Identifier | PropertyAccessEntityNameExpression;
        };
    }
    interface JSDocAuthorTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocAuthorTag;
    }
    interface JSDocDeprecatedTag extends JSDocTag {
        kind: SyntaxKind.JSDocDeprecatedTag;
    }
    interface JSDocClassTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocClassTag;
    }
    interface JSDocPublicTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocPublicTag;
    }
    interface JSDocPrivateTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocPrivateTag;
    }
    interface JSDocProtectedTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocProtectedTag;
    }
    interface JSDocReadonlyTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocReadonlyTag;
    }
    interface JSDocOverrideTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocOverrideTag;
    }
    interface JSDocEnumTag extends JSDocTag, Declaration, LocalsContainer {
        readonly kind: SyntaxKind.JSDocEnumTag;
        readonly parent: JSDoc;
        readonly typeExpression: JSDocTypeExpression;
    }
    interface JSDocThisTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocThisTag;
        readonly typeExpression: JSDocTypeExpression;
    }
    interface JSDocTemplateTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocTemplateTag;
        readonly constraint: JSDocTypeExpression | undefined;
        readonly typeParameters: NodeArray<TypeParameterDeclaration>;
    }
    interface JSDocSeeTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocSeeTag;
        readonly name?: JSDocNameReference;
    }
    interface JSDocReturnTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocReturnTag;
        readonly typeExpression?: JSDocTypeExpression;
    }
    interface JSDocTypeTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocTypeTag;
        readonly typeExpression: JSDocTypeExpression;
    }
    interface JSDocTypedefTag extends JSDocTag, NamedDeclaration, LocalsContainer {
        readonly kind: SyntaxKind.JSDocTypedefTag;
        readonly parent: JSDoc;
        readonly fullName?: JSDocNamespaceDeclaration | Identifier;
        readonly name?: Identifier;
        readonly typeExpression?: JSDocTypeExpression | JSDocTypeLiteral;
    }
    interface JSDocCallbackTag extends JSDocTag, NamedDeclaration, LocalsContainer {
        readonly kind: SyntaxKind.JSDocCallbackTag;
        readonly parent: JSDoc;
        readonly fullName?: JSDocNamespaceDeclaration | Identifier;
        readonly name?: Identifier;
        readonly typeExpression: JSDocSignature;
    }
    interface JSDocOverloadTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocOverloadTag;
        readonly parent: JSDoc;
        readonly typeExpression: JSDocSignature;
    }
    interface JSDocThrowsTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocThrowsTag;
        readonly typeExpression?: JSDocTypeExpression;
    }
    interface JSDocSignature extends JSDocType, Declaration, JSDocContainer, LocalsContainer {
        readonly kind: SyntaxKind.JSDocSignature;
        readonly typeParameters?: readonly JSDocTemplateTag[];
        readonly parameters: readonly JSDocParameterTag[];
        readonly type: JSDocReturnTag | undefined;
    }
    interface JSDocPropertyLikeTag extends JSDocTag, Declaration {
        readonly parent: JSDoc;
        readonly name: EntityName;
        readonly typeExpression?: JSDocTypeExpression;
        /** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */
        readonly isNameFirst: boolean;
        readonly isBracketed: boolean;
    }
    interface JSDocPropertyTag extends JSDocPropertyLikeTag {
        readonly kind: SyntaxKind.JSDocPropertyTag;
    }
    interface JSDocParameterTag extends JSDocPropertyLikeTag {
        readonly kind: SyntaxKind.JSDocParameterTag;
    }
    interface JSDocTypeLiteral extends JSDocType, Declaration {
        readonly kind: SyntaxKind.JSDocTypeLiteral;
        readonly jsDocPropertyTags?: readonly JSDocPropertyLikeTag[];
        /** If true, then this type literal represents an *array* of its type. */
        readonly isArrayType: boolean;
    }
    interface JSDocSatisfiesTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocSatisfiesTag;
        readonly typeExpression: JSDocTypeExpression;
    }
    /** @internal */
    interface JSDocSatisfiesExpression extends ParenthesizedExpression {
        readonly _jsDocSatisfiesExpressionBrand: never;
    }
    enum FlowFlags {
        Unreachable = 1,
        Start = 2,
        BranchLabel = 4,
        LoopLabel = 8,
        Assignment = 16,
        TrueCondition = 32,
        FalseCondition = 64,
        SwitchClause = 128,
        ArrayMutation = 256,
        Call = 512,
        ReduceLabel = 1024,
        Referenced = 2048,
        Shared = 4096,
        Label = 12,
        Condition = 96
    }
    type FlowNode = FlowStart | FlowLabel | FlowAssignment | FlowCondition | FlowSwitchClause | FlowArrayMutation | FlowCall | FlowReduceLabel;
    interface FlowNodeBase {
        flags: FlowFlags;
        id?: number;
    }
    interface FlowStart extends FlowNodeBase {
        node?: FunctionExpression | ArrowFunction | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;
    }
    interface FlowLabel extends FlowNodeBase {
        antecedents: FlowNode[] | undefined;
    }
    interface FlowAssignment extends FlowNodeBase {
        node: Expression | VariableDeclaration | BindingElement;
        antecedent: FlowNode;
    }
    interface FlowCall extends FlowNodeBase {
        node: CallExpression;
        antecedent: FlowNode;
    }
    interface FlowCondition extends FlowNodeBase {
        node: Expression;
        antecedent: FlowNode;
    }
    interface FlowSwitchClause extends FlowNodeBase {
        switchStatement: SwitchStatement;
        clauseStart: number;
        clauseEnd: number;
        antecedent: FlowNode;
    }
    interface FlowArrayMutation extends FlowNodeBase {
        node: CallExpression | BinaryExpression;
        antecedent: FlowNode;
    }
    interface FlowReduceLabel extends FlowNodeBase {
        target: FlowLabel;
        antecedents: FlowNode[];
        antecedent: FlowNode;
    }
    type FlowType = Type | IncompleteType;
    interface IncompleteType {
        flags: TypeFlags | 0;
        type: Type;
    }
    interface AmdDependency {
        path: string;
        name?: string;
    }
    /**
     * Subset of properties from SourceFile that are used in multiple utility functions
     */
    interface SourceFileLike {
        readonly text: string;
        /** @internal */
        lineMap?: readonly number[];
        /** @internal */
        getPositionOfLineAndCharacter?(line: number, character: number, allowEdits?: true): number;
    }
    interface SourceFileLike {
        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
    }
    /** @internal */
    interface RedirectInfo {
        /** Source file this redirects to. */
        readonly redirectTarget: SourceFile;
        /**
         * Source file for the duplicate package. This will not be used by the Program,
         * but we need to keep this around so we can watch for changes in underlying.
         */
        readonly unredirected: SourceFile;
    }
    type ResolutionMode = ModuleKind.ESNext | ModuleKind.CommonJS | undefined;
    interface SourceFile extends Declaration, LocalsContainer {
        readonly kind: SyntaxKind.SourceFile;
        readonly statements: NodeArray<Statement>;
        readonly endOfFileToken: Token<SyntaxKind.EndOfFileToken>;
        fileName: string;
        /** @internal */ path: Path;
        text: string;
        /** Resolved path can be different from path property,
         * when file is included through project reference is mapped to its output instead of source
         * in that case resolvedPath = path to output file
         * path = input file's path
         *
         * @internal
         */
        resolvedPath: Path;
        /** Original file name that can be different from fileName,
         * when file is included through project reference is mapped to its output instead of source
         * in that case originalFileName = name of input file
         * fileName = output file's name
         *
         * @internal
         */
        originalFileName: string;
        /**
         * If two source files are for the same version of the same package, one will redirect to the other.
         * (See `createRedirectSourceFile` in program.ts.)
         * The redirect will have this set. The redirected-to source file will be in `redirectTargetsMap`.
         *
         * @internal
         */
        redirectInfo?: RedirectInfo;
        amdDependencies: readonly AmdDependency[];
        moduleName?: string;
        referencedFiles: readonly FileReference[];
        typeReferenceDirectives: readonly FileReference[];
        libReferenceDirectives: readonly FileReference[];
        languageVariant: LanguageVariant;
        isDeclarationFile: boolean;
        /** @internal */
        renamedDependencies?: ReadonlyMap<string, string>;
        /**
         * lib.d.ts should have a reference comment like
         *
         *  /// <reference no-default-lib="true"/>
         *
         * If any other file has this comment, it signals not to include lib.d.ts
         * because this containing file is intended to act as a default library.
         */
        hasNoDefaultLib: boolean;
        languageVersion: ScriptTarget;
        /**
         * When `module` is `Node16` or `NodeNext`, this field controls whether the
         * source file in question is an ESNext-output-format file, or a CommonJS-output-format
         * module. This is derived by the module resolver as it looks up the file, since
         * it is derived from either the file extension of the module, or the containing
         * `package.json` context, and affects both checking and emit.
         *
         * It is _public_ so that (pre)transformers can set this field,
         * since it switches the builtin `node` module transform. Generally speaking, if unset,
         * the field is treated as though it is `ModuleKind.CommonJS`.
         *
         * Note that this field is only set by the module resolution process when
         * `moduleResolution` is `Node16` or `NodeNext`, which is implied by the `module` setting
         * of `Node16` or `NodeNext`, respectively, but may be overriden (eg, by a `moduleResolution`
         * of `node`). If so, this field will be unset and source files will be considered to be
         * CommonJS-output-format by the node module transformer and type checker, regardless of extension or context.
         */
        impliedNodeFormat?: ResolutionMode;
        /** @internal */ packageJsonLocations?: readonly string[];
        /** @internal */ packageJsonScope?: PackageJsonInfo;
        /** @internal */ scriptKind: ScriptKind;
        /**
         * The first "most obvious" node that makes a file an external module.
         * This is intended to be the first top-level import/export,
         * but could be arbitrarily nested (e.g. `import.meta`).
         *
         * @internal
         */
        externalModuleIndicator?: Node | true;
        /**
         * The callback used to set the external module indicator - this is saved to
         * be later reused during incremental reparsing, which otherwise lacks the information
         * to set this field
         *
         * @internal
         */
        setExternalModuleIndicator?: (file: SourceFile) => void;
        /** @internal */ commonJsModuleIndicator?: Node;
        /** @internal */ jsGlobalAugmentations?: SymbolTable;
        /** @internal */ identifiers: ReadonlyMap<string, string>;
        /** @internal */ nodeCount: number;
        /** @internal */ identifierCount: number;
        /** @internal */ symbolCount: number;
        /** @internal */ parseDiagnostics: DiagnosticWithLocation[];
        /** @internal */ bindDiagnostics: DiagnosticWithLocation[];
        /** @internal */ bindSuggestionDiagnostics?: DiagnosticWithLocation[];
        /** @internal */ jsDocDiagnostics?: DiagnosticWithLocation[];
        /** @internal */ additionalSyntacticDiagnostics?: readonly DiagnosticWithLocation[];
        /** @internal */ lineMap: readonly number[];
        /** @internal */ classifiableNames?: ReadonlySet<__String>;
        /** @internal */ commentDirectives?: CommentDirective[];
        /** @internal */ resolvedModules?: ModeAwareCache<ResolvedModuleWithFailedLookupLocations>;
        /** @internal */ resolvedTypeReferenceDirectiveNames?: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>;
        /** @internal */ imports: readonly StringLiteralLike[];
        /** @internal */ moduleAugmentations: readonly (StringLiteral | Identifier)[];
        /** @internal */ patternAmbientModules?: PatternAmbientModule[];
        /** @internal */ ambientModuleNames: readonly string[];
        /** @internal */ checkJsDirective?: CheckJsDirective;
        /** @internal */ version: string;
        /** @internal */ pragmas: ReadonlyPragmaMap;
        /** @internal */ localJsxNamespace?: __String;
        /** @internal */ localJsxFragmentNamespace?: __String;
        /** @internal */ localJsxFactory?: EntityName;
        /** @internal */ localJsxFragmentFactory?: EntityName;
        /** @internal */ exportedModulesFromDeclarationEmit?: ExportedModulesFromDeclarationEmit;
        /** @internal */ endFlowNode?: FlowNode;
    }
    /** @internal */
    interface SourceFile extends ReadonlyPragmaContext {
    }
    interface SourceFile {
        /** @internal */ version: string;
        /** @internal */ scriptSnapshot: IScriptSnapshot | undefined;
        /** @internal */ nameTable: UnderscoreEscapedMap<number> | undefined;
        /** @internal */ getNamedDeclarations(): Map<string, readonly Declaration[]>;
        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
        getLineEndOfPosition(pos: number): number;
        getLineStarts(): readonly number[];
        getPositionOfLineAndCharacter(line: number, character: number): number;
        update(newText: string, textChangeRange: TextChangeRange): SourceFile;
        /** @internal */ sourceMapper?: DocumentPositionMapper;
    }
    /** @internal */
    interface ReadonlyPragmaContext {
        languageVersion: ScriptTarget;
        pragmas?: ReadonlyPragmaMap;
        checkJsDirective?: CheckJsDirective;
        referencedFiles: readonly FileReference[];
        typeReferenceDirectives: readonly FileReference[];
        libReferenceDirectives: readonly FileReference[];
        amdDependencies: readonly AmdDependency[];
        hasNoDefaultLib?: boolean;
        moduleName?: string;
    }
    /** @internal */
    interface PragmaContext extends ReadonlyPragmaContext {
        pragmas?: PragmaMap;
        referencedFiles: FileReference[];
        typeReferenceDirectives: FileReference[];
        libReferenceDirectives: FileReference[];
        amdDependencies: AmdDependency[];
    }
    /** @internal */
    interface CommentDirective {
        range: TextRange;
        type: CommentDirectiveType;
    }
    /** @internal */
    enum CommentDirectiveType {
        ExpectError = 0,
        Ignore = 1
    }
    /** @internal */
    type ExportedModulesFromDeclarationEmit = readonly Symbol[];
    interface Bundle extends Node {
        readonly kind: SyntaxKind.Bundle;
        /** @deprecated */ readonly prepends: readonly (InputFiles | UnparsedSource)[];
        readonly sourceFiles: readonly SourceFile[];
        /** @internal */ syntheticFileReferences?: readonly FileReference[];
        /** @internal */ syntheticTypeReferences?: readonly FileReference[];
        /** @internal */ syntheticLibReferences?: readonly FileReference[];
        /** @internal */ hasNoDefaultLib?: boolean;
    }
    /** @deprecated */
    interface InputFiles extends Node {
        readonly kind: SyntaxKind.InputFiles;
        javascriptPath?: string;
        javascriptText: string;
        javascriptMapPath?: string;
        javascriptMapText?: string;
        declarationPath?: string;
        declarationText: string;
        declarationMapPath?: string;
        declarationMapText?: string;
        /** @internal */ buildInfoPath?: string;
        /** @internal */ buildInfo?: BuildInfo;
        /** @internal */ oldFileOfCurrentEmit?: boolean;
    }
    /** @deprecated */
    interface UnparsedSource extends Node {
        readonly kind: SyntaxKind.UnparsedSource;
        fileName: string;
        text: string;
        readonly prologues: readonly UnparsedPrologue[];
        helpers: readonly UnscopedEmitHelper[] | undefined;
        referencedFiles: readonly FileReference[];
        typeReferenceDirectives: readonly FileReference[] | undefined;
        libReferenceDirectives: readonly FileReference[];
        hasNoDefaultLib?: boolean;
        sourceMapPath?: string;
        sourceMapText?: string;
        readonly syntheticReferences?: readonly UnparsedSyntheticReference[];
        readonly texts: readonly UnparsedSourceText[];
        /** @internal */ oldFileOfCurrentEmit?: boolean;
        /** @internal */ parsedSourceMap?: RawSourceMap | false | undefined;
        /** @internal */
        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
    }
    /** @deprecated */
    type UnparsedSourceText = UnparsedPrepend | UnparsedTextLike;
    /** @deprecated */
    type UnparsedNode = UnparsedPrologue | UnparsedSourceText | UnparsedSyntheticReference;
    /** @deprecated */
    interface UnparsedSection extends Node {
        readonly kind: SyntaxKind;
        readonly parent: UnparsedSource;
        readonly data?: string;
    }
    /** @deprecated */
    interface UnparsedPrologue extends UnparsedSection {
        readonly kind: SyntaxKind.UnparsedPrologue;
        readonly parent: UnparsedSource;
        readonly data: string;
    }
    /** @deprecated */
    interface UnparsedPrepend extends UnparsedSection {
        readonly kind: SyntaxKind.UnparsedPrepend;
        readonly parent: UnparsedSource;
        readonly data: string;
        readonly texts: readonly UnparsedTextLike[];
    }
    /** @deprecated */
    interface UnparsedTextLike extends UnparsedSection {
        readonly kind: SyntaxKind.UnparsedText | SyntaxKind.UnparsedInternalText;
        readonly parent: UnparsedSource;
    }
    /** @deprecated */
    interface UnparsedSyntheticReference extends UnparsedSection {
        readonly kind: SyntaxKind.UnparsedSyntheticReference;
        readonly parent: UnparsedSource;
        /** @internal */ readonly section: BundleFileHasNoDefaultLib | BundleFileReference;
    }
    interface JsonSourceFile extends SourceFile {
        readonly statements: NodeArray<JsonObjectExpressionStatement>;
    }
    interface TsConfigSourceFile extends JsonSourceFile {
        extendedSourceFiles?: string[];
        /** @internal */ configFileSpecs?: ConfigFileSpecs;
    }
    interface JsonMinusNumericLiteral extends PrefixUnaryExpression {
        readonly kind: SyntaxKind.PrefixUnaryExpression;
        readonly operator: SyntaxKind.MinusToken;
        readonly operand: NumericLiteral;
    }
    type JsonObjectExpression = ObjectLiteralExpression | ArrayLiteralExpression | JsonMinusNumericLiteral | NumericLiteral | StringLiteral | BooleanLiteral | NullLiteral;
    interface JsonObjectExpressionStatement extends ExpressionStatement {
        readonly expression: JsonObjectExpression;
    }
    interface ScriptReferenceHost {
        getCompilerOptions(): CompilerOptions;
        getSourceFile(fileName: string): SourceFile | undefined;
        getSourceFileByPath(path: Path): SourceFile | undefined;
        getCurrentDirectory(): string;
    }
    interface ParseConfigHost {
        useCaseSensitiveFileNames: boolean;
        readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): readonly string[];
        /**
         * Gets a value indicating whether the specified path exists and is a file.
         * @param path The path to test.
         */
        fileExists(path: string): boolean;
        readFile(path: string): string | undefined;
        trace?(s: string): void;
    }
    /**
     * Branded string for keeping track of when we've turned an ambiguous path
     * specified like "./blah" to an absolute path to an actual
     * tsconfig file, e.g. "/root/blah/tsconfig.json"
     */
    type ResolvedConfigFileName = string & {
        _isResolvedConfigFileName: never;
    };
    interface WriteFileCallbackData {
        /** @internal */ sourceMapUrlPos?: number;
        /** @internal */ buildInfo?: BuildInfo;
        /** @internal */ diagnostics?: readonly DiagnosticWithLocation[];
        /** @internal */ differsOnlyInMap?: true;
    }
    type WriteFileCallback = (fileName: string, text: string, writeByteOrderMark: boolean, onError?: (message: string) => void, sourceFiles?: readonly SourceFile[], data?: WriteFileCallbackData) => void;
    class OperationCanceledException {
    }
    interface CancellationToken {
        isCancellationRequested(): boolean;
        /** @throws OperationCanceledException if isCancellationRequested is true */
        throwIfCancellationRequested(): void;
    }
    /** @internal */
    enum FileIncludeKind {
        RootFile = 0,
        SourceFromProjectReference = 1,
        OutputFromProjectReference = 2,
        Import = 3,
        ReferenceFile = 4,
        TypeReferenceDirective = 5,
        LibFile = 6,
        LibReferenceDirective = 7,
        AutomaticTypeDirectiveFile = 8
    }
    /** @internal */
    interface RootFile {
        kind: FileIncludeKind.RootFile;
        index: number;
    }
    /** @internal */
    interface LibFile {
        kind: FileIncludeKind.LibFile;
        index?: number;
    }
    /** @internal */
    type ProjectReferenceFileKind = FileIncludeKind.SourceFromProjectReference | FileIncludeKind.OutputFromProjectReference;
    /** @internal */
    interface ProjectReferenceFile {
        kind: ProjectReferenceFileKind;
        index: number;
    }
    /** @internal */
    type ReferencedFileKind = FileIncludeKind.Import | FileIncludeKind.ReferenceFile | FileIncludeKind.TypeReferenceDirective | FileIncludeKind.LibReferenceDirective;
    /** @internal */
    interface ReferencedFile {
        kind: ReferencedFileKind;
        file: Path;
        index: number;
    }
    /** @internal */
    interface AutomaticTypeDirectiveFile {
        kind: FileIncludeKind.AutomaticTypeDirectiveFile;
        typeReference: string;
        packageId: PackageId | undefined;
    }
    /** @internal */
    type FileIncludeReason = RootFile | LibFile | ProjectReferenceFile | ReferencedFile | AutomaticTypeDirectiveFile;
    /** @internal */
    enum FilePreprocessingDiagnosticsKind {
        FilePreprocessingReferencedDiagnostic = 0,
        FilePreprocessingFileExplainingDiagnostic = 1,
        ResolutionDiagnostics = 2
    }
    /** @internal */
    interface FilePreprocessingReferencedDiagnostic {
        kind: FilePreprocessingDiagnosticsKind.FilePreprocessingReferencedDiagnostic;
        reason: ReferencedFile;
        diagnostic: DiagnosticMessage;
        args?: (string | number | undefined)[];
    }
    /** @internal */
    interface FilePreprocessingFileExplainingDiagnostic {
        kind: FilePreprocessingDiagnosticsKind.FilePreprocessingFileExplainingDiagnostic;
        file?: Path;
        fileProcessingReason: FileIncludeReason;
        diagnostic: DiagnosticMessage;
        args?: (string | number | undefined)[];
    }
    /** @internal */
    interface ResolutionDiagnostics {
        kind: FilePreprocessingDiagnosticsKind.ResolutionDiagnostics;
        diagnostics: readonly Diagnostic[];
    }
    /** @internal */
    type FilePreprocessingDiagnostics = FilePreprocessingReferencedDiagnostic | FilePreprocessingFileExplainingDiagnostic | ResolutionDiagnostics;
    /** @internal */
    enum EmitOnly {
        Js = 0,
        Dts = 1
    }
    interface Program extends ScriptReferenceHost {
        getCurrentDirectory(): string;
        /**
         * Get a list of root file names that were passed to a 'createProgram'
         */
        getRootFileNames(): readonly string[];
        /**
         * Get a list of files in the program
         */
        getSourceFiles(): readonly SourceFile[];
        /**
         * Get a list of file names that were passed to 'createProgram' or referenced in a
         * program source file but could not be located.
         *
         * @internal
         */
        getMissingFilePaths(): readonly Path[];
        /** @internal */
        getModuleResolutionCache(): ModuleResolutionCache | undefined;
        /** @internal */
        getFilesByNameMap(): Map<string, SourceFile | false | undefined>;
        /**
         * Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then
         * the JavaScript and declaration files will be produced for all the files in this program.
         * If targetSourceFile is specified, then only the JavaScript and declaration for that
         * specific file will be generated.
         *
         * If writeFile is not specified then the writeFile callback from the compiler host will be
         * used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter
         * will be invoked when writing the JavaScript and declaration files.
         */
        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;
        /** @internal */
        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnly?: boolean | EmitOnly, customTransformers?: CustomTransformers, forceDtsEmit?: boolean): EmitResult;
        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
        /** The first time this is called, it will return global diagnostics (no location). */
        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
        getConfigFileParsingDiagnostics(): readonly Diagnostic[];
        /** @internal */ getSuggestionDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
        /** @internal */ getBindAndCheckDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        /** @internal */ getProgramDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        /**
         * Gets a type checker that can be used to semantically analyze source files in the program.
         */
        getTypeChecker(): TypeChecker;
        /** @internal */ getCommonSourceDirectory(): string;
        /** @internal */ getCachedSemanticDiagnostics(sourceFile?: SourceFile): readonly Diagnostic[] | undefined;
        /** @internal */ getClassifiableNames(): Set<__String>;
        getNodeCount(): number;
        getIdentifierCount(): number;
        getSymbolCount(): number;
        getTypeCount(): number;
        getInstantiationCount(): number;
        getRelationCacheSizes(): {
            assignable: number;
            identity: number;
            subtype: number;
            strictSubtype: number;
        };
        /** @internal */ getFileProcessingDiagnostics(): FilePreprocessingDiagnostics[] | undefined;
        /** @internal */ getResolvedTypeReferenceDirectives(): ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>;
        /** @internal */ getAutomaticTypeDirectiveNames(): string[];
        /** @internal */ getAutomaticTypeDirectiveResolutions(): ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>;
        isSourceFileFromExternalLibrary(file: SourceFile): boolean;
        isSourceFileDefaultLibrary(file: SourceFile): boolean;
        /** @internal */ readonly structureIsReused: StructureIsReused;
        /** @internal */ getSourceFileFromReference(referencingFile: SourceFile | UnparsedSource, ref: FileReference): SourceFile | undefined;
        /** @internal */ getLibFileFromReference(ref: FileReference): SourceFile | undefined;
        /**
         * Given a source file, get the name of the package it was imported from.
         *
         * @internal
         */
        sourceFileToPackageName: Map<Path, string>;
        /**
         * Set of all source files that some other source file redirects to.
         *
         * @internal
         */
        redirectTargetsMap: MultiMap<Path, string>;
        /**
         * Whether any (non-external, non-declaration) source files use `node:`-prefixed module specifiers.
         *
         * @internal
         */
        readonly usesUriStyleNodeCoreModules: boolean;
        /**
         * Is the file emitted file
         *
         * @internal
         */
        isEmittedFile(file: string): boolean;
        /** @internal */ getFileIncludeReasons(): MultiMap<Path, FileIncludeReason>;
        /** @internal */ useCaseSensitiveFileNames(): boolean;
        /** @internal */ getCanonicalFileName: GetCanonicalFileName;
        getProjectReferences(): readonly ProjectReference[] | undefined;
        getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined;
        /** @internal */ getProjectReferenceRedirect(fileName: string): string | undefined;
        /** @internal */ getResolvedProjectReferenceToRedirect(fileName: string): ResolvedProjectReference | undefined;
        /** @internal */ forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined;
        /** @internal */ getResolvedProjectReferenceByPath(projectReferencePath: Path): ResolvedProjectReference | undefined;
        /** @internal */ isSourceOfProjectReferenceRedirect(fileName: string): boolean;
        /** @internal */ getBuildInfo?(bundle: BundleBuildInfo | undefined): BuildInfo;
        /** @internal */ emitBuildInfo(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken): EmitResult;
        /**
         * This implementation handles file exists to be true if file is source of project reference redirect when program is created using useSourceOfProjectReferenceRedirect
         *
         * @internal
         */
        fileExists(fileName: string): boolean;
        /**
         * Call compilerHost.writeFile on host program was created with
         *
         * @internal
         */
        writeFile: WriteFileCallback;
    }
    /** @internal */
    interface Program extends TypeCheckerHost, ModuleSpecifierResolutionHost {
    }
    /** @internal */
    type RedirectTargetsMap = ReadonlyMap<Path, readonly string[]>;
    interface ResolvedProjectReference {
        commandLine: ParsedCommandLine;
        sourceFile: SourceFile;
        references?: readonly (ResolvedProjectReference | undefined)[];
    }
    /** @internal */
    enum StructureIsReused {
        Not = 0,
        SafeModules = 1,
        Completely = 2
    }
    type CustomTransformerFactory = (context: TransformationContext) => CustomTransformer;
    interface CustomTransformer {
        transformSourceFile(node: SourceFile): SourceFile;
        transformBundle(node: Bundle): Bundle;
    }
    interface CustomTransformers {
        /** Custom transformers to evaluate before built-in .js transformations. */
        before?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];
        /** Custom transformers to evaluate after built-in .js transformations. */
        after?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];
        /** Custom transformers to evaluate after built-in .d.ts transformations. */
        afterDeclarations?: (TransformerFactory<Bundle | SourceFile> | CustomTransformerFactory)[];
    }
    /** @internal */
    interface EmitTransformers {
        scriptTransformers: readonly TransformerFactory<SourceFile | Bundle>[];
        declarationTransformers: readonly TransformerFactory<SourceFile | Bundle>[];
    }
    interface SourceMapSpan {
        /** Line number in the .js file. */
        emittedLine: number;
        /** Column number in the .js file. */
        emittedColumn: number;
        /** Line number in the .ts file. */
        sourceLine: number;
        /** Column number in the .ts file. */
        sourceColumn: number;
        /** Optional name (index into names array) associated with this span. */
        nameIndex?: number;
        /** .ts file (index into sources array) associated with this span */
        sourceIndex: number;
    }
    /** @internal */
    interface SourceMapEmitResult {
        inputSourceFileNames: readonly string[];
        sourceMap: RawSourceMap;
    }
    /** Return code used by getEmitOutput function to indicate status of the function */
    enum ExitStatus {
        Success = 0,
        DiagnosticsPresent_OutputsSkipped = 1,
        DiagnosticsPresent_OutputsGenerated = 2,
        InvalidProject_OutputsSkipped = 3,
        ProjectReferenceCycle_OutputsSkipped = 4
    }
    interface EmitResult {
        emitSkipped: boolean;
        /** Contains declaration emit diagnostics */
        diagnostics: readonly Diagnostic[];
        emittedFiles?: string[];
        /** @internal */ sourceMaps?: SourceMapEmitResult[];
    }
    /** @internal */
    interface TypeCheckerHost extends ModuleSpecifierResolutionHost {
        getCompilerOptions(): CompilerOptions;
        getSourceFiles(): readonly SourceFile[];
        getSourceFile(fileName: string): SourceFile | undefined;
        getResolvedTypeReferenceDirectives(): ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>;
        getProjectReferenceRedirect(fileName: string): string | undefined;
        isSourceOfProjectReferenceRedirect(fileName: string): boolean;
        readonly redirectTargetsMap: RedirectTargetsMap;
    }
    interface TypeChecker {
        getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;
        getTypeOfSymbol(symbol: Symbol): Type;
        getDeclaredTypeOfSymbol(symbol: Symbol): Type;
        getPropertiesOfType(type: Type): Symbol[];
        getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;
        getPrivateIdentifierPropertyOfType(leftType: Type, name: string, location: Node): Symbol | undefined;
        /** @internal */ getTypeOfPropertyOfType(type: Type, propertyName: string): Type | undefined;
        getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;
        getIndexInfosOfType(type: Type): readonly IndexInfo[];
        getIndexInfosOfIndexSymbol: (indexSymbol: Symbol) => IndexInfo[];
        getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[];
        getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;
        /** @internal */ getIndexType(type: Type): Type;
        getBaseTypes(type: InterfaceType): BaseType[];
        getBaseTypeOfLiteralType(type: Type): Type;
        getWidenedType(type: Type): Type;
        /** @internal */
        getPromisedTypeOfPromise(promise: Type, errorNode?: Node): Type | undefined;
        /** @internal */
        getAwaitedType(type: Type): Type | undefined;
        /** @internal */
        isEmptyAnonymousObjectType(type: Type): boolean;
        getReturnTypeOfSignature(signature: Signature): Type;
        /**
         * Gets the type of a parameter at a given position in a signature.
         * Returns `any` if the index is not valid.
         *
         * @internal
         */
        getParameterType(signature: Signature, parameterIndex: number): Type;
        /** @internal */ getParameterIdentifierNameAtPosition(signature: Signature, parameterIndex: number): [
            parameterName: __String,
            isRestParameter: boolean
        ] | undefined;
        getNullableType(type: Type, flags: TypeFlags): Type;
        getNonNullableType(type: Type): Type;
        /** @internal */ getNonOptionalType(type: Type): Type;
        /** @internal */ isNullableType(type: Type): boolean;
        getTypeArguments(type: TypeReference): readonly Type[];
        /** Note that the resulting nodes cannot be checked. */
        typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeNode | undefined;
        /** @internal */ typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, tracker?: SymbolTracker): TypeNode | undefined;
        /** Note that the resulting nodes cannot be checked. */
        signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): SignatureDeclaration & {
            typeArguments?: NodeArray<TypeNode>;
        } | undefined;
        /** @internal */ signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, tracker?: SymbolTracker): SignatureDeclaration & {
            typeArguments?: NodeArray<TypeNode>;
        } | undefined;
        /** Note that the resulting nodes cannot be checked. */
        indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): IndexSignatureDeclaration | undefined;
        /** @internal */ indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, tracker?: SymbolTracker): IndexSignatureDeclaration | undefined;
        /** Note that the resulting nodes cannot be checked. */
        symbolToEntityName(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): EntityName | undefined;
        /** Note that the resulting nodes cannot be checked. */
        symbolToExpression(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Expression | undefined;
        /**
         * Note that the resulting nodes cannot be checked.
         *
         * @internal
         */
        symbolToNode(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Node | undefined;
        /** Note that the resulting nodes cannot be checked. */
        symbolToTypeParameterDeclarations(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): NodeArray<TypeParameterDeclaration> | undefined;
        /** Note that the resulting nodes cannot be checked. */
        symbolToParameterDeclaration(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): ParameterDeclaration | undefined;
        /** Note that the resulting nodes cannot be checked. */
        typeParameterToDeclaration(parameter: TypeParameter, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeParameterDeclaration | undefined;
        getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];
        getSymbolAtLocation(node: Node): Symbol | undefined;
        /** @internal */ getIndexInfosAtLocation(node: Node): readonly IndexInfo[] | undefined;
        getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];
        /**
         * The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.
         * This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value.
         */
        getShorthandAssignmentValueSymbol(location: Node | undefined): Symbol | undefined;
        getExportSpecifierLocalTargetSymbol(location: ExportSpecifier | Identifier): Symbol | undefined;
        /**
         * If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.
         * Otherwise returns its input.
         * For example, at `export type T = number;`:
         *     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.
         *     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.
         *     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.
         */
        getExportSymbolOfSymbol(symbol: Symbol): Symbol;
        getPropertySymbolOfDestructuringAssignment(location: Identifier): Symbol | undefined;
        getTypeOfAssignmentPattern(pattern: AssignmentPattern): Type;
        getTypeAtLocation(node: Node): Type;
        getTypeFromTypeNode(node: TypeNode): Type;
        signatureToString(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): string;
        typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;
        symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): string;
        typePredicateToString(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;
        /** @internal */ writeSignature(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind, writer?: EmitTextWriter): string;
        /** @internal */ writeType(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags, writer?: EmitTextWriter): string;
        /** @internal */ writeSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags, writer?: EmitTextWriter): string;
        /** @internal */ writeTypePredicate(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags, writer?: EmitTextWriter): string;
        getFullyQualifiedName(symbol: Symbol): string;
        getAugmentedPropertiesOfType(type: Type): Symbol[];
        getRootSymbols(symbol: Symbol): readonly Symbol[];
        getSymbolOfExpando(node: Node, allowDeclaration: boolean): Symbol | undefined;
        getContextualType(node: Expression): Type | undefined;
        /** @internal */ getContextualType(node: Expression, contextFlags?: ContextFlags): Type | undefined;
        /** @internal */ getContextualTypeForObjectLiteralElement(element: ObjectLiteralElementLike): Type | undefined;
        /** @internal */ getContextualTypeForArgumentAtIndex(call: CallLikeExpression, argIndex: number): Type | undefined;
        /** @internal */ getContextualTypeForJsxAttribute(attribute: JsxAttribute | JsxSpreadAttribute): Type | undefined;
        /** @internal */ isContextSensitive(node: Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike): boolean;
        /** @internal */ getTypeOfPropertyOfContextualType(type: Type, name: __String): Type | undefined;
        /**
         * returns unknownSignature in the case of an error.
         * returns undefined if the node is not valid.
         * @param argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.
         */
        getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;
        /** @internal */ getResolvedSignatureForSignatureHelp(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;
        /** @internal */ getResolvedSignatureForStringLiteralCompletions(call: CallLikeExpression, editingArgument: Node, candidatesOutArray: Signature[]): Signature | undefined;
        /** @internal */ getExpandedParameters(sig: Signature): readonly (readonly Symbol[])[];
        /** @internal */ hasEffectiveRestParameter(sig: Signature): boolean;
        /** @internal */ containsArgumentsReference(declaration: SignatureDeclaration): boolean;
        getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;
        isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;
        isUndefinedSymbol(symbol: Symbol): boolean;
        isArgumentsSymbol(symbol: Symbol): boolean;
        isUnknownSymbol(symbol: Symbol): boolean;
        /** @internal */ getMergedSymbol(symbol: Symbol): Symbol;
        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;
        isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: string): boolean;
        /**
         * Exclude accesses to private properties.
         *
         * @internal
         */
        isValidPropertyAccessForCompletions(node: PropertyAccessExpression | ImportTypeNode | QualifiedName, type: Type, property: Symbol): boolean;
        /** Follow all aliases to get the original symbol. */
        getAliasedSymbol(symbol: Symbol): Symbol;
        /** Follow a *single* alias to get the immediately aliased symbol. */
        getImmediateAliasedSymbol(symbol: Symbol): Symbol | undefined;
        getExportsOfModule(moduleSymbol: Symbol): Symbol[];
        /**
         * Unlike `getExportsOfModule`, this includes properties of an `export =` value.
         *
         * @internal
         */
        getExportsAndPropertiesOfModule(moduleSymbol: Symbol): Symbol[];
        /** @internal */ forEachExportAndPropertyOfModule(moduleSymbol: Symbol, cb: (symbol: Symbol, key: __String) => void): void;
        getJsxIntrinsicTagNamesAt(location: Node): Symbol[];
        isOptionalParameter(node: ParameterDeclaration): boolean;
        getAmbientModules(): Symbol[];
        tryGetMemberInModuleExports(memberName: string, moduleSymbol: Symbol): Symbol | undefined;
        /**
         * Unlike `tryGetMemberInModuleExports`, this includes properties of an `export =` value.
         * Does *not* return properties of primitive types.
         *
         * @internal
         */
        tryGetMemberInModuleExportsAndProperties(memberName: string, moduleSymbol: Symbol): Symbol | undefined;
        getApparentType(type: Type): Type;
        /** @internal */ getSuggestedSymbolForNonexistentProperty(name: MemberName | string, containingType: Type): Symbol | undefined;
        /** @internal */ getSuggestedSymbolForNonexistentJSXAttribute(name: Identifier | string, containingType: Type): Symbol | undefined;
        /** @internal */ getSuggestionForNonexistentProperty(name: MemberName | string, containingType: Type): string | undefined;
        /** @internal */ getSuggestedSymbolForNonexistentSymbol(location: Node, name: string, meaning: SymbolFlags): Symbol | undefined;
        /** @internal */ getSuggestionForNonexistentSymbol(location: Node, name: string, meaning: SymbolFlags): string | undefined;
        /** @internal */ getSuggestedSymbolForNonexistentModule(node: Identifier, target: Symbol): Symbol | undefined;
        /** @internal */ getSuggestedSymbolForNonexistentClassMember(name: string, baseType: Type): Symbol | undefined;
        /** @internal */ getSuggestionForNonexistentExport(node: Identifier, target: Symbol): string | undefined;
        getBaseConstraintOfType(type: Type): Type | undefined;
        getDefaultFromTypeParameter(type: Type): Type | undefined;
        /** @internal */ getAnyType(): Type;
        /** @internal */ getStringType(): Type;
        /** @internal */ getNumberType(): Type;
        /** @internal */ getBooleanType(): Type;
        /** @internal */ getFalseType(fresh?: boolean): Type;
        /** @internal */ getTrueType(fresh?: boolean): Type;
        /** @internal */ getVoidType(): Type;
        /** @internal */ getUndefinedType(): Type;
        /** @internal */ getNullType(): Type;
        /** @internal */ getESSymbolType(): Type;
        /** @internal */ getNeverType(): Type;
        /** @internal */ getOptionalType(): Type;
        /** @internal */ getUnionType(types: Type[], subtypeReduction?: UnionReduction): Type;
        /** @internal */ createArrayType(elementType: Type): Type;
        /** @internal */ getElementTypeOfArrayType(arrayType: Type): Type | undefined;
        /** @internal */ createPromiseType(type: Type): Type;
        /** @internal */ getPromiseType(): Type;
        /** @internal */ getPromiseLikeType(): Type;
        /** @internal */ getAsyncIterableType(): Type | undefined;
        /** @internal */ isTypeAssignableTo(source: Type, target: Type): boolean;
        /** @internal */ createAnonymousType(symbol: Symbol | undefined, members: SymbolTable, callSignatures: Signature[], constructSignatures: Signature[], indexInfos: IndexInfo[]): Type;
        /** @internal */ createSignature(declaration: SignatureDeclaration | undefined, typeParameters: readonly TypeParameter[] | undefined, thisParameter: Symbol | undefined, parameters: readonly Symbol[], resolvedReturnType: Type, typePredicate: TypePredicate | undefined, minArgumentCount: number, flags: SignatureFlags): Signature;
        /** @internal */ createSymbol(flags: SymbolFlags, name: __String): TransientSymbol;
        /** @internal */ createIndexInfo(keyType: Type, type: Type, isReadonly: boolean, declaration?: SignatureDeclaration): IndexInfo;
        /** @internal */ isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, shouldComputeAliasToMarkVisible: boolean): SymbolAccessibilityResult;
        /** @internal */ tryFindAmbientModule(moduleName: string): Symbol | undefined;
        /** @internal */ tryFindAmbientModuleWithoutAugmentations(moduleName: string): Symbol | undefined;
        /** @internal */ getSymbolWalker(accept?: (symbol: Symbol) => boolean): SymbolWalker;
        /** @internal */ getDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): Diagnostic[];
        /** @internal */ getGlobalDiagnostics(): Diagnostic[];
        /** @internal */ getEmitResolver(sourceFile?: SourceFile, cancellationToken?: CancellationToken): EmitResolver;
        /** @internal */ getNodeCount(): number;
        /** @internal */ getIdentifierCount(): number;
        /** @internal */ getSymbolCount(): number;
        /** @internal */ getTypeCount(): number;
        /** @internal */ getInstantiationCount(): number;
        /** @internal */ getRelationCacheSizes(): {
            assignable: number;
            identity: number;
            subtype: number;
            strictSubtype: number;
        };
        /** @internal */ getRecursionIdentity(type: Type): object | undefined;
        /** @internal */ getUnmatchedProperties(source: Type, target: Type, requireOptionalProperties: boolean, matchDiscriminantProperties: boolean): IterableIterator<Symbol>;
        /**
         * True if this type is the `Array` or `ReadonlyArray` type from lib.d.ts.
         * This function will _not_ return true if passed a type which
         * extends `Array` (for example, the TypeScript AST's `NodeArray` type).
         */
        isArrayType(type: Type): boolean;
        /**
         * True if this type is a tuple type. This function will _not_ return true if
         * passed a type which extends from a tuple.
         */
        isTupleType(type: Type): boolean;
        /**
         * True if this type is assignable to `ReadonlyArray<any>`.
         */
        isArrayLikeType(type: Type): boolean;
        /**
         * True if `contextualType` should not be considered for completions because
         * e.g. it specifies `kind: "a"` and obj has `kind: "b"`.
         *
         * @internal
         */
        isTypeInvalidDueToUnionDiscriminant(contextualType: Type, obj: ObjectLiteralExpression | JsxAttributes): boolean;
        /** @internal */ getExactOptionalProperties(type: Type): Symbol[];
        /**
         * For a union, will include a property if it's defined in *any* of the member types.
         * So for `{ a } | { b }`, this will include both `a` and `b`.
         * Does not include properties of primitive types.
         *
         * @internal
         */
        getAllPossiblePropertiesOfTypes(type: readonly Type[]): Symbol[];
        /** @internal */ resolveName(name: string, location: Node | undefined, meaning: SymbolFlags, excludeGlobals: boolean): Symbol | undefined;
        /** @internal */ getJsxNamespace(location?: Node): string;
        /** @internal */ getJsxFragmentFactory(location: Node): string | undefined;
        /**
         * Note that this will return undefined in the following case:
         *     // a.ts
         *     export namespace N { export class C { } }
         *     // b.ts
         *     <<enclosingDeclaration>>
         * Where `C` is the symbol we're looking for.
         * This should be called in a loop climbing parents of the symbol, so we'll get `N`.
         *
         * @internal
         */
        getAccessibleSymbolChain(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, useOnlyExternalAliasing: boolean): Symbol[] | undefined;
        getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined;
        /** @internal */ resolveExternalModuleName(moduleSpecifier: Expression): Symbol | undefined;
        /**
         * An external module with an 'export =' declaration resolves to the target of the 'export =' declaration,
         * and an external module with no 'export =' declaration resolves to the module itself.
         *
         * @internal
         */
        resolveExternalModuleSymbol(symbol: Symbol): Symbol;
        /**
         * @param node A location where we might consider accessing `this`. Not necessarily a ThisExpression.
         *
         * @internal
         */
        tryGetThisTypeAt(node: Node, includeGlobalThis?: boolean, container?: ThisContainer): Type | undefined;
        /** @internal */ getTypeArgumentConstraint(node: TypeNode): Type | undefined;
        /**
         * Does *not* get *all* suggestion diagnostics, just the ones that were convenient to report in the checker.
         * Others are added in computeSuggestionDiagnostics.
         *
         * @internal
         */
        getSuggestionDiagnostics(file: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
        /**
         * Depending on the operation performed, it may be appropriate to throw away the checker
         * if the cancellation token is triggered. Typically, if it is used for error checking
         * and the operation is cancelled, then it should be discarded, otherwise it is safe to keep.
         */
        runWithCancellationToken<T>(token: CancellationToken, cb: (checker: TypeChecker) => T): T;
        /** @internal */ getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol: Symbol): readonly TypeParameter[] | undefined;
        /** @internal */ isDeclarationVisible(node: Declaration | AnyImportSyntax): boolean;
        /** @internal */ isPropertyAccessible(node: Node, isSuper: boolean, isWrite: boolean, containingType: Type, property: Symbol): boolean;
        /** @internal */ getTypeOnlyAliasDeclaration(symbol: Symbol): TypeOnlyAliasDeclaration | undefined;
        /** @internal */ getMemberOverrideModifierStatus(node: ClassLikeDeclaration, member: ClassElement, memberSymbol: Symbol): MemberOverrideStatus;
        /** @internal */ isTypeParameterPossiblyReferenced(tp: TypeParameter, node: Node): boolean;
        /** @internal */ typeHasCallOrConstructSignatures(type: Type): boolean;
    }
    /** @internal */
    enum MemberOverrideStatus {
        Ok = 0,
        NeedsOverride = 1,
        HasInvalidOverride = 2
    }
    /** @internal */
    enum UnionReduction {
        None = 0,
        Literal = 1,
        Subtype = 2
    }
    /** @internal */
    enum ContextFlags {
        None = 0,
        Signature = 1,
        NoConstraints = 2,
        Completions = 4,
        SkipBindingPatterns = 8
    }
    enum NodeBuilderFlags {
        None = 0,
        NoTruncation = 1,
        WriteArrayAsGenericType = 2,
        GenerateNamesForShadowedTypeParams = 4,
        UseStructuralFallback = 8,
        ForbidIndexedAccessSymbolReferences = 16,
        WriteTypeArgumentsOfSignature = 32,
        UseFullyQualifiedType = 64,
        UseOnlyExternalAliasing = 128,
        SuppressAnyReturnType = 256,
        WriteTypeParametersInQualifiedName = 512,
        MultilineObjectLiterals = 1024,
        WriteClassExpressionAsTypeLiteral = 2048,
        UseTypeOfFunction = 4096,
        OmitParameterModifiers = 8192,
        UseAliasDefinedOutsideCurrentScope = 16384,
        UseSingleQuotesForStringLiteralType = 268435456,
        NoTypeReduction = 536870912,
        OmitThisParameter = 33554432,
        AllowThisInObjectLiteral = 32768,
        AllowQualifiedNameInPlaceOfIdentifier = 65536,
        AllowAnonymousIdentifier = 131072,
        AllowEmptyUnionOrIntersection = 262144,
        AllowEmptyTuple = 524288,
        AllowUniqueESSymbolType = 1048576,
        AllowEmptyIndexInfoType = 2097152,
        /** @internal */ WriteComputedProps = 1073741824,
        AllowNodeModulesRelativePaths = 67108864,
        /** @internal */ DoNotIncludeSymbolChain = 134217728,
        IgnoreErrors = 70221824,
        InObjectTypeLiteral = 4194304,
        InTypeAlias = 8388608,
        InInitialEntityName = 16777216
    }
    enum TypeFormatFlags {
        None = 0,
        NoTruncation = 1,
        WriteArrayAsGenericType = 2,
        UseStructuralFallback = 8,
        WriteTypeArgumentsOfSignature = 32,
        UseFullyQualifiedType = 64,
        SuppressAnyReturnType = 256,
        MultilineObjectLiterals = 1024,
        WriteClassExpressionAsTypeLiteral = 2048,
        UseTypeOfFunction = 4096,
        OmitParameterModifiers = 8192,
        UseAliasDefinedOutsideCurrentScope = 16384,
        UseSingleQuotesForStringLiteralType = 268435456,
        NoTypeReduction = 536870912,
        OmitThisParameter = 33554432,
        AllowUniqueESSymbolType = 1048576,
        AddUndefined = 131072,
        WriteArrowStyleSignature = 262144,
        InArrayType = 524288,
        InElementType = 2097152,
        InFirstTypeArgument = 4194304,
        InTypeAlias = 8388608,
        NodeBuilderFlagsMask = 848330091
    }
    enum SymbolFormatFlags {
        None = 0,
        WriteTypeParametersOrArguments = 1,
        UseOnlyExternalAliasing = 2,
        AllowAnyNodeKind = 4,
        UseAliasDefinedOutsideCurrentScope = 8,
        /** @internal */ WriteComputedProps = 16,
        /** @internal */ DoNotIncludeSymbolChain = 32
    }
    /** @internal */
    interface SymbolWalker {
        /** Note: Return values are not ordered. */
        walkType(root: Type): {
            visitedTypes: readonly Type[];
            visitedSymbols: readonly Symbol[];
        };
        /** Note: Return values are not ordered. */
        walkSymbol(root: Symbol): {
            visitedTypes: readonly Type[];
            visitedSymbols: readonly Symbol[];
        };
    }
    /** @internal */
    interface SymbolWriter {
        writeKeyword(text: string): void;
        writeOperator(text: string): void;
        writePunctuation(text: string): void;
        writeSpace(text: string): void;
        writeStringLiteral(text: string): void;
        writeParameter(text: string): void;
        writeProperty(text: string): void;
        writeSymbol(text: string, symbol: Symbol): void;
        writeLine(force?: boolean): void;
        increaseIndent(): void;
        decreaseIndent(): void;
        clear(): void;
    }
    /** @internal */
    enum SymbolAccessibility {
        Accessible = 0,
        NotAccessible = 1,
        CannotBeNamed = 2
    }
    /** @internal */
    enum SyntheticSymbolKind {
        UnionOrIntersection = 0,
        Spread = 1
    }
    enum TypePredicateKind {
        This = 0,
        Identifier = 1,
        AssertsThis = 2,
        AssertsIdentifier = 3
    }
    interface TypePredicateBase {
        kind: TypePredicateKind;
        type: Type | undefined;
    }
    interface ThisTypePredicate extends TypePredicateBase {
        kind: TypePredicateKind.This;
        parameterName: undefined;
        parameterIndex: undefined;
        type: Type;
    }
    interface IdentifierTypePredicate extends TypePredicateBase {
        kind: TypePredicateKind.Identifier;
        parameterName: string;
        parameterIndex: number;
        type: Type;
    }
    interface AssertsThisTypePredicate extends TypePredicateBase {
        kind: TypePredicateKind.AssertsThis;
        parameterName: undefined;
        parameterIndex: undefined;
        type: Type | undefined;
    }
    interface AssertsIdentifierTypePredicate extends TypePredicateBase {
        kind: TypePredicateKind.AssertsIdentifier;
        parameterName: string;
        parameterIndex: number;
        type: Type | undefined;
    }
    type TypePredicate = ThisTypePredicate | IdentifierTypePredicate | AssertsThisTypePredicate | AssertsIdentifierTypePredicate;
    /** @internal */
    type AnyImportSyntax = ImportDeclaration | ImportEqualsDeclaration;
    /** @internal */
    type AnyImportOrRequire = AnyImportSyntax | VariableDeclarationInitializedTo<RequireOrImportCall>;
    /** @internal */
    type AnyImportOrBareOrAccessedRequire = AnyImportSyntax | VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression>;
    /** @internal */
    type AliasDeclarationNode = ImportEqualsDeclaration | VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression> | ImportClause | NamespaceImport | ImportSpecifier | ExportSpecifier | NamespaceExport | BindingElementOfBareOrAccessedRequire;
    /** @internal */
    type BindingElementOfBareOrAccessedRequire = BindingElement & {
        parent: {
            parent: VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression>;
        };
    };
    /** @internal */
    type AnyImportOrRequireStatement = AnyImportSyntax | RequireVariableStatement;
    /** @internal */
    type AnyImportOrReExport = AnyImportSyntax | ExportDeclaration;
    /** @internal */
    interface ValidImportTypeNode extends ImportTypeNode {
        argument: LiteralTypeNode & {
            literal: StringLiteral;
        };
    }
    /** @internal */
    type AnyValidImportOrReExport = (ImportDeclaration | ExportDeclaration) & {
        moduleSpecifier: StringLiteral;
    } | ImportEqualsDeclaration & {
        moduleReference: ExternalModuleReference & {
            expression: StringLiteral;
        };
    } | RequireOrImportCall | ValidImportTypeNode;
    /** @internal */
    type RequireOrImportCall = CallExpression & {
        expression: Identifier;
        arguments: [
            StringLiteralLike
        ];
    };
    /** @internal */
    interface VariableDeclarationInitializedTo<T extends Expression> extends VariableDeclaration {
        readonly initializer: T;
    }
    /** @internal */
    interface RequireVariableStatement extends VariableStatement {
        readonly declarationList: RequireVariableDeclarationList;
    }
    /** @internal */
    interface RequireVariableDeclarationList extends VariableDeclarationList {
        readonly declarations: NodeArray<VariableDeclarationInitializedTo<RequireOrImportCall>>;
    }
    /** @internal */
    type LateVisibilityPaintedStatement = AnyImportSyntax | VariableStatement | ClassDeclaration | FunctionDeclaration | ModuleDeclaration | TypeAliasDeclaration | InterfaceDeclaration | EnumDeclaration;
    /** @internal */
    interface SymbolVisibilityResult {
        accessibility: SymbolAccessibility;
        aliasesToMakeVisible?: LateVisibilityPaintedStatement[];
        errorSymbolName?: string;
        errorNode?: Node;
    }
    /** @internal */
    interface SymbolAccessibilityResult extends SymbolVisibilityResult {
        errorModuleName?: string;
    }
    /** @internal */
    interface AllAccessorDeclarations {
        firstAccessor: AccessorDeclaration;
        secondAccessor: AccessorDeclaration | undefined;
        getAccessor: GetAccessorDeclaration | undefined;
        setAccessor: SetAccessorDeclaration | undefined;
    }
    /** @internal */
    interface AllDecorators {
        decorators: readonly Decorator[] | undefined;
        parameters?: readonly (readonly Decorator[] | undefined)[];
        getDecorators?: readonly Decorator[] | undefined;
        setDecorators?: readonly Decorator[] | undefined;
    }
    /**
     * Indicates how to serialize the name for a TypeReferenceNode when emitting decorator metadata
     *
     * @internal
     */
    enum TypeReferenceSerializationKind {
        Unknown = 0,
        TypeWithConstructSignatureAndValue = 1,
        VoidNullableOrNeverType = 2,
        NumberLikeType = 3,
        BigIntLikeType = 4,
        StringLikeType = 5,
        BooleanType = 6,
        ArrayLikeType = 7,
        ESSymbolType = 8,
        Promise = 9,
        TypeWithCallSignature = 10,
        ObjectType = 11
    }
    /** @internal */
    interface EmitResolver {
        hasGlobalName(name: string): boolean;
        getReferencedExportContainer(node: Identifier, prefixLocals?: boolean): SourceFile | ModuleDeclaration | EnumDeclaration | undefined;
        getReferencedImportDeclaration(node: Identifier): Declaration | undefined;
        getReferencedDeclarationWithCollidingName(node: Identifier): Declaration | undefined;
        isDeclarationWithCollidingName(node: Declaration): boolean;
        isValueAliasDeclaration(node: Node): boolean;
        isReferencedAliasDeclaration(node: Node, checkChildren?: boolean): boolean;
        isTopLevelValueImportEqualsWithEntityName(node: ImportEqualsDeclaration): boolean;
        getNodeCheckFlags(node: Node): NodeCheckFlags;
        isDeclarationVisible(node: Declaration | AnyImportSyntax): boolean;
        isLateBound(node: Declaration): node is LateBoundDeclaration;
        collectLinkedAliases(node: Identifier, setVisibility?: boolean): Node[] | undefined;
        isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;
        isRequiredInitializedParameter(node: ParameterDeclaration): boolean;
        isOptionalUninitializedParameterProperty(node: ParameterDeclaration): boolean;
        isExpandoFunctionDeclaration(node: FunctionDeclaration): boolean;
        getPropertiesOfContainerFunction(node: Declaration): Symbol[];
        createTypeOfDeclaration(declaration: AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression, enclosingDeclaration: Node, flags: NodeBuilderFlags, tracker: SymbolTracker, addUndefined?: boolean): TypeNode | undefined;
        createReturnTypeOfSignatureDeclaration(signatureDeclaration: SignatureDeclaration, enclosingDeclaration: Node, flags: NodeBuilderFlags, tracker: SymbolTracker): TypeNode | undefined;
        createTypeOfExpression(expr: Expression, enclosingDeclaration: Node, flags: NodeBuilderFlags, tracker: SymbolTracker): TypeNode | undefined;
        createLiteralConstValue(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration, tracker: SymbolTracker): Expression;
        isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags | undefined, shouldComputeAliasToMarkVisible: boolean): SymbolAccessibilityResult;
        isEntityNameVisible(entityName: EntityNameOrEntityNameExpression, enclosingDeclaration: Node): SymbolVisibilityResult;
        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;
        getReferencedValueDeclaration(reference: Identifier): Declaration | undefined;
        getTypeReferenceSerializationKind(typeName: EntityName, location?: Node): TypeReferenceSerializationKind;
        isOptionalParameter(node: ParameterDeclaration): boolean;
        moduleExportsSomeValue(moduleReferenceExpression: Expression): boolean;
        isArgumentsLocalBinding(node: Identifier): boolean;
        getExternalModuleFileFromDeclaration(declaration: ImportEqualsDeclaration | ImportDeclaration | ExportDeclaration | ModuleDeclaration | ImportTypeNode | ImportCall): SourceFile | undefined;
        getTypeReferenceDirectivesForEntityName(name: EntityNameOrEntityNameExpression): [
            specifier: string,
            mode: ResolutionMode
        ][] | undefined;
        getTypeReferenceDirectivesForSymbol(symbol: Symbol, meaning?: SymbolFlags): [
            specifier: string,
            mode: ResolutionMode
        ][] | undefined;
        isLiteralConstDeclaration(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration): boolean;
        getJsxFactoryEntity(location?: Node): EntityName | undefined;
        getJsxFragmentFactoryEntity(location?: Node): EntityName | undefined;
        getAllAccessorDeclarations(declaration: AccessorDeclaration): AllAccessorDeclarations;
        getSymbolOfExternalModuleSpecifier(node: StringLiteralLike): Symbol | undefined;
        isBindingCapturedByNode(node: Node, decl: VariableDeclaration | BindingElement): boolean;
        getDeclarationStatementsForSourceFile(node: SourceFile, flags: NodeBuilderFlags, tracker: SymbolTracker, bundled?: boolean): Statement[] | undefined;
        isImportRequiredByAugmentation(decl: ImportDeclaration): boolean;
    }
    enum SymbolFlags {
        None = 0,
        FunctionScopedVariable = 1,
        BlockScopedVariable = 2,
        Property = 4,
        EnumMember = 8,
        Function = 16,
        Class = 32,
        Interface = 64,
        ConstEnum = 128,
        RegularEnum = 256,
        ValueModule = 512,
        NamespaceModule = 1024,
        TypeLiteral = 2048,
        ObjectLiteral = 4096,
        Method = 8192,
        Constructor = 16384,
        GetAccessor = 32768,
        SetAccessor = 65536,
        Signature = 131072,
        TypeParameter = 262144,
        TypeAlias = 524288,
        ExportValue = 1048576,
        Alias = 2097152,
        Prototype = 4194304,
        ExportStar = 8388608,
        Optional = 16777216,
        Transient = 33554432,
        Assignment = 67108864,
        ModuleExports = 134217728,
        /** @internal */
        All = 67108863,
        Enum = 384,
        Variable = 3,
        Value = 111551,
        Type = 788968,
        Namespace = 1920,
        Module = 1536,
        Accessor = 98304,
        FunctionScopedVariableExcludes = 111550,
        BlockScopedVariableExcludes = 111551,
        ParameterExcludes = 111551,
        PropertyExcludes = 0,
        EnumMemberExcludes = 900095,
        FunctionExcludes = 110991,
        ClassExcludes = 899503,
        InterfaceExcludes = 788872,
        RegularEnumExcludes = 899327,
        ConstEnumExcludes = 899967,
        ValueModuleExcludes = 110735,
        NamespaceModuleExcludes = 0,
        MethodExcludes = 103359,
        GetAccessorExcludes = 46015,
        SetAccessorExcludes = 78783,
        AccessorExcludes = 13247,
        TypeParameterExcludes = 526824,
        TypeAliasExcludes = 788968,
        AliasExcludes = 2097152,
        ModuleMember = 2623475,
        ExportHasLocal = 944,
        BlockScoped = 418,
        PropertyOrAccessor = 98308,
        ClassMember = 106500,
        /** @internal */
        ExportSupportsDefaultModifier = 112,
        /** @internal */
        ExportDoesNotSupportDefaultModifier = -113,
        /** @internal */
        Classifiable = 2885600,
        /** @internal */
        LateBindingContainer = 6256
    }
    /** @internal */
    type SymbolId = number;
    interface Symbol {
        flags: SymbolFlags;
        escapedName: __String;
        declarations?: Declaration[];
        valueDeclaration?: Declaration;
        members?: SymbolTable;
        exports?: SymbolTable;
        globalExports?: SymbolTable;
        /** @internal */ id: SymbolId;
        /** @internal */ mergeId: number;
        /** @internal */ parent?: Symbol;
        /** @internal */ exportSymbol?: Symbol;
        /** @internal */ constEnumOnlyModule: boolean | undefined;
        /** @internal */ isReferenced?: SymbolFlags;
        /** @internal */ isReplaceableByMethod?: boolean;
        /** @internal */ isAssigned?: boolean;
        /** @internal */ assignmentDeclarationMembers?: Map<number, Declaration>;
    }
    interface Symbol {
        readonly name: string;
        getFlags(): SymbolFlags;
        getEscapedName(): __String;
        getName(): string;
        getDeclarations(): Declaration[] | undefined;
        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
        /** @internal */
        getContextualDocumentationComment(context: Node | undefined, checker: TypeChecker | undefined): SymbolDisplayPart[];
        getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];
        /** @internal */
        getContextualJsDocTags(context: Node | undefined, checker: TypeChecker | undefined): JSDocTagInfo[];
    }
    /** @internal */
    interface SymbolLinks {
        _symbolLinksBrand: any;
        immediateTarget?: Symbol;
        aliasTarget?: Symbol;
        target?: Symbol;
        type?: Type;
        writeType?: Type;
        nameType?: Type;
        uniqueESSymbolType?: Type;
        declaredType?: Type;
        typeParameters?: TypeParameter[];
        outerTypeParameters?: TypeParameter[];
        instantiations?: Map<string, Type>;
        aliasSymbol?: Symbol;
        aliasTypeArguments?: readonly Type[];
        inferredClassSymbol?: Map<SymbolId, TransientSymbol>;
        mapper?: TypeMapper;
        referenced?: boolean;
        constEnumReferenced?: boolean;
        containingType?: UnionOrIntersectionType;
        leftSpread?: Symbol;
        rightSpread?: Symbol;
        syntheticOrigin?: Symbol;
        isDiscriminantProperty?: boolean;
        resolvedExports?: SymbolTable;
        resolvedMembers?: SymbolTable;
        exportsChecked?: boolean;
        typeParametersChecked?: boolean;
        isDeclarationWithCollidingName?: boolean;
        bindingElement?: BindingElement;
        exportsSomeValue?: boolean;
        enumKind?: EnumKind;
        originatingImport?: ImportDeclaration | ImportCall;
        lateSymbol?: Symbol;
        specifierCache?: Map<ModeAwareCacheKey, string>;
        extendedContainers?: Symbol[];
        extendedContainersByFile?: Map<NodeId, Symbol[]>;
        variances?: VarianceFlags[];
        deferralConstituents?: Type[];
        deferralWriteConstituents?: Type[];
        deferralParent?: Type;
        cjsExportMerged?: Symbol;
        typeOnlyDeclaration?: TypeOnlyAliasDeclaration | false;
        typeOnlyExportStarMap?: UnderscoreEscapedMap<ExportDeclaration & {
            readonly isTypeOnly: true;
        }>;
        typeOnlyExportStarName?: __String;
        isConstructorDeclaredProperty?: boolean;
        tupleLabelDeclaration?: NamedTupleMember | ParameterDeclaration;
        accessibleChainCache?: Map<string, Symbol[] | undefined>;
        filteredIndexSymbolCache?: Map<string, Symbol>;
    }
    /** @internal */
    enum EnumKind {
        Numeric = 0,
        Literal = 1
    }
    /** @internal */
    enum CheckFlags {
        None = 0,
        Instantiated = 1,
        SyntheticProperty = 2,
        SyntheticMethod = 4,
        Readonly = 8,
        ReadPartial = 16,
        WritePartial = 32,
        HasNonUniformType = 64,
        HasLiteralType = 128,
        ContainsPublic = 256,
        ContainsProtected = 512,
        ContainsPrivate = 1024,
        ContainsStatic = 2048,
        Late = 4096,
        ReverseMapped = 8192,
        OptionalParameter = 16384,
        RestParameter = 32768,
        DeferredType = 65536,
        HasNeverType = 131072,
        Mapped = 262144,
        StripOptional = 524288,
        Unresolved = 1048576,
        Synthetic = 6,
        Discriminant = 192,
        Partial = 48
    }
    /** @internal */
    interface TransientSymbolLinks extends SymbolLinks {
        checkFlags: CheckFlags;
    }
    /** @internal */
    interface TransientSymbol extends Symbol {
        links: TransientSymbolLinks;
    }
    /** @internal */
    interface MappedSymbolLinks extends TransientSymbolLinks {
        mappedType: MappedType;
        keyType: Type;
    }
    /** @internal */
    interface MappedSymbol extends TransientSymbol {
        links: MappedSymbolLinks;
    }
    /** @internal */
    interface ReverseMappedSymbolLinks extends TransientSymbolLinks {
        propertyType: Type;
        mappedType: MappedType;
        constraintType: IndexType;
    }
    /** @internal */
    interface ReverseMappedSymbol extends TransientSymbol {
        links: ReverseMappedSymbolLinks;
    }
    enum InternalSymbolName {
        Call = "__call",
        Constructor = "__constructor",
        New = "__new",
        Index = "__index",
        ExportStar = "__export",
        Global = "__global",
        Missing = "__missing",
        Type = "__type",
        Object = "__object",
        JSXAttributes = "__jsxAttributes",
        Class = "__class",
        Function = "__function",
        Computed = "__computed",
        Resolving = "__resolving__",
        ExportEquals = "export=",
        Default = "default",
        This = "this"
    }
    /**
     * This represents a string whose leading underscore have been escaped by adding extra leading underscores.
     * The shape of this brand is rather unique compared to others we've used.
     * Instead of just an intersection of a string and an object, it is that union-ed
     * with an intersection of void and an object. This makes it wholly incompatible
     * with a normal string (which is good, it cannot be misused on assignment or on usage),
     * while still being comparable with a normal string via === (also good) and castable from a string.
     */
    type __String = (string & {
        __escapedIdentifier: void;
    }) | (void & {
        __escapedIdentifier: void;
    }) | InternalSymbolName;
    /** ReadonlyMap where keys are `__String`s. */
    interface ReadonlyUnderscoreEscapedMap<T> extends ReadonlyMap<__String, T> {
    }
    /** Map where keys are `__String`s. */
    interface UnderscoreEscapedMap<T> extends Map<__String, T> {
    }
    /** SymbolTable based on ES6 Map interface. */
    type SymbolTable = UnderscoreEscapedMap<Symbol>;
    /**
     * Used to track a `declare module "foo*"`-like declaration.
     *
     * @internal
     */
    interface PatternAmbientModule {
        pattern: Pattern;
        symbol: Symbol;
    }
    /** @internal */
    enum NodeCheckFlags {
        None = 0,
        TypeChecked = 1,
        LexicalThis = 2,
        CaptureThis = 4,
        CaptureNewTarget = 8,
        SuperInstance = 16,
        SuperStatic = 32,
        ContextChecked = 64,
        MethodWithSuperPropertyAccessInAsync = 128,
        MethodWithSuperPropertyAssignmentInAsync = 256,
        CaptureArguments = 512,
        EnumValuesComputed = 1024,
        LexicalModuleMergesWithClass = 2048,
        LoopWithCapturedBlockScopedBinding = 4096,
        ContainsCapturedBlockScopeBinding = 8192,
        CapturedBlockScopedBinding = 16384,
        BlockScopedBindingInLoop = 32768,
        ClassWithBodyScopedClassBinding = 65536,
        BodyScopedClassBinding = 131072,
        NeedsLoopOutParameter = 262144,
        AssignmentsMarked = 524288,
        ClassWithConstructorReference = 1048576,
        ConstructorReferenceInClass = 2097152,
        ContainsClassWithPrivateIdentifiers = 4194304,
        ContainsSuperPropertyInStaticInitializer = 8388608,
        InCheckIdentifier = 16777216
    }
    /** @internal */
    interface NodeLinks {
        flags: NodeCheckFlags;
        resolvedType?: Type;
        resolvedEnumType?: Type;
        resolvedSignature?: Signature;
        resolvedSymbol?: Symbol;
        resolvedIndexInfo?: IndexInfo;
        effectsSignature?: Signature;
        enumMemberValue?: string | number;
        isVisible?: boolean;
        containsArgumentsReference?: boolean;
        hasReportedStatementInAmbientContext?: boolean;
        jsxFlags: JsxFlags;
        resolvedJsxElementAttributesType?: Type;
        resolvedJsxElementAllAttributesType?: Type;
        resolvedJSDocType?: Type;
        switchTypes?: Type[];
        jsxNamespace?: Symbol | false;
        jsxImplicitImportContainer?: Symbol | false;
        contextFreeType?: Type;
        deferredNodes?: Set<Node>;
        capturedBlockScopeBindings?: Symbol[];
        outerTypeParameters?: TypeParameter[];
        isExhaustive?: boolean | 0;
        skipDirectInference?: true;
        declarationRequiresScopeChange?: boolean;
        serializedTypes?: Map<string, SerializedTypeEntry>;
        decoratorSignature?: Signature;
        firstSpreadIndex?: number;
        parameterInitializerContainsUndefined?: boolean;
        fakeScopeForSignatureDeclaration?: boolean;
    }
    /** @internal */
    interface SerializedTypeEntry {
        node: TypeNode;
        truncating?: boolean;
        addedLength: number;
    }
    enum TypeFlags {
        Any = 1,
        Unknown = 2,
        String = 4,
        Number = 8,
        Boolean = 16,
        Enum = 32,
        BigInt = 64,
        StringLiteral = 128,
        NumberLiteral = 256,
        BooleanLiteral = 512,
        EnumLiteral = 1024,
        BigIntLiteral = 2048,
        ESSymbol = 4096,
        UniqueESSymbol = 8192,
        Void = 16384,
        Undefined = 32768,
        Null = 65536,
        Never = 131072,
        TypeParameter = 262144,
        Object = 524288,
        Union = 1048576,
        Intersection = 2097152,
        Index = 4194304,
        IndexedAccess = 8388608,
        Conditional = 16777216,
        Substitution = 33554432,
        NonPrimitive = 67108864,
        TemplateLiteral = 134217728,
        StringMapping = 268435456,
        /** @internal */
        AnyOrUnknown = 3,
        /** @internal */
        Nullable = 98304,
        Literal = 2944,
        Unit = 109472,
        Freshable = 2976,
        StringOrNumberLiteral = 384,
        /** @internal */
        StringOrNumberLiteralOrUnique = 8576,
        /** @internal */
        DefinitelyFalsy = 117632,
        PossiblyFalsy = 117724,
        /** @internal */
        Intrinsic = 67359327,
        /** @internal */
        Primitive = 134348796,
        StringLike = 402653316,
        NumberLike = 296,
        BigIntLike = 2112,
        BooleanLike = 528,
        EnumLike = 1056,
        ESSymbolLike = 12288,
        VoidLike = 49152,
        /** @internal */
        DefinitelyNonNullable = 470302716,
        /** @internal */
        DisjointDomains = 469892092,
        UnionOrIntersection = 3145728,
        StructuredType = 3670016,
        TypeVariable = 8650752,
        InstantiableNonPrimitive = 58982400,
        InstantiablePrimitive = 406847488,
        Instantiable = 465829888,
        StructuredOrInstantiable = 469499904,
        /** @internal */
        ObjectFlagsType = 3899393,
        /** @internal */
        Simplifiable = 25165824,
        /** @internal */
        Singleton = 67358815,
        Narrowable = 536624127,
        /** @internal */
        IncludesMask = 205258751,
        /** @internal */
        IncludesMissingType = 262144,
        /** @internal */
        IncludesNonWideningType = 4194304,
        /** @internal */
        IncludesWildcard = 8388608,
        /** @internal */
        IncludesEmptyObject = 16777216,
        /** @internal */
        IncludesInstantiable = 33554432,
        /** @internal */
        NotPrimitiveUnion = 36323363
    }
    type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;
    /** @internal */
    type TypeId = number;
    interface Type {
        flags: TypeFlags;
        /** @internal */ id: TypeId;
        /** @internal */ checker: TypeChecker;
        symbol: Symbol;
        pattern?: DestructuringPattern;
        aliasSymbol?: Symbol;
        aliasTypeArguments?: readonly Type[];
        /** @internal */
        permissiveInstantiation?: Type;
        /** @internal */
        restrictiveInstantiation?: Type;
        /** @internal */
        uniqueLiteralFilledInstantiation?: Type;
        /** @internal */
        immediateBaseConstraint?: Type;
        /** @internal */
        widened?: Type;
    }
    interface Type {
        getFlags(): TypeFlags;
        getSymbol(): Symbol | undefined;
        getProperties(): Symbol[];
        getProperty(propertyName: string): Symbol | undefined;
        getApparentProperties(): Symbol[];
        getCallSignatures(): readonly Signature[];
        getConstructSignatures(): readonly Signature[];
        getStringIndexType(): Type | undefined;
        getNumberIndexType(): Type | undefined;
        getBaseTypes(): BaseType[] | undefined;
        getNonNullableType(): Type;
        /** @internal */ getNonOptionalType(): Type;
        /** @internal */ isNullableType(): boolean;
        getConstraint(): Type | undefined;
        getDefault(): Type | undefined;
        isUnion(): this is UnionType;
        isIntersection(): this is IntersectionType;
        isUnionOrIntersection(): this is UnionOrIntersectionType;
        isLiteral(): this is LiteralType;
        isStringLiteral(): this is StringLiteralType;
        isNumberLiteral(): this is NumberLiteralType;
        isTypeParameter(): this is TypeParameter;
        isClassOrInterface(): this is InterfaceType;
        isClass(): this is InterfaceType;
        isIndexType(): this is IndexType;
    }
    /** @internal */
    interface IntrinsicType extends Type {
        intrinsicName: string;
        objectFlags: ObjectFlags;
    }
    /** @internal */
    interface NullableType extends IntrinsicType {
        objectFlags: ObjectFlags;
    }
    interface FreshableType extends Type {
        freshType: FreshableType;
        regularType: FreshableType;
    }
    /** @internal */
    interface FreshableIntrinsicType extends FreshableType, IntrinsicType {
    }
    interface LiteralType extends FreshableType {
        value: string | number | PseudoBigInt;
    }
    interface UniqueESSymbolType extends Type {
        symbol: Symbol;
        escapedName: __String;
    }
    interface StringLiteralType extends LiteralType {
        value: string;
    }
    interface NumberLiteralType extends LiteralType {
        value: number;
    }
    interface BigIntLiteralType extends LiteralType {
        value: PseudoBigInt;
    }
    interface EnumType extends FreshableType {
    }
    enum ObjectFlags {
        None = 0,
        Class = 1,
        Interface = 2,
        Reference = 4,
        Tuple = 8,
        Anonymous = 16,
        Mapped = 32,
        Instantiated = 64,
        ObjectLiteral = 128,
        EvolvingArray = 256,
        ObjectLiteralPatternWithComputedProperties = 512,
        ReverseMapped = 1024,
        JsxAttributes = 2048,
        JSLiteral = 4096,
        FreshLiteral = 8192,
        ArrayLiteral = 16384,
        /** @internal */
        PrimitiveUnion = 32768,
        /** @internal */
        ContainsWideningType = 65536,
        /** @internal */
        ContainsObjectOrArrayLiteral = 131072,
        /** @internal */
        NonInferrableType = 262144,
        /** @internal */
        CouldContainTypeVariablesComputed = 524288,
        /** @internal */
        CouldContainTypeVariables = 1048576,
        ClassOrInterface = 3,
        /** @internal */
        RequiresWidening = 196608,
        /** @internal */
        PropagatingFlags = 458752,
        /** @internal */
        ObjectTypeKindMask = 1343,
        ContainsSpread = 2097152,
        ObjectRestType = 4194304,
        InstantiationExpressionType = 8388608,
        /** @internal */
        IsClassInstanceClone = 16777216,
        /** @internal */
        IdenticalBaseTypeCalculated = 33554432,
        /** @internal */
        IdenticalBaseTypeExists = 67108864,
        /** @internal */
        IsGenericTypeComputed = 2097152,
        /** @internal */
        IsGenericObjectType = 4194304,
        /** @internal */
        IsGenericIndexType = 8388608,
        /** @internal */
        IsGenericType = 12582912,
        /** @internal */
        ContainsIntersections = 16777216,
        /** @internal */
        IsUnknownLikeUnionComputed = 33554432,
        /** @internal */
        IsUnknownLikeUnion = 67108864,
        /** @internal */
        /** @internal */
        IsNeverIntersectionComputed = 16777216,
        /** @internal */
        IsNeverIntersection = 33554432
    }
    /** @internal */
    type ObjectFlagsType = NullableType | ObjectType | UnionType | IntersectionType;
    interface ObjectType extends Type {
        objectFlags: ObjectFlags;
        /** @internal */ members?: SymbolTable;
        /** @internal */ properties?: Symbol[];
        /** @internal */ callSignatures?: readonly Signature[];
        /** @internal */ constructSignatures?: readonly Signature[];
        /** @internal */ indexInfos?: readonly IndexInfo[];
        /** @internal */ objectTypeWithoutAbstractConstructSignatures?: ObjectType;
    }
    /** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */
    interface InterfaceType extends ObjectType {
        typeParameters: TypeParameter[] | undefined;
        outerTypeParameters: TypeParameter[] | undefined;
        localTypeParameters: TypeParameter[] | undefined;
        thisType: TypeParameter | undefined;
        /** @internal */
        resolvedBaseConstructorType?: Type;
        /** @internal */
        resolvedBaseTypes: BaseType[];
        /** @internal */
        baseTypesResolved?: boolean;
    }
    type BaseType = ObjectType | IntersectionType | TypeVariable;
    interface InterfaceTypeWithDeclaredMembers extends InterfaceType {
        declaredProperties: Symbol[];
        declaredCallSignatures: Signature[];
        declaredConstructSignatures: Signature[];
        declaredIndexInfos: IndexInfo[];
    }
    /**
     * Type references (ObjectFlags.Reference). When a class or interface has type parameters or
     * a "this" type, references to the class or interface are made using type references. The
     * typeArguments property specifies the types to substitute for the type parameters of the
     * class or interface and optionally includes an extra element that specifies the type to
     * substitute for "this" in the resulting instantiation. When no extra argument is present,
     * the type reference itself is substituted for "this". The typeArguments property is undefined
     * if the class or interface has no type parameters and the reference isn't specifying an
     * explicit "this" argument.
     */
    interface TypeReference extends ObjectType {
        target: GenericType;
        node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;
        /** @internal */
        mapper?: TypeMapper;
        /** @internal */
        resolvedTypeArguments?: readonly Type[];
        /** @internal */
        literalType?: TypeReference;
        /** @internal */
        cachedEquivalentBaseType?: Type;
    }
    interface TypeReference {
        typeArguments?: readonly Type[];
    }
    interface DeferredTypeReference extends TypeReference {
        /** @internal */
        node: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;
        /** @internal */
        mapper?: TypeMapper;
        /** @internal */
        instantiations?: Map<string, Type>;
    }
    /** @internal */
    enum VarianceFlags {
        Invariant = 0,
        Covariant = 1,
        Contravariant = 2,
        Bivariant = 3,
        Independent = 4,
        VarianceMask = 7,
        Unmeasurable = 8,
        Unreliable = 16,
        AllowsStructuralFallback = 24
    }
    interface GenericType extends InterfaceType, TypeReference {
        /** @internal */
        instantiations: Map<string, TypeReference>;
        /** @internal */
        variances?: VarianceFlags[];
    }
    enum ElementFlags {
        Required = 1,
        Optional = 2,
        Rest = 4,
        Variadic = 8,
        Fixed = 3,
        Variable = 12,
        NonRequired = 14,
        NonRest = 11
    }
    interface TupleType extends GenericType {
        elementFlags: readonly ElementFlags[];
        /** Number of required or variadic elements */
        minLength: number;
        /** Number of initial required or optional elements */
        fixedLength: number;
        /** True if tuple has any rest or variadic elements */
        hasRestElement: boolean;
        combinedFlags: ElementFlags;
        readonly: boolean;
        labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[];
    }
    interface TupleTypeReference extends TypeReference {
        target: TupleType;
    }
    interface UnionOrIntersectionType extends Type {
        types: Type[];
        /** @internal */
        objectFlags: ObjectFlags;
        /** @internal */
        propertyCache?: SymbolTable;
        /** @internal */
        propertyCacheWithoutObjectFunctionPropertyAugment?: SymbolTable;
        /** @internal */
        resolvedProperties: Symbol[];
        /** @internal */
        resolvedIndexType: IndexType;
        /** @internal */
        resolvedStringIndexType: IndexType;
        /** @internal */
        resolvedBaseConstraint: Type;
    }
    interface UnionType extends UnionOrIntersectionType {
        /** @internal */
        resolvedReducedType?: Type;
        /** @internal */
        regularType?: UnionType;
        /** @internal */
        origin?: Type;
        /** @internal */
        keyPropertyName?: __String;
        /** @internal */
        constituentMap?: Map<TypeId, Type>;
    }
    interface IntersectionType extends UnionOrIntersectionType {
        /** @internal */
        resolvedApparentType: Type;
    }
    type StructuredType = ObjectType | UnionType | IntersectionType;
    /** @internal */
    interface AnonymousType extends ObjectType {
        target?: AnonymousType;
        mapper?: TypeMapper;
        instantiations?: Map<string, Type>;
    }
    /** @internal */
    interface InstantiationExpressionType extends AnonymousType {
        node: NodeWithTypeArguments;
    }
    /** @internal */
    interface MappedType extends AnonymousType {
        declaration: MappedTypeNode;
        typeParameter?: TypeParameter;
        constraintType?: Type;
        nameType?: Type;
        templateType?: Type;
        modifiersType?: Type;
        resolvedApparentType?: Type;
        containsError?: boolean;
    }
    interface EvolvingArrayType extends ObjectType {
        elementType: Type;
        finalArrayType?: Type;
    }
    /** @internal */
    interface ReverseMappedType extends ObjectType {
        source: Type;
        mappedType: MappedType;
        constraintType: IndexType;
    }
    /** @internal */
    interface ResolvedType extends ObjectType, UnionOrIntersectionType {
        members: SymbolTable;
        properties: Symbol[];
        callSignatures: readonly Signature[];
        constructSignatures: readonly Signature[];
        indexInfos: readonly IndexInfo[];
    }
    /** @internal */
    interface FreshObjectLiteralType extends ResolvedType {
        regularType: ResolvedType;
    }
    /** @internal */
    interface IterationTypes {
        readonly yieldType: Type;
        readonly returnType: Type;
        readonly nextType: Type;
    }
    /** @internal */
    interface IterableOrIteratorType extends ObjectType, UnionType {
        iterationTypesOfGeneratorReturnType?: IterationTypes;
        iterationTypesOfAsyncGeneratorReturnType?: IterationTypes;
        iterationTypesOfIterable?: IterationTypes;
        iterationTypesOfIterator?: IterationTypes;
        iterationTypesOfAsyncIterable?: IterationTypes;
        iterationTypesOfAsyncIterator?: IterationTypes;
        iterationTypesOfIteratorResult?: IterationTypes;
    }
    /** @internal */
    interface PromiseOrAwaitableType extends ObjectType, UnionType {
        promiseTypeOfPromiseConstructor?: Type;
        promisedTypeOfPromise?: Type;
        awaitedTypeOfType?: Type;
    }
    /** @internal */
    interface SyntheticDefaultModuleType extends Type {
        syntheticType?: Type;
        defaultOnlyType?: Type;
    }
    interface InstantiableType extends Type {
        /** @internal */
        resolvedBaseConstraint?: Type;
        /** @internal */
        resolvedIndexType?: IndexType;
        /** @internal */
        resolvedStringIndexType?: IndexType;
    }
    interface TypeParameter extends InstantiableType {
        /**
         * Retrieve using getConstraintFromTypeParameter
         *
         * @internal
         */
        constraint?: Type;
        /** @internal */
        default?: Type;
        /** @internal */
        target?: TypeParameter;
        /** @internal */
        mapper?: TypeMapper;
        /** @internal */
        isThisType?: boolean;
        /** @internal */
        resolvedDefaultType?: Type;
    }
    /** @internal */
    enum AccessFlags {
        None = 0,
        IncludeUndefined = 1,
        NoIndexSignatures = 2,
        Writing = 4,
        CacheSymbol = 8,
        NoTupleBoundsCheck = 16,
        ExpressionPosition = 32,
        ReportDeprecated = 64,
        SuppressNoImplicitAnyError = 128,
        Contextual = 256,
        Persistent = 1
    }
    interface IndexedAccessType extends InstantiableType {
        objectType: Type;
        indexType: Type;
        /** @internal */
        accessFlags: AccessFlags;
        constraint?: Type;
        simplifiedForReading?: Type;
        simplifiedForWriting?: Type;
    }
    type TypeVariable = TypeParameter | IndexedAccessType;
    interface IndexType extends InstantiableType {
        type: InstantiableType | UnionOrIntersectionType;
        /** @internal */
        stringsOnly: boolean;
    }
    interface ConditionalRoot {
        node: ConditionalTypeNode;
        checkType: Type;
        extendsType: Type;
        isDistributive: boolean;
        inferTypeParameters?: TypeParameter[];
        outerTypeParameters?: TypeParameter[];
        instantiations?: Map<string, Type>;
        aliasSymbol?: Symbol;
        aliasTypeArguments?: Type[];
    }
    interface ConditionalType extends InstantiableType {
        root: ConditionalRoot;
        checkType: Type;
        extendsType: Type;
        resolvedTrueType?: Type;
        resolvedFalseType?: Type;
        /** @internal */
        resolvedInferredTrueType?: Type;
        /** @internal */
        resolvedDefaultConstraint?: Type;
        /** @internal */
        mapper?: TypeMapper;
        /** @internal */
        combinedMapper?: TypeMapper;
    }
    interface TemplateLiteralType extends InstantiableType {
        texts: readonly string[];
        types: readonly Type[];
    }
    interface StringMappingType extends InstantiableType {
        symbol: Symbol;
        type: Type;
    }
    interface SubstitutionType extends InstantiableType {
        objectFlags: ObjectFlags;
        baseType: Type;
        constraint: Type;
    }
    /** @internal */
    enum JsxReferenceKind {
        Component = 0,
        Function = 1,
        Mixed = 2
    }
    enum SignatureKind {
        Call = 0,
        Construct = 1
    }
    /** @internal */
    enum SignatureFlags {
        None = 0,
        HasRestParameter = 1,
        HasLiteralTypes = 2,
        Abstract = 4,
        IsInnerCallChain = 8,
        IsOuterCallChain = 16,
        IsUntypedSignatureInJSFile = 32,
        PropagatingFlags = 39,
        CallChainFlags = 24
    }
    interface Signature {
        /** @internal */ flags: SignatureFlags;
        /** @internal */ checker?: TypeChecker;
        declaration?: SignatureDeclaration | JSDocSignature;
        typeParameters?: readonly TypeParameter[];
        parameters: readonly Symbol[];
        /** @internal */
        thisParameter?: Symbol;
        /** @internal */
        resolvedReturnType?: Type;
        /** @internal */
        resolvedTypePredicate?: TypePredicate;
        /** @internal */
        minArgumentCount: number;
        /** @internal */
        resolvedMinArgumentCount?: number;
        /** @internal */
        target?: Signature;
        /** @internal */
        mapper?: TypeMapper;
        /** @internal */
        compositeSignatures?: Signature[];
        /** @internal */
        compositeKind?: TypeFlags;
        /** @internal */
        erasedSignatureCache?: Signature;
        /** @internal */
        canonicalSignatureCache?: Signature;
        /** @internal */
        baseSignatureCache?: Signature;
        /** @internal */
        optionalCallSignatureCache?: {
            inner?: Signature;
            outer?: Signature;
        };
        /** @internal */
        isolatedSignatureType?: ObjectType;
        /** @internal */
        instantiations?: Map<string, Signature>;
    }
    interface Signature {
        getDeclaration(): SignatureDeclaration;
        getTypeParameters(): TypeParameter[] | undefined;
        getParameters(): Symbol[];
        getTypeParameterAtPosition(pos: number): Type;
        getReturnType(): Type;
        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
        getJsDocTags(): JSDocTagInfo[];
    }
    enum IndexKind {
        String = 0,
        Number = 1
    }
    interface IndexInfo {
        keyType: Type;
        type: Type;
        isReadonly: boolean;
        declaration?: IndexSignatureDeclaration;
    }
    /** @internal */
    enum TypeMapKind {
        Simple = 0,
        Array = 1,
        Deferred = 2,
        Function = 3,
        Composite = 4,
        Merged = 5
    }
    /** @internal */
    type TypeMapper = {
        kind: TypeMapKind.Simple;
        source: Type;
        target: Type;
    } | {
        kind: TypeMapKind.Array;
        sources: readonly Type[];
        targets: readonly Type[] | undefined;
    } | {
        kind: TypeMapKind.Deferred;
        sources: readonly Type[];
        targets: (() => Type)[];
    } | {
        kind: TypeMapKind.Function;
        func: (t: Type) => Type;
        debugInfo?: () => string;
    } | {
        kind: TypeMapKind.Composite | TypeMapKind.Merged;
        mapper1: TypeMapper;
        mapper2: TypeMapper;
    };
    enum InferencePriority {
        None = 0,
        NakedTypeVariable = 1,
        SpeculativeTuple = 2,
        SubstituteSource = 4,
        HomomorphicMappedType = 8,
        PartialHomomorphicMappedType = 16,
        MappedTypeConstraint = 32,
        ContravariantConditional = 64,
        ReturnType = 128,
        LiteralKeyof = 256,
        NoConstraints = 512,
        AlwaysStrict = 1024,
        MaxValue = 2048,
        PriorityImpliesCombination = 416,
        Circularity = -1
    }
    /** @internal */
    interface InferenceInfo {
        typeParameter: TypeParameter;
        candidates: Type[] | undefined;
        contraCandidates: Type[] | undefined;
        inferredType?: Type;
        priority?: InferencePriority;
        topLevel: boolean;
        isFixed: boolean;
        impliedArity?: number;
    }
    /** @internal */
    enum InferenceFlags {
        None = 0,
        NoDefault = 1,
        AnyDefault = 2,
        SkippedGenericFunction = 4
    }
    /**
     * Ternary values are defined such that
     * x & y picks the lesser in the order False < Unknown < Maybe < True, and
     * x | y picks the greater in the order False < Unknown < Maybe < True.
     * Generally, Ternary.Maybe is used as the result of a relation that depends on itself, and
     * Ternary.Unknown is used as the result of a variance check that depends on itself. We make
     * a distinction because we don't want to cache circular variance check results.
     *
     * @internal
     */
    enum Ternary {
        False = 0,
        Unknown = 1,
        Maybe = 3,
        True = -1
    }
    /** @internal */
    type TypeComparer = (s: Type, t: Type, reportErrors?: boolean) => Ternary;
    /** @internal */
    interface InferenceContext {
        inferences: InferenceInfo[];
        signature?: Signature;
        flags: InferenceFlags;
        compareTypes: TypeComparer;
        mapper: TypeMapper;
        nonFixingMapper: TypeMapper;
        returnMapper?: TypeMapper;
        inferredTypeParameters?: readonly TypeParameter[];
        intraExpressionInferenceSites?: IntraExpressionInferenceSite[];
    }
    /** @internal */
    interface IntraExpressionInferenceSite {
        node: Expression | MethodDeclaration;
        type: Type;
    }
    /** @internal */
    interface WideningContext {
        parent?: WideningContext;
        propertyName?: __String;
        siblings?: Type[];
        resolvedProperties?: Symbol[];
    }
    /** @internal */
    enum AssignmentDeclarationKind {
        None = 0,
        ExportsProperty = 1,
        ModuleExports = 2,
        PrototypeProperty = 3,
        ThisProperty = 4,
        Property = 5,
        Prototype = 6,
        ObjectDefinePropertyValue = 7,
        ObjectDefinePropertyExports = 8,
        ObjectDefinePrototypeProperty = 9
    }
    interface FileExtensionInfo {
        extension: string;
        isMixedContent: boolean;
        scriptKind?: ScriptKind;
    }
    interface DiagnosticMessage {
        key: string;
        category: DiagnosticCategory;
        code: number;
        message: string;
        reportsUnnecessary?: {};
        reportsDeprecated?: {};
        /** @internal */
        elidedInCompatabilityPyramid?: boolean;
    }
    /**
     * A linked list of formatted diagnostic messages to be used as part of a multiline message.
     * It is built from the bottom up, leaving the head to be the "main" diagnostic.
     * While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,
     * the difference is that messages are all preformatted in DMC.
     */
    interface DiagnosticMessageChain {
        messageText: string;
        category: DiagnosticCategory;
        code: number;
        next?: DiagnosticMessageChain[];
    }
    interface Diagnostic extends DiagnosticRelatedInformation {
        /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */
        reportsUnnecessary?: {};
        reportsDeprecated?: {};
        source?: string;
        relatedInformation?: DiagnosticRelatedInformation[];
        /** @internal */ skippedOn?: keyof CompilerOptions;
    }
    interface DiagnosticRelatedInformation {
        category: DiagnosticCategory;
        code: number;
        file: SourceFile | undefined;
        start: number | undefined;
        length: number | undefined;
        messageText: string | DiagnosticMessageChain;
    }
    interface DiagnosticWithLocation extends Diagnostic {
        file: SourceFile;
        start: number;
        length: number;
    }
    /** @internal */
    interface DiagnosticWithDetachedLocation extends Diagnostic {
        file: undefined;
        fileName: string;
        start: number;
        length: number;
    }
    enum DiagnosticCategory {
        Warning = 0,
        Error = 1,
        Suggestion = 2,
        Message = 3
    }
    enum ModuleResolutionKind {
        Classic = 1,
        /**
         * @deprecated
         * `NodeJs` was renamed to `Node10` to better reflect the version of Node that it targets.
         * Use the new name or consider switching to a modern module resolution target.
         */
        NodeJs = 2,
        Node10 = 2,
        Node16 = 3,
        NodeNext = 99,
        Bundler = 100
    }
    enum ModuleDetectionKind {
        /**
         * Files with imports, exports and/or import.meta are considered modules
         */
        Legacy = 1,
        /**
         * Legacy, but also files with jsx under react-jsx or react-jsxdev and esm mode files under moduleResolution: node16+
         */
        Auto = 2,
        /**
         * Consider all non-declaration files modules, regardless of present syntax
         */
        Force = 3
    }
    interface PluginImport {
        name: string;
    }
    interface ProjectReference {
        /** A normalized path on disk */
        path: string;
        /** The path as the user originally wrote it */
        originalPath?: string;
        /** True if the output of this reference should be prepended to the output of this project. Only valid for --outFile compilations */
        prepend?: boolean;
        /** True if it is intended that this reference form a circularity */
        circular?: boolean;
    }
    enum WatchFileKind {
        FixedPollingInterval = 0,
        PriorityPollingInterval = 1,
        DynamicPriorityPolling = 2,
        FixedChunkSizePolling = 3,
        UseFsEvents = 4,
        UseFsEventsOnParentDirectory = 5
    }
    enum WatchDirectoryKind {
        UseFsEvents = 0,
        FixedPollingInterval = 1,
        DynamicPriorityPolling = 2,
        FixedChunkSizePolling = 3
    }
    enum PollingWatchKind {
        FixedInterval = 0,
        PriorityInterval = 1,
        DynamicPriority = 2,
        FixedChunkSize = 3
    }
    type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | ProjectReference[] | null | undefined;
    interface CompilerOptions {
        /** @internal */ all?: boolean;
        allowImportingTsExtensions?: boolean;
        allowJs?: boolean;
        /** @internal */ allowNonTsExtensions?: boolean;
        allowArbitraryExtensions?: boolean;
        allowSyntheticDefaultImports?: boolean;
        allowUmdGlobalAccess?: boolean;
        allowUnreachableCode?: boolean;
        allowUnusedLabels?: boolean;
        alwaysStrict?: boolean;
        baseUrl?: string;
        /**
         * An error if set - this should only go through the -b pipeline and not actually be observed
         *
         * @internal
         */
        build?: boolean;
        charset?: string;
        checkJs?: boolean;
        /** @internal */ configFilePath?: string;
        /**
         * configFile is set as non enumerable property so as to avoid checking of json source files
         *
         * @internal
         */
        readonly configFile?: TsConfigSourceFile;
        customConditions?: string[];
        declaration?: boolean;
        declarationMap?: boolean;
        emitDeclarationOnly?: boolean;
        declarationDir?: string;
        /** @internal */ diagnostics?: boolean;
        /** @internal */ extendedDiagnostics?: boolean;
        disableSizeLimit?: boolean;
        disableSourceOfProjectReferenceRedirect?: boolean;
        disableSolutionSearching?: boolean;
        disableReferencedProjectLoad?: boolean;
        downlevelIteration?: boolean;
        emitBOM?: boolean;
        emitDecoratorMetadata?: boolean;
        exactOptionalPropertyTypes?: boolean;
        experimentalDecorators?: boolean;
        forceConsistentCasingInFileNames?: boolean;
        /** @internal */ generateCpuProfile?: string;
        /** @internal */ generateTrace?: string;
        /** @internal */ help?: boolean;
        ignoreDeprecations?: string;
        importHelpers?: boolean;
        importsNotUsedAsValues?: ImportsNotUsedAsValues;
        /** @internal */ init?: boolean;
        inlineSourceMap?: boolean;
        inlineSources?: boolean;
        isolatedModules?: boolean;
        jsx?: JsxEmit;
        keyofStringsOnly?: boolean;
        lib?: string[];
        /** @internal */ listEmittedFiles?: boolean;
        /** @internal */ listFiles?: boolean;
        /** @internal */ explainFiles?: boolean;
        /** @internal */ listFilesOnly?: boolean;
        locale?: string;
        mapRoot?: string;
        maxNodeModuleJsDepth?: number;
        module?: ModuleKind;
        moduleResolution?: ModuleResolutionKind;
        moduleSuffixes?: string[];
        moduleDetection?: ModuleDetectionKind;
        newLine?: NewLineKind;
        noEmit?: boolean;
        /** @internal */ noEmitForJsFiles?: boolean;
        noEmitHelpers?: boolean;
        noEmitOnError?: boolean;
        noErrorTruncation?: boolean;
        noFallthroughCasesInSwitch?: boolean;
        noImplicitAny?: boolean;
        noImplicitReturns?: boolean;
        noImplicitThis?: boolean;
        noStrictGenericChecks?: boolean;
        noUnusedLocals?: boolean;
        noUnusedParameters?: boolean;
        noImplicitUseStrict?: boolean;
        noPropertyAccessFromIndexSignature?: boolean;
        assumeChangesOnlyAffectDirectDependencies?: boolean;
        noLib?: boolean;
        noResolve?: boolean;
        /** @internal */
        noDtsResolution?: boolean;
        noUncheckedIndexedAccess?: boolean;
        out?: string;
        outDir?: string;
        outFile?: string;
        paths?: MapLike<string[]>;
        /**
         * The directory of the config file that specified 'paths'. Used to resolve relative paths when 'baseUrl' is absent.
         *
         * @internal
         */
        pathsBasePath?: string;
        /** @internal */ plugins?: PluginImport[];
        preserveConstEnums?: boolean;
        noImplicitOverride?: boolean;
        preserveSymlinks?: boolean;
        preserveValueImports?: boolean;
        /** @internal */ preserveWatchOutput?: boolean;
        project?: string;
        /** @internal */ pretty?: boolean;
        reactNamespace?: string;
        jsxFactory?: string;
        jsxFragmentFactory?: string;
        jsxImportSource?: string;
        composite?: boolean;
        incremental?: boolean;
        tsBuildInfoFile?: string;
        removeComments?: boolean;
        resolvePackageJsonExports?: boolean;
        resolvePackageJsonImports?: boolean;
        rootDir?: string;
        rootDirs?: string[];
        skipLibCheck?: boolean;
        skipDefaultLibCheck?: boolean;
        sourceMap?: boolean;
        sourceRoot?: string;
        strict?: boolean;
        strictFunctionTypes?: boolean;
        strictBindCallApply?: boolean;
        strictNullChecks?: boolean;
        strictPropertyInitialization?: boolean;
        stripInternal?: boolean;
        suppressExcessPropertyErrors?: boolean;
        suppressImplicitAnyIndexErrors?: boolean;
        /** @internal */ suppressOutputPathCheck?: boolean;
        target?: ScriptTarget;
        traceResolution?: boolean;
        useUnknownInCatchVariables?: boolean;
        resolveJsonModule?: boolean;
        types?: string[];
        /** Paths used to compute primary types search locations */
        typeRoots?: string[];
        verbatimModuleSyntax?: boolean;
        /** @internal */ version?: boolean;
        /** @internal */ watch?: boolean;
        esModuleInterop?: boolean;
        /** @internal */ showConfig?: boolean;
        useDefineForClassFields?: boolean;
        defines?: MapLike<any>;
        emitReflection?: boolean;
        reorderFiles?: boolean;
        [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;
    }
    interface WatchOptions {
        watchFile?: WatchFileKind;
        watchDirectory?: WatchDirectoryKind;
        fallbackPolling?: PollingWatchKind;
        synchronousWatchDirectory?: boolean;
        excludeDirectories?: string[];
        excludeFiles?: string[];
        [option: string]: CompilerOptionsValue | undefined;
    }
    interface TypeAcquisition {
        enable?: boolean;
        include?: string[];
        exclude?: string[];
        disableFilenameBasedTypeAcquisition?: boolean;
        [option: string]: CompilerOptionsValue | undefined;
    }
    enum ModuleKind {
        None = 0,
        CommonJS = 1,
        AMD = 2,
        UMD = 3,
        System = 4,
        ES2015 = 5,
        ES2020 = 6,
        ES2022 = 7,
        ESNext = 99,
        Node16 = 100,
        NodeNext = 199
    }
    enum JsxEmit {
        None = 0,
        Preserve = 1,
        React = 2,
        ReactNative = 3,
        ReactJSX = 4,
        ReactJSXDev = 5
    }
    enum ImportsNotUsedAsValues {
        Remove = 0,
        Preserve = 1,
        Error = 2
    }
    enum NewLineKind {
        CarriageReturnLineFeed = 0,
        LineFeed = 1
    }
    interface LineAndCharacter {
        /** 0-based. */
        line: number;
        character: number;
    }
    enum ScriptKind {
        Unknown = 0,
        JS = 1,
        JSX = 2,
        TS = 3,
        TSX = 4,
        External = 5,
        JSON = 6,
        /**
         * Used on extensions that doesn't define the ScriptKind but the content defines it.
         * Deferred extensions are going to be included in all project contexts.
         */
        Deferred = 7
    }
    enum ScriptTarget {
        ES3 = 0,
        ES5 = 1,
        ES2015 = 2,
        ES2016 = 3,
        ES2017 = 4,
        ES2018 = 5,
        ES2019 = 6,
        ES2020 = 7,
        ES2021 = 8,
        ES2022 = 9,
        ESNext = 99,
        JSON = 100,
        Latest = 99
    }
    enum LanguageVariant {
        Standard = 0,
        JSX = 1
    }
    /** Either a parsed command line or a parsed tsconfig.json */
    interface ParsedCommandLine {
        options: CompilerOptions;
        typeAcquisition?: TypeAcquisition;
        fileNames: string[];
        projectReferences?: readonly ProjectReference[];
        watchOptions?: WatchOptions;
        raw?: any;
        errors: Diagnostic[];
        wildcardDirectories?: MapLike<WatchDirectoryFlags>;
        compileOnSave?: boolean;
    }
    enum WatchDirectoryFlags {
        None = 0,
        Recursive = 1
    }
    /** @internal */
    interface ConfigFileSpecs {
        filesSpecs: readonly string[] | undefined;
        /**
         * Present to report errors (user specified specs), validatedIncludeSpecs are used for file name matching
         */
        includeSpecs: readonly string[] | undefined;
        /**
         * Present to report errors (user specified specs), validatedExcludeSpecs are used for file name matching
         */
        excludeSpecs: readonly string[] | undefined;
        validatedFilesSpec: readonly string[] | undefined;
        validatedIncludeSpecs: readonly string[] | undefined;
        validatedExcludeSpecs: readonly string[] | undefined;
        pathPatterns: readonly (string | Pattern)[] | undefined;
        isDefaultIncludeSpec: boolean;
    }
    /** @internal */
    type RequireResult<T = {}> = {
        module: T;
        modulePath?: string;
        error: undefined;
    } | {
        module: undefined;
        modulePath?: undefined;
        error: {
            stack?: string;
            message?: string;
        };
    };
    interface CreateProgramOptions {
        rootNames: readonly string[];
        options: CompilerOptions;
        projectReferences?: readonly ProjectReference[];
        host?: CompilerHost;
        oldProgram?: Program;
        configFileParsingDiagnostics?: readonly Diagnostic[];
        /** @internal */
        typeScriptVersion?: string;
    }
    /** @internal */
    interface CommandLineOptionBase {
        name: string;
        type: "string" | "number" | "boolean" | "object" | "list" | "listOrElement" | Map<string, number | string>;
        isFilePath?: boolean;
        shortName?: string;
        description?: DiagnosticMessage;
        defaultValueDescription?: string | number | boolean | DiagnosticMessage;
        paramType?: DiagnosticMessage;
        isTSConfigOnly?: boolean;
        isCommandLineOnly?: boolean;
        showInSimplifiedHelpView?: boolean;
        category?: DiagnosticMessage;
        strictFlag?: true;
        affectsSourceFile?: true;
        affectsModuleResolution?: true;
        affectsBindDiagnostics?: true;
        affectsSemanticDiagnostics?: true;
        affectsEmit?: true;
        affectsProgramStructure?: true;
        affectsDeclarationPath?: true;
        affectsBuildInfo?: true;
        transpileOptionValue?: boolean | undefined;
        extraValidation?: (value: CompilerOptionsValue) => [
            DiagnosticMessage,
            ...string[]
        ] | undefined;
    }
    /** @internal */
    interface CommandLineOptionOfStringType extends CommandLineOptionBase {
        type: "string";
        defaultValueDescription?: string | undefined | DiagnosticMessage;
    }
    /** @internal */
    interface CommandLineOptionOfNumberType extends CommandLineOptionBase {
        type: "number";
        defaultValueDescription: number | undefined | DiagnosticMessage;
    }
    /** @internal */
    interface CommandLineOptionOfBooleanType extends CommandLineOptionBase {
        type: "boolean";
        defaultValueDescription: boolean | undefined | DiagnosticMessage;
    }
    /** @internal */
    interface CommandLineOptionOfCustomType extends CommandLineOptionBase {
        type: Map<string, number | string>;
        defaultValueDescription: number | string | undefined | DiagnosticMessage;
        deprecatedKeys?: Set<string>;
    }
    /** @internal */
    interface AlternateModeDiagnostics {
        diagnostic: DiagnosticMessage;
        getOptionsNameMap: () => OptionsNameMap;
    }
    /** @internal */
    interface DidYouMeanOptionsDiagnostics {
        alternateMode?: AlternateModeDiagnostics;
        optionDeclarations: CommandLineOption[];
        unknownOptionDiagnostic: DiagnosticMessage;
        unknownDidYouMeanDiagnostic: DiagnosticMessage;
    }
    /** @internal */
    interface TsConfigOnlyOption extends CommandLineOptionBase {
        type: "object";
        elementOptions?: Map<string, CommandLineOption>;
        extraKeyDiagnostics?: DidYouMeanOptionsDiagnostics;
    }
    /** @internal */
    interface CommandLineOptionOfListType extends CommandLineOptionBase {
        type: "list" | "listOrElement";
        element: CommandLineOptionOfCustomType | CommandLineOptionOfStringType | CommandLineOptionOfNumberType | CommandLineOptionOfBooleanType | TsConfigOnlyOption;
        listPreserveFalsyValues?: boolean;
    }
    /** @internal */
    type CommandLineOption = CommandLineOptionOfCustomType | CommandLineOptionOfStringType | CommandLineOptionOfNumberType | CommandLineOptionOfBooleanType | TsConfigOnlyOption | CommandLineOptionOfListType;
    /** @internal */
    enum CharacterCodes {
        nullCharacter = 0,
        maxAsciiCharacter = 127,
        lineFeed = 10,
        carriageReturn = 13,
        lineSeparator = 8232,
        paragraphSeparator = 8233,
        nextLine = 133,
        space = 32,
        nonBreakingSpace = 160,
        enQuad = 8192,
        emQuad = 8193,
        enSpace = 8194,
        emSpace = 8195,
        threePerEmSpace = 8196,
        fourPerEmSpace = 8197,
        sixPerEmSpace = 8198,
        figureSpace = 8199,
        punctuationSpace = 8200,
        thinSpace = 8201,
        hairSpace = 8202,
        zeroWidthSpace = 8203,
        narrowNoBreakSpace = 8239,
        ideographicSpace = 12288,
        mathematicalSpace = 8287,
        ogham = 5760,
        _ = 95,
        $ = 36,
        _0 = 48,
        _1 = 49,
        _2 = 50,
        _3 = 51,
        _4 = 52,
        _5 = 53,
        _6 = 54,
        _7 = 55,
        _8 = 56,
        _9 = 57,
        a = 97,
        b = 98,
        c = 99,
        d = 100,
        e = 101,
        f = 102,
        g = 103,
        h = 104,
        i = 105,
        j = 106,
        k = 107,
        l = 108,
        m = 109,
        n = 110,
        o = 111,
        p = 112,
        q = 113,
        r = 114,
        s = 115,
        t = 116,
        u = 117,
        v = 118,
        w = 119,
        x = 120,
        y = 121,
        z = 122,
        A = 65,
        B = 66,
        C = 67,
        D = 68,
        E = 69,
        F = 70,
        G = 71,
        H = 72,
        I = 73,
        J = 74,
        K = 75,
        L = 76,
        M = 77,
        N = 78,
        O = 79,
        P = 80,
        Q = 81,
        R = 82,
        S = 83,
        T = 84,
        U = 85,
        V = 86,
        W = 87,
        X = 88,
        Y = 89,
        Z = 90,
        ampersand = 38,
        asterisk = 42,
        at = 64,
        backslash = 92,
        backtick = 96,
        bar = 124,
        caret = 94,
        closeBrace = 125,
        closeBracket = 93,
        closeParen = 41,
        colon = 58,
        comma = 44,
        dot = 46,
        doubleQuote = 34,
        equals = 61,
        exclamation = 33,
        greaterThan = 62,
        hash = 35,
        lessThan = 60,
        minus = 45,
        openBrace = 123,
        openBracket = 91,
        openParen = 40,
        percent = 37,
        plus = 43,
        question = 63,
        semicolon = 59,
        singleQuote = 39,
        slash = 47,
        tilde = 126,
        backspace = 8,
        formFeed = 12,
        byteOrderMark = 65279,
        tab = 9,
        verticalTab = 11
    }
    interface ModuleResolutionHost {
        fileExists(fileName: string): boolean;
        readFile(fileName: string): string | undefined;
        trace?(s: string): void;
        directoryExists?(directoryName: string): boolean;
        /**
         * Resolve a symbolic link.
         * @see https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options
         */
        realpath?(path: string): string;
        getCurrentDirectory?(): string;
        getDirectories?(path: string): string[];
        useCaseSensitiveFileNames?: boolean | (() => boolean) | undefined;
    }
    /**
     * Used by services to specify the minimum host area required to set up source files under any compilation settings
     */
    interface MinimalResolutionCacheHost extends ModuleResolutionHost {
        getCompilationSettings(): CompilerOptions;
        getCompilerHost?(): CompilerHost | undefined;
    }
    /**
     * Represents the result of module resolution.
     * Module resolution will pick up tsx/jsx/js files even if '--jsx' and '--allowJs' are turned off.
     * The Program will then filter results based on these flags.
     *
     * Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.
     */
    interface ResolvedModule {
        /** Path of the file the module was resolved to. */
        resolvedFileName: string;
        /** True if `resolvedFileName` comes from `node_modules`. */
        isExternalLibraryImport?: boolean;
        /**
         * True if the original module reference used a .ts extension to refer directly to a .ts file,
         * which should produce an error during checking if emit is enabled.
         */
        resolvedUsingTsExtension?: boolean;
    }
    /**
     * ResolvedModule with an explicitly provided `extension` property.
     * Prefer this over `ResolvedModule`.
     * If changing this, remember to change `moduleResolutionIsEqualTo`.
     */
    interface ResolvedModuleFull extends ResolvedModule {
        /**
         * @internal
         * This is a file name with preserved original casing, not a normalized `Path`.
         */
        readonly originalPath?: string;
        /**
         * Extension of resolvedFileName. This must match what's at the end of resolvedFileName.
         * This is optional for backwards-compatibility, but will be added if not provided.
         */
        extension: string;
        packageId?: PackageId;
    }
    /**
     * Unique identifier with a package name and version.
     * If changing this, remember to change `packageIdIsEqual`.
     */
    interface PackageId {
        /**
         * Name of the package.
         * Should not include `@types`.
         * If accessing a non-index file, this should include its name e.g. "foo/bar".
         */
        name: string;
        /**
         * Name of a submodule within this package.
         * May be "".
         */
        subModuleName: string;
        /** Version of the package, e.g. "1.2.3" */
        version: string;
    }
    enum Extension {
        Ts = ".ts",
        Tsx = ".tsx",
        Dts = ".d.ts",
        Js = ".js",
        Jsx = ".jsx",
        Json = ".json",
        TsBuildInfo = ".tsbuildinfo",
        Mjs = ".mjs",
        Mts = ".mts",
        Dmts = ".d.mts",
        Cjs = ".cjs",
        Cts = ".cts",
        Dcts = ".d.cts"
    }
    interface ResolvedModuleWithFailedLookupLocations {
        readonly resolvedModule: ResolvedModuleFull | undefined;
        /** @internal */
        failedLookupLocations?: string[];
        /** @internal */
        affectingLocations?: string[];
        /** @internal */
        resolutionDiagnostics?: Diagnostic[];
        /**
         * @internal
         * Used to issue a diagnostic if typings for a non-relative import couldn't be found
         * while respecting package.json `exports`, but were found when disabling `exports`.
         */
        node10Result?: string;
    }
    interface ResolvedTypeReferenceDirective {
        primary: boolean;
        resolvedFileName: string | undefined;
        /**
         * @internal
         * The location of the symlink to the .d.ts file we found, if `resolvedFileName` was the realpath.
         * This is a file name with preserved original casing, not a normalized `Path`.
         */
        originalPath?: string;
        packageId?: PackageId;
        /** True if `resolvedFileName` comes from `node_modules`. */
        isExternalLibraryImport?: boolean;
    }
    interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
        readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;
        /** @internal */ failedLookupLocations?: string[];
        /** @internal */ affectingLocations?: string[];
        /** @internal */ resolutionDiagnostics?: Diagnostic[];
    }
    /** @internal */
    type HasInvalidatedResolutions = (sourceFile: Path) => boolean;
    /** @internal */
    type HasChangedAutomaticTypeDirectiveNames = () => boolean;
    interface CompilerHost extends ModuleResolutionHost {
        getSourceFile(fileName: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;
        getSourceFileByPath?(fileName: string, path: Path, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;
        getCancellationToken?(): CancellationToken;
        getDefaultLibFileName(options: CompilerOptions): string;
        getDefaultLibLocation?(): string;
        writeFile: WriteFileCallback;
        getCurrentDirectory(): string;
        getCanonicalFileName(fileName: string): string;
        useCaseSensitiveFileNames(): boolean;
        getNewLine(): string;
        readDirectory?(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): string[];
        /** @deprecated supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext */
        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
        /**
         * Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it
         */
        getModuleResolutionCache?(): ModuleResolutionCache | undefined;
        /**
         * @deprecated supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext
         *
         * This method is a companion for 'resolveModuleNames' and is used to resolve 'types' references to actual type declaration files
         */
        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];
        resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
        resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
        getEnvironmentVariable?(name: string): string | undefined;
        /** @internal */ onReleaseOldSourceFile?(oldSourceFile: SourceFile, oldOptions: CompilerOptions, hasSourceFileByPath: boolean): void;
        /** @internal */ onReleaseParsedCommandLine?(configFileName: string, oldResolvedRef: ResolvedProjectReference | undefined, optionOptions: CompilerOptions): void;
        /** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */
        hasInvalidatedResolutions?(filePath: Path): boolean;
        /** @internal */ hasChangedAutomaticTypeDirectiveNames?: HasChangedAutomaticTypeDirectiveNames;
        createHash?(data: string): string;
        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
        /** @internal */ useSourceOfProjectReferenceRedirect?(): boolean;
        /** @internal */ createDirectory?(directory: string): void;
        /** @internal */ getSymlinkCache?(): SymlinkCache;
        /** @internal */ storeFilesChangingSignatureDuringEmit?: boolean;
        /** @internal */ getBuildInfo?(fileName: string, configFilePath: string | undefined): BuildInfo | undefined;
    }
    /** true if --out otherwise source file name *
     * @internal
     */
    type SourceOfProjectReferenceRedirect = string | true;
    /** @internal */
    interface ResolvedProjectReferenceCallbacks {
        getSourceOfProjectReferenceRedirect(fileName: string): SourceOfProjectReferenceRedirect | undefined;
        forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined;
    }
    /** @internal */
    enum TransformFlags {
        None = 0,
        ContainsTypeScript = 1,
        ContainsJsx = 2,
        ContainsESNext = 4,
        ContainsES2022 = 8,
        ContainsES2021 = 16,
        ContainsES2020 = 32,
        ContainsES2019 = 64,
        ContainsES2018 = 128,
        ContainsES2017 = 256,
        ContainsES2016 = 512,
        ContainsES2015 = 1024,
        ContainsGenerator = 2048,
        ContainsDestructuringAssignment = 4096,
        ContainsTypeScriptClassSyntax = 8192,
        ContainsLexicalThis = 16384,
        ContainsRestOrSpread = 32768,
        ContainsObjectRestOrSpread = 65536,
        ContainsComputedPropertyName = 131072,
        ContainsBlockScopedBinding = 262144,
        ContainsBindingPattern = 524288,
        ContainsYield = 1048576,
        ContainsAwait = 2097152,
        ContainsHoistedDeclarationOrCompletion = 4194304,
        ContainsDynamicImport = 8388608,
        ContainsClassFields = 16777216,
        ContainsDecorators = 33554432,
        ContainsPossibleTopLevelAwait = 67108864,
        ContainsLexicalSuper = 134217728,
        ContainsUpdateExpressionForIdentifier = 268435456,
        ContainsPrivateIdentifierInExpression = 536870912,
        HasComputedFlags = -2147483648,
        AssertTypeScript = 1,
        AssertJsx = 2,
        AssertESNext = 4,
        AssertES2022 = 8,
        AssertES2021 = 16,
        AssertES2020 = 32,
        AssertES2019 = 64,
        AssertES2018 = 128,
        AssertES2017 = 256,
        AssertES2016 = 512,
        AssertES2015 = 1024,
        AssertGenerator = 2048,
        AssertDestructuringAssignment = 4096,
        OuterExpressionExcludes = -2147483648,
        PropertyAccessExcludes = -2147483648,
        NodeExcludes = -2147483648,
        ArrowFunctionExcludes = -2072174592,
        FunctionExcludes = -1937940480,
        ConstructorExcludes = -1937948672,
        MethodOrAccessorExcludes = -2005057536,
        PropertyExcludes = -2013249536,
        ClassExcludes = -2147344384,
        ModuleExcludes = -1941676032,
        TypeExcludes = -2,
        ObjectLiteralExcludes = -2147278848,
        ArrayLiteralOrCallOrNewExcludes = -2147450880,
        VariableDeclarationListExcludes = -2146893824,
        ParameterExcludes = -2147483648,
        CatchClauseExcludes = -2147418112,
        BindingPatternExcludes = -2147450880,
        ContainsLexicalThisOrSuper = 134234112,
        PropertyNamePropagatingFlags = 134234112
    }
    interface SourceMapRange extends TextRange {
        source?: SourceMapSource;
    }
    interface SourceMapSource {
        fileName: string;
        text: string;
        /** @internal */ lineMap: readonly number[];
        skipTrivia?: (pos: number) => number;
    }
    interface SourceMapSource {
        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
    }
    /** @internal */
    interface EmitNode {
        annotatedNodes?: Node[];
        flags: EmitFlags;
        internalFlags: InternalEmitFlags;
        leadingComments?: SynthesizedComment[];
        trailingComments?: SynthesizedComment[];
        commentRange?: TextRange;
        sourceMapRange?: SourceMapRange;
        tokenSourceMapRanges?: (SourceMapRange | undefined)[];
        constantValue?: string | number;
        externalHelpersModuleName?: Identifier;
        externalHelpers?: boolean;
        helpers?: EmitHelper[];
        startsOnNewLine?: boolean;
        snippetElement?: SnippetElement;
        typeNode?: TypeNode;
        classThis?: Identifier;
        identifierTypeArguments?: NodeArray<TypeNode | TypeParameterDeclaration>;
        autoGenerate: AutoGenerateInfo | undefined;
        generatedImportReference?: ImportSpecifier;
    }
    /** @internal */
    type SnippetElement = TabStop | Placeholder;
    /** @internal */
    interface TabStop {
        kind: SnippetKind.TabStop;
        order: number;
    }
    /** @internal */
    interface Placeholder {
        kind: SnippetKind.Placeholder;
        order: number;
    }
    /** @internal */
    enum SnippetKind {
        TabStop = 0,
        Placeholder = 1,
        Choice = 2,
        Variable = 3
    }
    enum EmitFlags {
        None = 0,
        SingleLine = 1,
        MultiLine = 2,
        AdviseOnEmitNode = 4,
        NoSubstitution = 8,
        CapturesThis = 16,
        NoLeadingSourceMap = 32,
        NoTrailingSourceMap = 64,
        NoSourceMap = 96,
        NoNestedSourceMaps = 128,
        NoTokenLeadingSourceMaps = 256,
        NoTokenTrailingSourceMaps = 512,
        NoTokenSourceMaps = 768,
        NoLeadingComments = 1024,
        NoTrailingComments = 2048,
        NoComments = 3072,
        NoNestedComments = 4096,
        HelperName = 8192,
        ExportName = 16384,
        LocalName = 32768,
        InternalName = 65536,
        Indented = 131072,
        NoIndentation = 262144,
        AsyncFunctionBody = 524288,
        ReuseTempVariableScope = 1048576,
        CustomPrologue = 2097152,
        NoHoisting = 4194304,
        HasEndOfDeclarationMarker = 8388608,
        Iterator = 16777216,
        NoAsciiEscaping = 33554432
    }
    /** @internal */
    enum InternalEmitFlags {
        None = 0,
        TypeScriptClassWrapper = 1,
        NeverApplyImportHelper = 2,
        IgnoreSourceNewlines = 4,
        Immutable = 8,
        IndirectCall = 16,
        TransformPrivateStaticElements = 32
    }
    interface EmitHelperBase {
        readonly name: string;
        readonly scoped: boolean;
        readonly text: string | ((node: EmitHelperUniqueNameCallback) => string);
        readonly priority?: number;
        readonly dependencies?: EmitHelper[];
    }
    interface ScopedEmitHelper extends EmitHelperBase {
        readonly scoped: true;
    }
    interface UnscopedEmitHelper extends EmitHelperBase {
        readonly scoped: false;
        /** @internal */
        readonly importName?: string;
        readonly text: string;
    }
    type EmitHelper = ScopedEmitHelper | UnscopedEmitHelper;
    /** @internal */
    type UniqueNameHandler = (baseName: string, checkFn?: (name: string) => boolean, optimistic?: boolean) => string;
    type EmitHelperUniqueNameCallback = (name: string) => string;
    /**
     * Used by the checker, this enum keeps track of external emit helpers that should be type
     * checked.
     *
     * @internal
     */
    enum ExternalEmitHelpers {
        Extends = 1,
        Assign = 2,
        Rest = 4,
        Decorate = 8,
        ESDecorateAndRunInitializers = 8,
        Metadata = 16,
        Param = 32,
        Awaiter = 64,
        Generator = 128,
        Values = 256,
        Read = 512,
        SpreadArray = 1024,
        Await = 2048,
        AsyncGenerator = 4096,
        AsyncDelegator = 8192,
        AsyncValues = 16384,
        ExportStar = 32768,
        ImportStar = 65536,
        ImportDefault = 131072,
        MakeTemplateObject = 262144,
        ClassPrivateFieldGet = 524288,
        ClassPrivateFieldSet = 1048576,
        ClassPrivateFieldIn = 2097152,
        CreateBinding = 4194304,
        SetFunctionName = 8388608,
        PropKey = 16777216,
        FirstEmitHelper = 1,
        LastEmitHelper = 16777216,
        ForOfIncludes = 256,
        ForAwaitOfIncludes = 16384,
        AsyncGeneratorIncludes = 6144,
        AsyncDelegatorIncludes = 26624,
        SpreadIncludes = 1536
    }
    enum EmitHint {
        SourceFile = 0,
        Expression = 1,
        IdentifierName = 2,
        MappedTypeParameter = 3,
        Unspecified = 4,
        EmbeddedStatement = 5,
        JsxAttributeValue = 6
    }
    /** @internal */
    interface SourceFileMayBeEmittedHost {
        getCompilerOptions(): CompilerOptions;
        isSourceFileFromExternalLibrary(file: SourceFile): boolean;
        getResolvedProjectReferenceToRedirect(fileName: string): ResolvedProjectReference | undefined;
        isSourceOfProjectReferenceRedirect(fileName: string): boolean;
    }
    /** @internal */
    interface EmitHost extends ScriptReferenceHost, ModuleSpecifierResolutionHost, SourceFileMayBeEmittedHost {
        getSourceFiles(): readonly SourceFile[];
        useCaseSensitiveFileNames(): boolean;
        getCurrentDirectory(): string;
        getTypeChecker?(): TypeChecker;
        getLibFileFromReference(ref: FileReference): SourceFile | undefined;
        getCommonSourceDirectory(): string;
        getCanonicalFileName(fileName: string): string;
        isEmitBlocked(emitFileName: string): boolean;
        /** @deprecated */ getPrependNodes(): readonly (InputFiles | UnparsedSource)[];
        writeFile: WriteFileCallback;
        getBuildInfo(bundle: BundleBuildInfo | undefined): BuildInfo | undefined;
        getSourceFileFromReference: Program["getSourceFileFromReference"];
        readonly redirectTargetsMap: RedirectTargetsMap;
        createHash?(data: string): string;
    }
    /** @internal */
    interface PropertyDescriptorAttributes {
        enumerable?: boolean | Expression;
        configurable?: boolean | Expression;
        writable?: boolean | Expression;
        value?: Expression;
        get?: Expression;
        set?: Expression;
    }
    enum OuterExpressionKinds {
        Parentheses = 1,
        TypeAssertions = 2,
        NonNullAssertions = 4,
        PartiallyEmittedExpressions = 8,
        Assertions = 6,
        All = 15,
        ExcludeJSDocTypeAssertion = 16
    }
    /** @internal */
    type OuterExpression = ParenthesizedExpression | TypeAssertion | SatisfiesExpression | AsExpression | NonNullExpression | PartiallyEmittedExpression;
    /** @internal */
    type WrappedExpression<T extends Expression> = OuterExpression & {
        readonly expression: WrappedExpression<T>;
    } | T;
    type TypeOfTag = "undefined" | "number" | "bigint" | "boolean" | "string" | "symbol" | "object" | "function";
    /** @internal */
    interface CallBinding {
        target: LeftHandSideExpression;
        thisArg: Expression;
    }
    /** @internal */
    interface ParenthesizerRules {
        getParenthesizeLeftSideOfBinaryForOperator(binaryOperator: SyntaxKind): (leftSide: Expression) => Expression;
        getParenthesizeRightSideOfBinaryForOperator(binaryOperator: SyntaxKind): (rightSide: Expression) => Expression;
        parenthesizeLeftSideOfBinary(binaryOperator: SyntaxKind, leftSide: Expression): Expression;
        parenthesizeRightSideOfBinary(binaryOperator: SyntaxKind, leftSide: Expression | undefined, rightSide: Expression): Expression;
        parenthesizeExpressionOfComputedPropertyName(expression: Expression): Expression;
        parenthesizeConditionOfConditionalExpression(condition: Expression): Expression;
        parenthesizeBranchOfConditionalExpression(branch: Expression): Expression;
        parenthesizeExpressionOfExportDefault(expression: Expression): Expression;
        parenthesizeExpressionOfNew(expression: Expression): LeftHandSideExpression;
        parenthesizeLeftSideOfAccess(expression: Expression, optionalChain?: boolean): LeftHandSideExpression;
        parenthesizeOperandOfPostfixUnary(operand: Expression): LeftHandSideExpression;
        parenthesizeOperandOfPrefixUnary(operand: Expression): UnaryExpression;
        parenthesizeExpressionsOfCommaDelimitedList(elements: readonly Expression[]): NodeArray<Expression>;
        parenthesizeExpressionForDisallowedComma(expression: Expression): Expression;
        parenthesizeExpressionOfExpressionStatement(expression: Expression): Expression;
        parenthesizeConciseBodyOfArrowFunction(body: Expression): Expression;
        parenthesizeConciseBodyOfArrowFunction(body: ConciseBody): ConciseBody;
        parenthesizeCheckTypeOfConditionalType(type: TypeNode): TypeNode;
        parenthesizeExtendsTypeOfConditionalType(type: TypeNode): TypeNode;
        parenthesizeOperandOfTypeOperator(type: TypeNode): TypeNode;
        parenthesizeOperandOfReadonlyTypeOperator(type: TypeNode): TypeNode;
        parenthesizeNonArrayTypeOfPostfixType(type: TypeNode): TypeNode;
        parenthesizeElementTypesOfTupleType(types: readonly (TypeNode | NamedTupleMember)[]): NodeArray<TypeNode>;
        parenthesizeElementTypeOfTupleType(type: TypeNode | NamedTupleMember): TypeNode | NamedTupleMember;
        parenthesizeTypeOfOptionalType(type: TypeNode): TypeNode;
        parenthesizeConstituentTypeOfUnionType(type: TypeNode): TypeNode;
        parenthesizeConstituentTypesOfUnionType(constituents: readonly TypeNode[]): NodeArray<TypeNode>;
        parenthesizeConstituentTypeOfIntersectionType(type: TypeNode): TypeNode;
        parenthesizeConstituentTypesOfIntersectionType(constituents: readonly TypeNode[]): NodeArray<TypeNode>;
        parenthesizeLeadingTypeArgument(typeNode: TypeNode): TypeNode;
        parenthesizeTypeArguments(typeParameters: readonly TypeNode[] | undefined): NodeArray<TypeNode> | undefined;
    }
    /** @internal */
    interface NodeConverters {
        convertToFunctionBlock(node: ConciseBody, multiLine?: boolean): Block;
        convertToFunctionExpression(node: FunctionDeclaration): FunctionExpression;
        convertToArrayAssignmentElement(element: ArrayBindingOrAssignmentElement): Expression;
        convertToObjectAssignmentElement(element: ObjectBindingOrAssignmentElement): ObjectLiteralElementLike;
        convertToAssignmentPattern(node: BindingOrAssignmentPattern): AssignmentPattern;
        convertToObjectAssignmentPattern(node: ObjectBindingOrAssignmentPattern): ObjectLiteralExpression;
        convertToArrayAssignmentPattern(node: ArrayBindingOrAssignmentPattern): ArrayLiteralExpression;
        convertToAssignmentElementTarget(node: BindingOrAssignmentElementTarget): Expression;
    }
    /** @internal */
    interface GeneratedNamePart {
        /** an additional prefix to insert before the text sourced from `node` */
        prefix?: string;
        node: Identifier | PrivateIdentifier;
        /** an additional suffix to insert after the text sourced from `node` */
        suffix?: string;
    }
    interface NodeFactory {
        /** @internal */ readonly parenthesizer: ParenthesizerRules;
        /** @internal */ readonly converters: NodeConverters;
        /** @internal */ readonly baseFactory: BaseNodeFactory;
        /** @internal */ readonly flags: NodeFactoryFlags;
        createNodeArray<T extends Node>(elements?: readonly T[], hasTrailingComma?: boolean): NodeArray<T>;
        createNumericLiteral(value: string | number, numericLiteralFlags?: TokenFlags): NumericLiteral;
        createBigIntLiteral(value: string | PseudoBigInt): BigIntLiteral;
        createStringLiteral(text: string, isSingleQuote?: boolean): StringLiteral;
        /** @internal */ createStringLiteral(text: string, isSingleQuote?: boolean, hasExtendedUnicodeEscape?: boolean): StringLiteral;
        createStringLiteralFromNode(sourceNode: PropertyNameLiteral | PrivateIdentifier, isSingleQuote?: boolean): StringLiteral;
        createRegularExpressionLiteral(text: string): RegularExpressionLiteral;
        createIdentifier(text: string): Identifier;
        /** @internal */ createIdentifier(text: string, originalKeywordKind?: SyntaxKind, hasExtendedUnicodeEscape?: boolean): Identifier;
        /**
         * Create a unique temporary variable.
         * @param recordTempVariable An optional callback used to record the temporary variable name. This
         * should usually be a reference to `hoistVariableDeclaration` from a `TransformationContext`, but
         * can be `undefined` if you plan to record the temporary variable manually.
         * @param reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes
         * during emit so that the variable can be referenced in a nested function body. This is an alternative to
         * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.
         */
        createTempVariable(recordTempVariable: ((node: Identifier) => void) | undefined, reservedInNestedScopes?: boolean): Identifier;
        /** @internal */ createTempVariable(recordTempVariable: ((node: Identifier) => void) | undefined, reservedInNestedScopes?: boolean, prefix?: string | GeneratedNamePart, suffix?: string): Identifier;
        /**
         * Create a unique temporary variable for use in a loop.
         * @param reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes
         * during emit so that the variable can be referenced in a nested function body. This is an alternative to
         * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.
         */
        createLoopVariable(reservedInNestedScopes?: boolean): Identifier;
        /** Create a unique name based on the supplied text. */
        createUniqueName(text: string, flags?: GeneratedIdentifierFlags): Identifier;
        /** @internal */ createUniqueName(text: string, flags?: GeneratedIdentifierFlags, prefix?: string | GeneratedNamePart, suffix?: string): Identifier;
        /** Create a unique name generated for a node. */
        getGeneratedNameForNode(node: Node | undefined, flags?: GeneratedIdentifierFlags): Identifier;
        /** @internal */ getGeneratedNameForNode(node: Node | undefined, flags?: GeneratedIdentifierFlags, prefix?: string | GeneratedNamePart, suffix?: string): Identifier;
        createPrivateIdentifier(text: string): PrivateIdentifier;
        createUniquePrivateName(text?: string): PrivateIdentifier;
        /** @internal */ createUniquePrivateName(text?: string, prefix?: string | GeneratedNamePart, suffix?: string): PrivateIdentifier;
        getGeneratedPrivateNameForNode(node: Node): PrivateIdentifier;
        /** @internal */ getGeneratedPrivateNameForNode(node: Node, prefix?: string | GeneratedNamePart, suffix?: string): PrivateIdentifier;
        createToken(token: SyntaxKind.SuperKeyword): SuperExpression;
        createToken(token: SyntaxKind.ThisKeyword): ThisExpression;
        createToken(token: SyntaxKind.NullKeyword): NullLiteral;
        createToken(token: SyntaxKind.TrueKeyword): TrueLiteral;
        createToken(token: SyntaxKind.FalseKeyword): FalseLiteral;
        createToken(token: SyntaxKind.EndOfFileToken): EndOfFileToken;
        createToken(token: SyntaxKind.Unknown): Token<SyntaxKind.Unknown>;
        createToken<TKind extends PunctuationSyntaxKind>(token: TKind): PunctuationToken<TKind>;
        createToken<TKind extends KeywordTypeSyntaxKind>(token: TKind): KeywordTypeNode<TKind>;
        createToken<TKind extends ModifierSyntaxKind>(token: TKind): ModifierToken<TKind>;
        createToken<TKind extends KeywordSyntaxKind>(token: TKind): KeywordToken<TKind>;
        /** @internal */ createToken<TKind extends SyntaxKind>(token: TKind): Token<TKind>;
        createSuper(): SuperExpression;
        createThis(): ThisExpression;
        createNull(): NullLiteral;
        createTrue(): TrueLiteral;
        createFalse(): FalseLiteral;
        createModifier<T extends ModifierSyntaxKind>(kind: T): ModifierToken<T>;
        createModifiersFromModifierFlags(flags: ModifierFlags): Modifier[] | undefined;
        createQualifiedName(left: EntityName, right: string | Identifier): QualifiedName;
        updateQualifiedName(node: QualifiedName, left: EntityName, right: Identifier): QualifiedName;
        createComputedPropertyName(expression: Expression): ComputedPropertyName;
        updateComputedPropertyName(node: ComputedPropertyName, expression: Expression): ComputedPropertyName;
        createTypeParameterDeclaration(modifiers: readonly Modifier[] | undefined, name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;
        updateTypeParameterDeclaration(node: TypeParameterDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
        createParameterDeclaration(modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;
        updateParameterDeclaration(node: ParameterDeclaration, modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
        createDecorator(expression: Expression): Decorator;
        updateDecorator(node: Decorator, expression: Expression): Decorator;
        createPropertySignature(modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;
        updatePropertySignature(node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;
        createPropertyDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
        updatePropertyDeclaration(node: PropertyDeclaration, modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
        createMethodSignature(modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): MethodSignature;
        updateMethodSignature(node: MethodSignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): MethodSignature;
        createMethodDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
        updateMethodDeclaration(node: MethodDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
        createConstructorDeclaration(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
        updateConstructorDeclaration(node: ConstructorDeclaration, modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
        createGetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
        updateGetAccessorDeclaration(node: GetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
        createSetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
        updateSetAccessorDeclaration(node: SetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
        createCallSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): CallSignatureDeclaration;
        updateCallSignature(node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): CallSignatureDeclaration;
        createConstructSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): ConstructSignatureDeclaration;
        updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): ConstructSignatureDeclaration;
        createIndexSignature(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
        /** @internal */ createIndexSignature(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): IndexSignatureDeclaration;
        updateIndexSignature(node: IndexSignatureDeclaration, modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
        createTemplateLiteralTypeSpan(type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;
        updateTemplateLiteralTypeSpan(node: TemplateLiteralTypeSpan, type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;
        createClassStaticBlockDeclaration(body: Block): ClassStaticBlockDeclaration;
        updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, body: Block): ClassStaticBlockDeclaration;
        createKeywordTypeNode<TKind extends KeywordTypeSyntaxKind>(kind: TKind): KeywordTypeNode<TKind>;
        createTypePredicateNode(assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode | string, type: TypeNode | undefined): TypePredicateNode;
        updateTypePredicateNode(node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined): TypePredicateNode;
        createTypeReferenceNode(typeName: string | EntityName, typeArguments?: readonly TypeNode[]): TypeReferenceNode;
        updateTypeReferenceNode(node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined): TypeReferenceNode;
        createFunctionTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): FunctionTypeNode;
        updateFunctionTypeNode(node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): FunctionTypeNode;
        createConstructorTypeNode(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;
        updateConstructorTypeNode(node: ConstructorTypeNode, modifiers: readonly Modifier[] | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;
        createTypeQueryNode(exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;
        updateTypeQueryNode(node: TypeQueryNode, exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;
        createTypeLiteralNode(members: readonly TypeElement[] | undefined): TypeLiteralNode;
        updateTypeLiteralNode(node: TypeLiteralNode, members: NodeArray<TypeElement>): TypeLiteralNode;
        createArrayTypeNode(elementType: TypeNode): ArrayTypeNode;
        updateArrayTypeNode(node: ArrayTypeNode, elementType: TypeNode): ArrayTypeNode;
        createTupleTypeNode(elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;
        updateTupleTypeNode(node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;
        createNamedTupleMember(dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;
        updateNamedTupleMember(node: NamedTupleMember, dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;
        createOptionalTypeNode(type: TypeNode): OptionalTypeNode;
        updateOptionalTypeNode(node: OptionalTypeNode, type: TypeNode): OptionalTypeNode;
        createRestTypeNode(type: TypeNode): RestTypeNode;
        updateRestTypeNode(node: RestTypeNode, type: TypeNode): RestTypeNode;
        createUnionTypeNode(types: readonly TypeNode[]): UnionTypeNode;
        updateUnionTypeNode(node: UnionTypeNode, types: NodeArray<TypeNode>): UnionTypeNode;
        createIntersectionTypeNode(types: readonly TypeNode[]): IntersectionTypeNode;
        updateIntersectionTypeNode(node: IntersectionTypeNode, types: NodeArray<TypeNode>): IntersectionTypeNode;
        createConditionalTypeNode(checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;
        updateConditionalTypeNode(node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;
        createInferTypeNode(typeParameter: TypeParameterDeclaration): InferTypeNode;
        updateInferTypeNode(node: InferTypeNode, typeParameter: TypeParameterDeclaration): InferTypeNode;
        createImportTypeNode(argument: TypeNode, assertions?: ImportTypeAssertionContainer, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
        updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, assertions: ImportTypeAssertionContainer | undefined, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;
        createParenthesizedType(type: TypeNode): ParenthesizedTypeNode;
        updateParenthesizedType(node: ParenthesizedTypeNode, type: TypeNode): ParenthesizedTypeNode;
        createThisTypeNode(): ThisTypeNode;
        createTypeOperatorNode(operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;
        updateTypeOperatorNode(node: TypeOperatorNode, type: TypeNode): TypeOperatorNode;
        createIndexedAccessTypeNode(objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;
        updateIndexedAccessTypeNode(node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;
        createMappedTypeNode(readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;
        updateMappedTypeNode(node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;
        createLiteralTypeNode(literal: LiteralTypeNode["literal"]): LiteralTypeNode;
        updateLiteralTypeNode(node: LiteralTypeNode, literal: LiteralTypeNode["literal"]): LiteralTypeNode;
        createTemplateLiteralType(head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;
        updateTemplateLiteralType(node: TemplateLiteralTypeNode, head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;
        createObjectBindingPattern(elements: readonly BindingElement[]): ObjectBindingPattern;
        updateObjectBindingPattern(node: ObjectBindingPattern, elements: readonly BindingElement[]): ObjectBindingPattern;
        createArrayBindingPattern(elements: readonly ArrayBindingElement[]): ArrayBindingPattern;
        updateArrayBindingPattern(node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]): ArrayBindingPattern;
        createBindingElement(dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression): BindingElement;
        updateBindingElement(node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined): BindingElement;
        createArrayLiteralExpression(elements?: readonly Expression[], multiLine?: boolean): ArrayLiteralExpression;
        updateArrayLiteralExpression(node: ArrayLiteralExpression, elements: readonly Expression[]): ArrayLiteralExpression;
        createObjectLiteralExpression(properties?: readonly ObjectLiteralElementLike[], multiLine?: boolean): ObjectLiteralExpression;
        updateObjectLiteralExpression(node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]): ObjectLiteralExpression;
        createPropertyAccessExpression(expression: Expression, name: string | MemberName): PropertyAccessExpression;
        updatePropertyAccessExpression(node: PropertyAccessExpression, expression: Expression, name: MemberName): PropertyAccessExpression;
        createPropertyAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName): PropertyAccessChain;
        updatePropertyAccessChain(node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName): PropertyAccessChain;
        createElementAccessExpression(expression: Expression, index: number | Expression): ElementAccessExpression;
        updateElementAccessExpression(node: ElementAccessExpression, expression: Expression, argumentExpression: Expression): ElementAccessExpression;
        createElementAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression): ElementAccessChain;
        updateElementAccessChain(node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression): ElementAccessChain;
        createCallExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallExpression;
        updateCallExpression(node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallExpression;
        createCallChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallChain;
        updateCallChain(node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallChain;
        createNewExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;
        updateNewExpression(node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;
        createTaggedTemplateExpression(tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
        updateTaggedTemplateExpression(node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
        createTypeAssertion(type: TypeNode, expression: Expression): TypeAssertion;
        updateTypeAssertion(node: TypeAssertion, type: TypeNode, expression: Expression): TypeAssertion;
        createParenthesizedExpression(expression: Expression): ParenthesizedExpression;
        updateParenthesizedExpression(node: ParenthesizedExpression, expression: Expression): ParenthesizedExpression;
        createFunctionExpression(modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block): FunctionExpression;
        updateFunctionExpression(node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block): FunctionExpression;
        createArrowFunction(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;
        updateArrowFunction(node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;
        createDeleteExpression(expression: Expression): DeleteExpression;
        updateDeleteExpression(node: DeleteExpression, expression: Expression): DeleteExpression;
        createTypeOfExpression(expression: Expression): TypeOfExpression;
        updateTypeOfExpression(node: TypeOfExpression, expression: Expression): TypeOfExpression;
        createVoidExpression(expression: Expression): VoidExpression;
        updateVoidExpression(node: VoidExpression, expression: Expression): VoidExpression;
        createAwaitExpression(expression: Expression): AwaitExpression;
        updateAwaitExpression(node: AwaitExpression, expression: Expression): AwaitExpression;
        createPrefixUnaryExpression(operator: PrefixUnaryOperator, operand: Expression): PrefixUnaryExpression;
        updatePrefixUnaryExpression(node: PrefixUnaryExpression, operand: Expression): PrefixUnaryExpression;
        createPostfixUnaryExpression(operand: Expression, operator: PostfixUnaryOperator): PostfixUnaryExpression;
        updatePostfixUnaryExpression(node: PostfixUnaryExpression, operand: Expression): PostfixUnaryExpression;
        createBinaryExpression(left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;
        updateBinaryExpression(node: BinaryExpression, left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;
        createConditionalExpression(condition: Expression, questionToken: QuestionToken | undefined, whenTrue: Expression, colonToken: ColonToken | undefined, whenFalse: Expression): ConditionalExpression;
        updateConditionalExpression(node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;
        createTemplateExpression(head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;
        updateTemplateExpression(node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;
        createTemplateHead(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateHead;
        createTemplateHead(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateHead;
        createTemplateMiddle(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateMiddle;
        createTemplateMiddle(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateMiddle;
        createTemplateTail(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateTail;
        createTemplateTail(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateTail;
        createNoSubstitutionTemplateLiteral(text: string, rawText?: string): NoSubstitutionTemplateLiteral;
        createNoSubstitutionTemplateLiteral(text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;
        /** @internal */ createLiteralLikeNode(kind: LiteralToken["kind"] | SyntaxKind.JsxTextAllWhiteSpaces, text: string): LiteralToken;
        /** @internal */ createTemplateLiteralLikeNode(kind: TemplateLiteralToken["kind"], text: string, rawText: string, templateFlags: TokenFlags | undefined): TemplateLiteralLikeNode;
        createYieldExpression(asteriskToken: AsteriskToken, expression: Expression): YieldExpression;
        createYieldExpression(asteriskToken: undefined, expression: Expression | undefined): YieldExpression;
        /** @internal */ createYieldExpression(asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression;
        updateYieldExpression(node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression;
        createSpreadElement(expression: Expression): SpreadElement;
        updateSpreadElement(node: SpreadElement, expression: Expression): SpreadElement;
        createClassExpression(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
        updateClassExpression(node: ClassExpression, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
        createOmittedExpression(): OmittedExpression;
        createExpressionWithTypeArguments(expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;
        updateExpressionWithTypeArguments(node: ExpressionWithTypeArguments, expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;
        createAsExpression(expression: Expression, type: TypeNode): AsExpression;
        updateAsExpression(node: AsExpression, expression: Expression, type: TypeNode): AsExpression;
        createNonNullExpression(expression: Expression): NonNullExpression;
        updateNonNullExpression(node: NonNullExpression, expression: Expression): NonNullExpression;
        createNonNullChain(expression: Expression): NonNullChain;
        updateNonNullChain(node: NonNullChain, expression: Expression): NonNullChain;
        createMetaProperty(keywordToken: MetaProperty["keywordToken"], name: Identifier): MetaProperty;
        updateMetaProperty(node: MetaProperty, name: Identifier): MetaProperty;
        createSatisfiesExpression(expression: Expression, type: TypeNode): SatisfiesExpression;
        updateSatisfiesExpression(node: SatisfiesExpression, expression: Expression, type: TypeNode): SatisfiesExpression;
        createTemplateSpan(expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;
        updateTemplateSpan(node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;
        createSemicolonClassElement(): SemicolonClassElement;
        createBlock(statements: readonly Statement[], multiLine?: boolean): Block;
        updateBlock(node: Block, statements: readonly Statement[]): Block;
        createVariableStatement(modifiers: readonly ModifierLike[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]): VariableStatement;
        updateVariableStatement(node: VariableStatement, modifiers: readonly ModifierLike[] | undefined, declarationList: VariableDeclarationList): VariableStatement;
        createEmptyStatement(): EmptyStatement;
        createExpressionStatement(expression: Expression): ExpressionStatement;
        updateExpressionStatement(node: ExpressionStatement, expression: Expression): ExpressionStatement;
        createIfStatement(expression: Expression, thenStatement: Statement, elseStatement?: Statement): IfStatement;
        updateIfStatement(node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined): IfStatement;
        createDoStatement(statement: Statement, expression: Expression): DoStatement;
        updateDoStatement(node: DoStatement, statement: Statement, expression: Expression): DoStatement;
        createWhileStatement(expression: Expression, statement: Statement): WhileStatement;
        updateWhileStatement(node: WhileStatement, expression: Expression, statement: Statement): WhileStatement;
        createForStatement(initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;
        updateForStatement(node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;
        createForInStatement(initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;
        updateForInStatement(node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;
        createForOfStatement(awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;
        updateForOfStatement(node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;
        createContinueStatement(label?: string | Identifier): ContinueStatement;
        updateContinueStatement(node: ContinueStatement, label: Identifier | undefined): ContinueStatement;
        createBreakStatement(label?: string | Identifier): BreakStatement;
        updateBreakStatement(node: BreakStatement, label: Identifier | undefined): BreakStatement;
        createReturnStatement(expression?: Expression): ReturnStatement;
        updateReturnStatement(node: ReturnStatement, expression: Expression | undefined): ReturnStatement;
        createWithStatement(expression: Expression, statement: Statement): WithStatement;
        updateWithStatement(node: WithStatement, expression: Expression, statement: Statement): WithStatement;
        createSwitchStatement(expression: Expression, caseBlock: CaseBlock): SwitchStatement;
        updateSwitchStatement(node: SwitchStatement, expression: Expression, caseBlock: CaseBlock): SwitchStatement;
        createLabeledStatement(label: string | Identifier, statement: Statement): LabeledStatement;
        updateLabeledStatement(node: LabeledStatement, label: Identifier, statement: Statement): LabeledStatement;
        createThrowStatement(expression: Expression): ThrowStatement;
        updateThrowStatement(node: ThrowStatement, expression: Expression): ThrowStatement;
        createTryStatement(tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;
        updateTryStatement(node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;
        createDebuggerStatement(): DebuggerStatement;
        createVariableDeclaration(name: string | BindingName, exclamationToken?: ExclamationToken, type?: TypeNode, initializer?: Expression): VariableDeclaration;
        updateVariableDeclaration(node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
        createVariableDeclarationList(declarations: readonly VariableDeclaration[], flags?: NodeFlags): VariableDeclarationList;
        updateVariableDeclarationList(node: VariableDeclarationList, declarations: readonly VariableDeclaration[]): VariableDeclarationList;
        createFunctionDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
        updateFunctionDeclaration(node: FunctionDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
        createClassDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
        updateClassDeclaration(node: ClassDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
        createInterfaceDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
        updateInterfaceDeclaration(node: InterfaceDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
        createTypeAliasDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
        updateTypeAliasDeclaration(node: TypeAliasDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
        createEnumDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
        updateEnumDeclaration(node: EnumDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
        createModuleDeclaration(modifiers: readonly ModifierLike[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;
        updateModuleDeclaration(node: ModuleDeclaration, modifiers: readonly ModifierLike[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
        createModuleBlock(statements: readonly Statement[]): ModuleBlock;
        updateModuleBlock(node: ModuleBlock, statements: readonly Statement[]): ModuleBlock;
        createCaseBlock(clauses: readonly CaseOrDefaultClause[]): CaseBlock;
        updateCaseBlock(node: CaseBlock, clauses: readonly CaseOrDefaultClause[]): CaseBlock;
        createNamespaceExportDeclaration(name: string | Identifier): NamespaceExportDeclaration;
        updateNamespaceExportDeclaration(node: NamespaceExportDeclaration, name: Identifier): NamespaceExportDeclaration;
        createImportEqualsDeclaration(modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
        updateImportEqualsDeclaration(node: ImportEqualsDeclaration, modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
        createImportDeclaration(modifiers: readonly ModifierLike[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause): ImportDeclaration;
        updateImportDeclaration(node: ImportDeclaration, modifiers: readonly ModifierLike[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
        createImportClause(isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;
        updateImportClause(node: ImportClause, isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;
        createAssertClause(elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;
        updateAssertClause(node: AssertClause, elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;
        createAssertEntry(name: AssertionKey, value: Expression): AssertEntry;
        updateAssertEntry(node: AssertEntry, name: AssertionKey, value: Expression): AssertEntry;
        createImportTypeAssertionContainer(clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;
        updateImportTypeAssertionContainer(node: ImportTypeAssertionContainer, clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;
        createNamespaceImport(name: Identifier): NamespaceImport;
        updateNamespaceImport(node: NamespaceImport, name: Identifier): NamespaceImport;
        createNamespaceExport(name: Identifier): NamespaceExport;
        updateNamespaceExport(node: NamespaceExport, name: Identifier): NamespaceExport;
        createNamedImports(elements: readonly ImportSpecifier[]): NamedImports;
        updateNamedImports(node: NamedImports, elements: readonly ImportSpecifier[]): NamedImports;
        createImportSpecifier(isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ImportSpecifier;
        updateImportSpecifier(node: ImportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ImportSpecifier;
        createExportAssignment(modifiers: readonly ModifierLike[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
        updateExportAssignment(node: ExportAssignment, modifiers: readonly ModifierLike[] | undefined, expression: Expression): ExportAssignment;
        createExportDeclaration(modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, assertClause?: AssertClause): ExportDeclaration;
        updateExportDeclaration(node: ExportDeclaration, modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, assertClause: AssertClause | undefined): ExportDeclaration;
        createNamedExports(elements: readonly ExportSpecifier[]): NamedExports;
        updateNamedExports(node: NamedExports, elements: readonly ExportSpecifier[]): NamedExports;
        createExportSpecifier(isTypeOnly: boolean, propertyName: string | Identifier | undefined, name: string | Identifier): ExportSpecifier;
        updateExportSpecifier(node: ExportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ExportSpecifier;
        /** @internal */ createMissingDeclaration(): MissingDeclaration;
        createExternalModuleReference(expression: Expression): ExternalModuleReference;
        updateExternalModuleReference(node: ExternalModuleReference, expression: Expression): ExternalModuleReference;
        createJSDocAllType(): JSDocAllType;
        createJSDocUnknownType(): JSDocUnknownType;
        createJSDocNonNullableType(type: TypeNode, postfix?: boolean): JSDocNonNullableType;
        updateJSDocNonNullableType(node: JSDocNonNullableType, type: TypeNode): JSDocNonNullableType;
        createJSDocNullableType(type: TypeNode, postfix?: boolean): JSDocNullableType;
        updateJSDocNullableType(node: JSDocNullableType, type: TypeNode): JSDocNullableType;
        createJSDocOptionalType(type: TypeNode): JSDocOptionalType;
        updateJSDocOptionalType(node: JSDocOptionalType, type: TypeNode): JSDocOptionalType;
        createJSDocFunctionType(parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;
        updateJSDocFunctionType(node: JSDocFunctionType, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;
        createJSDocVariadicType(type: TypeNode): JSDocVariadicType;
        updateJSDocVariadicType(node: JSDocVariadicType, type: TypeNode): JSDocVariadicType;
        createJSDocNamepathType(type: TypeNode): JSDocNamepathType;
        updateJSDocNamepathType(node: JSDocNamepathType, type: TypeNode): JSDocNamepathType;
        createJSDocTypeExpression(type: TypeNode): JSDocTypeExpression;
        updateJSDocTypeExpression(node: JSDocTypeExpression, type: TypeNode): JSDocTypeExpression;
        createJSDocNameReference(name: EntityName | JSDocMemberName): JSDocNameReference;
        updateJSDocNameReference(node: JSDocNameReference, name: EntityName | JSDocMemberName): JSDocNameReference;
        createJSDocMemberName(left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;
        updateJSDocMemberName(node: JSDocMemberName, left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;
        createJSDocLink(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;
        updateJSDocLink(node: JSDocLink, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;
        createJSDocLinkCode(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;
        updateJSDocLinkCode(node: JSDocLinkCode, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;
        createJSDocLinkPlain(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;
        updateJSDocLinkPlain(node: JSDocLinkPlain, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;
        createJSDocTypeLiteral(jsDocPropertyTags?: readonly JSDocPropertyLikeTag[], isArrayType?: boolean): JSDocTypeLiteral;
        updateJSDocTypeLiteral(node: JSDocTypeLiteral, jsDocPropertyTags: readonly JSDocPropertyLikeTag[] | undefined, isArrayType: boolean | undefined): JSDocTypeLiteral;
        createJSDocSignature(typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag): JSDocSignature;
        updateJSDocSignature(node: JSDocSignature, typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type: JSDocReturnTag | undefined): JSDocSignature;
        createJSDocTemplateTag(tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray<JSDocComment>): JSDocTemplateTag;
        updateJSDocTemplateTag(node: JSDocTemplateTag, tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment: string | NodeArray<JSDocComment> | undefined): JSDocTemplateTag;
        createJSDocTypedefTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | JSDocTypeLiteral, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocTypedefTag;
        updateJSDocTypedefTag(node: JSDocTypedefTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | JSDocTypeLiteral | undefined, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypedefTag;
        createJSDocParameterTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocParameterTag;
        updateJSDocParameterTag(node: JSDocParameterTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocParameterTag;
        createJSDocPropertyTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocPropertyTag;
        updateJSDocPropertyTag(node: JSDocPropertyTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocPropertyTag;
        createJSDocTypeTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocTypeTag;
        updateJSDocTypeTag(node: JSDocTypeTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypeTag;
        createJSDocSeeTag(tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;
        updateJSDocSeeTag(node: JSDocSeeTag, tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;
        createJSDocReturnTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocReturnTag;
        updateJSDocReturnTag(node: JSDocReturnTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReturnTag;
        createJSDocThisTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocThisTag;
        updateJSDocThisTag(node: JSDocThisTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocThisTag;
        createJSDocEnumTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocEnumTag;
        updateJSDocEnumTag(node: JSDocEnumTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocEnumTag;
        createJSDocCallbackTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocCallbackTag;
        updateJSDocCallbackTag(node: JSDocCallbackTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocCallbackTag;
        createJSDocOverloadTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, comment?: string | NodeArray<JSDocComment>): JSDocOverloadTag;
        updateJSDocOverloadTag(node: JSDocOverloadTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, comment: string | NodeArray<JSDocComment> | undefined): JSDocOverloadTag;
        createJSDocAugmentsTag(tagName: Identifier | undefined, className: JSDocAugmentsTag["class"], comment?: string | NodeArray<JSDocComment>): JSDocAugmentsTag;
        updateJSDocAugmentsTag(node: JSDocAugmentsTag, tagName: Identifier | undefined, className: JSDocAugmentsTag["class"], comment: string | NodeArray<JSDocComment> | undefined): JSDocAugmentsTag;
        createJSDocImplementsTag(tagName: Identifier | undefined, className: JSDocImplementsTag["class"], comment?: string | NodeArray<JSDocComment>): JSDocImplementsTag;
        updateJSDocImplementsTag(node: JSDocImplementsTag, tagName: Identifier | undefined, className: JSDocImplementsTag["class"], comment: string | NodeArray<JSDocComment> | undefined): JSDocImplementsTag;
        createJSDocAuthorTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocAuthorTag;
        updateJSDocAuthorTag(node: JSDocAuthorTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocAuthorTag;
        createJSDocClassTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocClassTag;
        updateJSDocClassTag(node: JSDocClassTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocClassTag;
        createJSDocPublicTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPublicTag;
        updateJSDocPublicTag(node: JSDocPublicTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPublicTag;
        createJSDocPrivateTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPrivateTag;
        updateJSDocPrivateTag(node: JSDocPrivateTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPrivateTag;
        createJSDocProtectedTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocProtectedTag;
        updateJSDocProtectedTag(node: JSDocProtectedTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocProtectedTag;
        createJSDocReadonlyTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocReadonlyTag;
        updateJSDocReadonlyTag(node: JSDocReadonlyTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReadonlyTag;
        createJSDocUnknownTag(tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocUnknownTag;
        updateJSDocUnknownTag(node: JSDocUnknownTag, tagName: Identifier, comment: string | NodeArray<JSDocComment> | undefined): JSDocUnknownTag;
        createJSDocDeprecatedTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;
        updateJSDocDeprecatedTag(node: JSDocDeprecatedTag, tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;
        createJSDocOverrideTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;
        updateJSDocOverrideTag(node: JSDocOverrideTag, tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;
        createJSDocThrowsTag(tagName: Identifier, typeExpression: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment>): JSDocThrowsTag;
        updateJSDocThrowsTag(node: JSDocThrowsTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment> | undefined): JSDocThrowsTag;
        createJSDocSatisfiesTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocSatisfiesTag;
        updateJSDocSatisfiesTag(node: JSDocSatisfiesTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocSatisfiesTag;
        createJSDocText(text: string): JSDocText;
        updateJSDocText(node: JSDocText, text: string): JSDocText;
        createJSDocComment(comment?: string | NodeArray<JSDocComment> | undefined, tags?: readonly JSDocTag[] | undefined): JSDoc;
        updateJSDocComment(node: JSDoc, comment: string | NodeArray<JSDocComment> | undefined, tags: readonly JSDocTag[] | undefined): JSDoc;
        createJsxElement(openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;
        updateJsxElement(node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;
        createJsxSelfClosingElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;
        updateJsxSelfClosingElement(node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;
        createJsxOpeningElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;
        updateJsxOpeningElement(node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;
        createJsxClosingElement(tagName: JsxTagNameExpression): JsxClosingElement;
        updateJsxClosingElement(node: JsxClosingElement, tagName: JsxTagNameExpression): JsxClosingElement;
        createJsxFragment(openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;
        createJsxText(text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;
        updateJsxText(node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;
        createJsxOpeningFragment(): JsxOpeningFragment;
        createJsxJsxClosingFragment(): JsxClosingFragment;
        updateJsxFragment(node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;
        createJsxAttribute(name: Identifier, initializer: JsxAttributeValue | undefined): JsxAttribute;
        updateJsxAttribute(node: JsxAttribute, name: Identifier, initializer: JsxAttributeValue | undefined): JsxAttribute;
        createJsxAttributes(properties: readonly JsxAttributeLike[]): JsxAttributes;
        updateJsxAttributes(node: JsxAttributes, properties: readonly JsxAttributeLike[]): JsxAttributes;
        createJsxSpreadAttribute(expression: Expression): JsxSpreadAttribute;
        updateJsxSpreadAttribute(node: JsxSpreadAttribute, expression: Expression): JsxSpreadAttribute;
        createJsxExpression(dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined): JsxExpression;
        updateJsxExpression(node: JsxExpression, expression: Expression | undefined): JsxExpression;
        createCaseClause(expression: Expression, statements: readonly Statement[]): CaseClause;
        updateCaseClause(node: CaseClause, expression: Expression, statements: readonly Statement[]): CaseClause;
        createDefaultClause(statements: readonly Statement[]): DefaultClause;
        updateDefaultClause(node: DefaultClause, statements: readonly Statement[]): DefaultClause;
        createHeritageClause(token: HeritageClause["token"], types: readonly ExpressionWithTypeArguments[]): HeritageClause;
        updateHeritageClause(node: HeritageClause, types: readonly ExpressionWithTypeArguments[]): HeritageClause;
        createCatchClause(variableDeclaration: string | BindingName | VariableDeclaration | undefined, block: Block): CatchClause;
        updateCatchClause(node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block): CatchClause;
        createPropertyAssignment(name: string | PropertyName, initializer: Expression): PropertyAssignment;
        updatePropertyAssignment(node: PropertyAssignment, name: PropertyName, initializer: Expression): PropertyAssignment;
        createShorthandPropertyAssignment(name: string | Identifier, objectAssignmentInitializer?: Expression): ShorthandPropertyAssignment;
        updateShorthandPropertyAssignment(node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined): ShorthandPropertyAssignment;
        createSpreadAssignment(expression: Expression): SpreadAssignment;
        updateSpreadAssignment(node: SpreadAssignment, expression: Expression): SpreadAssignment;
        createEnumMember(name: string | PropertyName, initializer?: Expression): EnumMember;
        updateEnumMember(node: EnumMember, name: PropertyName, initializer: Expression | undefined): EnumMember;
        createSourceFile(statements: readonly Statement[], endOfFileToken: EndOfFileToken, flags: NodeFlags): SourceFile;
        updateSourceFile(node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean, referencedFiles?: readonly FileReference[], typeReferences?: readonly FileReference[], hasNoDefaultLib?: boolean, libReferences?: readonly FileReference[]): SourceFile;
        /** @internal */ createRedirectedSourceFile(redirectInfo: RedirectInfo): SourceFile;
        /** @deprecated @internal */ createUnparsedSource(prologues: readonly UnparsedPrologue[], syntheticReferences: readonly UnparsedSyntheticReference[] | undefined, texts: readonly UnparsedSourceText[]): UnparsedSource;
        /** @deprecated @internal */ createUnparsedPrologue(data?: string): UnparsedPrologue;
        /** @deprecated @internal */ createUnparsedPrepend(data: string | undefined, texts: readonly UnparsedSourceText[]): UnparsedPrepend;
        /** @deprecated @internal */ createUnparsedTextLike(data: string | undefined, internal: boolean): UnparsedTextLike;
        /** @deprecated @internal */ createUnparsedSyntheticReference(section: BundleFileHasNoDefaultLib | BundleFileReference): UnparsedSyntheticReference;
        /** @deprecated @internal */ createInputFiles(): InputFiles;
        /** @internal */ createSyntheticExpression(type: Type, isSpread?: boolean, tupleNameSource?: ParameterDeclaration | NamedTupleMember): SyntheticExpression;
        /** @internal */ createSyntaxList(children: Node[]): SyntaxList;
        createNotEmittedStatement(original: Node): NotEmittedStatement;
        /** @internal */ createEndOfDeclarationMarker(original: Node): EndOfDeclarationMarker;
        /** @internal */ createMergeDeclarationMarker(original: Node): MergeDeclarationMarker;
        createPartiallyEmittedExpression(expression: Expression, original?: Node): PartiallyEmittedExpression;
        updatePartiallyEmittedExpression(node: PartiallyEmittedExpression, expression: Expression): PartiallyEmittedExpression;
        /** @internal */ createSyntheticReferenceExpression(expression: Expression, thisArg: Expression): SyntheticReferenceExpression;
        /** @internal */ updateSyntheticReferenceExpression(node: SyntheticReferenceExpression, expression: Expression, thisArg: Expression): SyntheticReferenceExpression;
        createCommaListExpression(elements: readonly Expression[]): CommaListExpression;
        updateCommaListExpression(node: CommaListExpression, elements: readonly Expression[]): CommaListExpression;
        createBundle(sourceFiles: readonly SourceFile[]): Bundle;
        /** @deprecated*/ createBundle(sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;
        updateBundle(node: Bundle, sourceFiles: readonly SourceFile[]): Bundle;
        /** @deprecated*/ updateBundle(node: Bundle, sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;
        createComma(left: Expression, right: Expression): BinaryExpression;
        createAssignment(left: ObjectLiteralExpression | ArrayLiteralExpression, right: Expression): DestructuringAssignment;
        createAssignment(left: Expression, right: Expression): AssignmentExpression<EqualsToken>;
        createLogicalOr(left: Expression, right: Expression): BinaryExpression;
        createLogicalAnd(left: Expression, right: Expression): BinaryExpression;
        createBitwiseOr(left: Expression, right: Expression): BinaryExpression;
        createBitwiseXor(left: Expression, right: Expression): BinaryExpression;
        createBitwiseAnd(left: Expression, right: Expression): BinaryExpression;
        createStrictEquality(left: Expression, right: Expression): BinaryExpression;
        createStrictInequality(left: Expression, right: Expression): BinaryExpression;
        createEquality(left: Expression, right: Expression): BinaryExpression;
        createInequality(left: Expression, right: Expression): BinaryExpression;
        createLessThan(left: Expression, right: Expression): BinaryExpression;
        createLessThanEquals(left: Expression, right: Expression): BinaryExpression;
        createGreaterThan(left: Expression, right: Expression): BinaryExpression;
        createGreaterThanEquals(left: Expression, right: Expression): BinaryExpression;
        createLeftShift(left: Expression, right: Expression): BinaryExpression;
        createRightShift(left: Expression, right: Expression): BinaryExpression;
        createUnsignedRightShift(left: Expression, right: Expression): BinaryExpression;
        createAdd(left: Expression, right: Expression): BinaryExpression;
        createSubtract(left: Expression, right: Expression): BinaryExpression;
        createMultiply(left: Expression, right: Expression): BinaryExpression;
        createDivide(left: Expression, right: Expression): BinaryExpression;
        createModulo(left: Expression, right: Expression): BinaryExpression;
        createExponent(left: Expression, right: Expression): BinaryExpression;
        createPrefixPlus(operand: Expression): PrefixUnaryExpression;
        createPrefixMinus(operand: Expression): PrefixUnaryExpression;
        createPrefixIncrement(operand: Expression): PrefixUnaryExpression;
        createPrefixDecrement(operand: Expression): PrefixUnaryExpression;
        createBitwiseNot(operand: Expression): PrefixUnaryExpression;
        createLogicalNot(operand: Expression): PrefixUnaryExpression;
        createPostfixIncrement(operand: Expression): PostfixUnaryExpression;
        createPostfixDecrement(operand: Expression): PostfixUnaryExpression;
        createImmediatelyInvokedFunctionExpression(statements: readonly Statement[]): CallExpression;
        createImmediatelyInvokedFunctionExpression(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
        createImmediatelyInvokedArrowFunction(statements: readonly Statement[]): CallExpression;
        createImmediatelyInvokedArrowFunction(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
        createVoidZero(): VoidExpression;
        createExportDefault(expression: Expression): ExportAssignment;
        createExternalModuleExport(exportName: Identifier): ExportDeclaration;
        /** @internal */ createTypeCheck(value: Expression, tag: TypeOfTag): Expression;
        /** @internal */ createMethodCall(object: Expression, methodName: string | Identifier, argumentsList: readonly Expression[]): CallExpression;
        /** @internal */ createGlobalMethodCall(globalObjectName: string, globalMethodName: string, argumentsList: readonly Expression[]): CallExpression;
        /** @internal */ createFunctionBindCall(target: Expression, thisArg: Expression, argumentsList: readonly Expression[]): CallExpression;
        /** @internal */ createFunctionCallCall(target: Expression, thisArg: Expression, argumentsList: readonly Expression[]): CallExpression;
        /** @internal */ createFunctionApplyCall(target: Expression, thisArg: Expression, argumentsExpression: Expression): CallExpression;
        /** @internal */ createObjectDefinePropertyCall(target: Expression, propertyName: string | Expression, attributes: Expression): CallExpression;
        /** @internal */ createObjectGetOwnPropertyDescriptorCall(target: Expression, propertyName: string | Expression): CallExpression;
        /** @internal */ createReflectGetCall(target: Expression, propertyKey: Expression, receiver?: Expression): CallExpression;
        /** @internal */ createReflectSetCall(target: Expression, propertyKey: Expression, value: Expression, receiver?: Expression): CallExpression;
        /** @internal */ createPropertyDescriptor(attributes: PropertyDescriptorAttributes, singleLine?: boolean): ObjectLiteralExpression;
        /** @internal */ createArraySliceCall(array: Expression, start?: number | Expression): CallExpression;
        /** @internal */ createArrayConcatCall(array: Expression, values: readonly Expression[]): CallExpression;
        /** @internal */ createCallBinding(expression: Expression, recordTempVariable: (temp: Identifier) => void, languageVersion?: ScriptTarget, cacheIdentifiers?: boolean): CallBinding;
        /**
         * Wraps an expression that cannot be an assignment target in an expression that can be.
         *
         * Given a `paramName` of `_a`:
         * ```
         * Reflect.set(obj, "x", _a)
         * ```
         * Becomes
         * ```ts
         * ({ set value(_a) { Reflect.set(obj, "x", _a); } }).value
         * ```
         *
         * @param paramName
         * @param expression
         *
         * @internal
         */
        createAssignmentTargetWrapper(paramName: Identifier, expression: Expression): PropertyAccessExpression;
        /** @internal */ inlineExpressions(expressions: readonly Expression[]): Expression;
        /**
         * Gets the internal name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the body of an ES5 class function body. An internal name will *never*
         * be prefixed with an module or namespace export modifier like "exports." when emitted as an
         * expression. An internal name will also *never* be renamed due to a collision with a block
         * scoped variable.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         *
         * @internal
         */
        getInternalName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
        /**
         * Gets the local name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the declaration's immediate scope (classes, enums, namespaces). A
         * local name will *never* be prefixed with an module or namespace export modifier like
         * "exports." when emitted as an expression.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         *
         * @internal
         */
        getLocalName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
        /**
         * Gets the export name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the declaration's immediate scope (classes, enums, namespaces). An
         * export name will *always* be prefixed with a module or namespace export modifier like
         * `"exports."` when emitted as an expression if the name points to an exported symbol.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         *
         * @internal
         */
        getExportName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
        /**
         * Gets the name of a declaration for use in declarations.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         *
         * @internal
         */
        getDeclarationName(node: Declaration | undefined, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
        /**
         * Gets a namespace-qualified name for use in expressions.
         *
         * @param ns The namespace identifier.
         * @param name The name.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         *
         * @internal
         */
        getNamespaceMemberName(ns: Identifier, name: Identifier, allowComments?: boolean, allowSourceMaps?: boolean): PropertyAccessExpression;
        /**
         * Gets the exported name of a declaration for use in expressions.
         *
         * An exported name will *always* be prefixed with an module or namespace export modifier like
         * "exports." if the name points to an exported symbol.
         *
         * @param ns The namespace identifier.
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         *
         * @internal
         */
        getExternalModuleOrNamespaceExportName(ns: Identifier | undefined, node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier | PropertyAccessExpression;
        restoreOuterExpressions(outerExpression: Expression | undefined, innerExpression: Expression, kinds?: OuterExpressionKinds): Expression;
        /** @internal */ restoreEnclosingLabel(node: Statement, outermostLabeledStatement: LabeledStatement | undefined, afterRestoreLabelCallback?: (node: LabeledStatement) => void): Statement;
        /** @internal */ createUseStrictPrologue(): PrologueDirective;
        /**
         * Copies any necessary standard and custom prologue-directives into target array.
         * @param source origin statements array
         * @param target result statements array
         * @param ensureUseStrict boolean determining whether the function need to add prologue-directives
         * @param visitor Optional callback used to visit any custom prologue directives.
         *
         * @internal
         */
        copyPrologue(source: readonly Statement[], target: Push<Statement>, ensureUseStrict?: boolean, visitor?: (node: Node) => VisitResult<Node | undefined>): number;
        /**
         * Copies only the standard (string-expression) prologue-directives into the target statement-array.
         * @param source origin statements array
         * @param target result statements array
         * @param statementOffset The offset at which to begin the copy.
         * @param ensureUseStrict boolean determining whether the function need to add prologue-directives
         *
         * @internal
         */
        copyStandardPrologue(source: readonly Statement[], target: Push<Statement>, statementOffset: number | undefined, ensureUseStrict?: boolean): number;
        /**
         * Copies only the custom prologue-directives into target statement-array.
         * @param source origin statements array
         * @param target result statements array
         * @param statementOffset The offset at which to begin the copy.
         * @param visitor Optional callback used to visit any custom prologue directives.
         *
         * @internal
         */
        copyCustomPrologue(source: readonly Statement[], target: Push<Statement>, statementOffset: number, visitor?: (node: Node) => VisitResult<Node | undefined>, filter?: (node: Statement) => boolean): number;
        /** @internal */ copyCustomPrologue(source: readonly Statement[], target: Push<Statement>, statementOffset: number | undefined, visitor?: (node: Node) => VisitResult<Node | undefined>, filter?: (node: Statement) => boolean): number | undefined;
        /** @internal */ ensureUseStrict(statements: NodeArray<Statement>): NodeArray<Statement>;
        /** @internal */ liftToBlock(nodes: readonly Node[]): Statement;
        /**
         * Merges generated lexical declarations into a new statement list.
         *
         * @internal
         */
        mergeLexicalEnvironment(statements: NodeArray<Statement>, declarations: readonly Statement[] | undefined): NodeArray<Statement>;
        /**
         * Appends generated lexical declarations to an array of statements.
         *
         * @internal
         */
        mergeLexicalEnvironment(statements: Statement[], declarations: readonly Statement[] | undefined): Statement[];
        /**
         * Creates a shallow, memberwise clone of a node.
         * - The result will have its `original` pointer set to `node`.
         * - The result will have its `pos` and `end` set to `-1`.
         * - *DO NOT USE THIS* if a more appropriate function is available.
         *
         * @internal
         */
        cloneNode<T extends Node | undefined>(node: T): T;
        /** @internal */ updateModifiers<T extends HasModifiers>(node: T, modifiers: readonly Modifier[] | ModifierFlags | undefined): T;
        getHelperName(name: string): Identifier;
    }
    /** @internal */
    enum LexicalEnvironmentFlags {
        None = 0,
        InParameters = 1,
        VariablesHoistedInParameters = 2
    }
    interface CoreTransformationContext {
        readonly factory: NodeFactory;
        /** Gets the compiler options supplied to the transformer. */
        getCompilerOptions(): CompilerOptions;
        /** Starts a new lexical environment. */
        startLexicalEnvironment(): void;
        /** @internal */ setLexicalEnvironmentFlags(flags: LexicalEnvironmentFlags, value: boolean): void;
        /** @internal */ getLexicalEnvironmentFlags(): LexicalEnvironmentFlags;
        /** Suspends the current lexical environment, usually after visiting a parameter list. */
        suspendLexicalEnvironment(): void;
        /** Resumes a suspended lexical environment, usually before visiting a function body. */
        resumeLexicalEnvironment(): void;
        /** Ends a lexical environment, returning any declarations. */
        endLexicalEnvironment(): Statement[] | undefined;
        /** Hoists a function declaration to the containing scope. */
        hoistFunctionDeclaration(node: FunctionDeclaration): void;
        /** Hoists a variable declaration to the containing scope. */
        hoistVariableDeclaration(node: Identifier): void;
        /** @internal */ startBlockScope(): void;
        /** @internal */ endBlockScope(): Statement[] | undefined;
        /** @internal */ addBlockScopedVariable(node: Identifier): void;
        /**
         * Adds an initialization statement to the top of the lexical environment.
         *
         * @internal
         */
        addInitializationStatement(node: Statement): void;
    }
    interface TransformationContext extends CoreTransformationContext {
        /** @internal */ getEmitResolver(): EmitResolver;
        /** @internal */ getEmitHost(): EmitHost;
        /** @internal */ getEmitHelperFactory(): EmitHelperFactory;
        /** Records a request for a non-scoped emit helper in the current context. */
        requestEmitHelper(helper: EmitHelper): void;
        /** Gets and resets the requested non-scoped emit helpers. */
        readEmitHelpers(): EmitHelper[] | undefined;
        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */
        enableSubstitution(kind: SyntaxKind): void;
        /** Determines whether expression substitutions are enabled for the provided node. */
        isSubstitutionEnabled(node: Node): boolean;
        /**
         * Hook used by transformers to substitute expressions just before they
         * are emitted by the pretty printer.
         *
         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
         * before returning the `NodeTransformer` callback.
         */
        onSubstituteNode: (hint: EmitHint, node: Node) => Node;
        /**
         * Enables before/after emit notifications in the pretty printer for the provided
         * SyntaxKind.
         */
        enableEmitNotification(kind: SyntaxKind): void;
        /**
         * Determines whether before/after emit notifications should be raised in the pretty
         * printer when it emits a node.
         */
        isEmitNotificationEnabled(node: Node): boolean;
        /**
         * Hook used to allow transformers to capture state before or after
         * the printer emits a node.
         *
         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
         * before returning the `NodeTransformer` callback.
         */
        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
        /** @internal */ addDiagnostic(diag: DiagnosticWithLocation): void;
    }
    interface TransformationResult<T extends Node> {
        /** Gets the transformed source files. */
        transformed: T[];
        /** Gets diagnostics for the transformation. */
        diagnostics?: DiagnosticWithLocation[];
        /**
         * Gets a substitute for a node, if one is available; otherwise, returns the original node.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to substitute.
         */
        substituteNode(hint: EmitHint, node: Node): Node;
        /**
         * Emits a node with possible notification.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to emit.
         * @param emitCallback A callback used to emit the node.
         */
        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
        /**
         * Indicates if a given node needs an emit notification
         *
         * @param node The node to emit.
         */
        isEmitNotificationEnabled?(node: Node): boolean;
        /**
         * Clean up EmitNode entries on any parse-tree nodes.
         */
        dispose(): void;
    }
    /**
     * A function that is used to initialize and return a `Transformer` callback, which in turn
     * will be used to transform one or more nodes.
     */
    type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;
    /**
     * A function that transforms a node.
     */
    type Transformer<T extends Node> = (node: T) => T;
    /**
     * A function that accepts and possibly transforms a node.
     */
    type Visitor<TIn extends Node = Node, TOut extends Node | undefined = TIn | undefined> = (node: TIn) => VisitResult<TOut>;
    /**
     * A function that walks a node using the given visitor, lifting node arrays into single nodes,
     * returning an node which satisfies the test.
     *
     * - If the input node is undefined, then the output is undefined.
     * - If the visitor returns undefined, then the output is undefined.
     * - If the output node is not undefined, then it will satisfy the test function.
     * - In order to obtain a return type that is more specific than `Node`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * For the canonical implementation of this type, @see {visitNode}.
     */
    interface NodeVisitor {
        <TIn extends Node | undefined, TVisited extends Node | undefined, TOut extends Node>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test: (node: Node) => node is TOut, lift?: (node: readonly Node[]) => Node): TOut | (TIn & undefined) | (TVisited & undefined);
        <TIn extends Node | undefined, TVisited extends Node | undefined>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => Node): Node | (TIn & undefined) | (TVisited & undefined);
    }
    /**
     * A function that walks a node array using the given visitor, returning an array whose contents satisfy the test.
     *
     * - If the input node array is undefined, the output is undefined.
     * - If the visitor can return undefined, the node it visits in the array will be reused.
     * - If the output node array is not undefined, then its contents will satisfy the test.
     * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * For the canonical implementation of this type, @see {visitNodes}.
     */
    interface NodesVisitor {
        <TIn extends Node, TInArray extends NodeArray<TIn> | undefined, TOut extends Node>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test: (node: Node) => node is TOut, start?: number, count?: number): NodeArray<TOut> | (TInArray & undefined);
        <TIn extends Node, TInArray extends NodeArray<TIn> | undefined>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<Node> | (TInArray & undefined);
    }
    type VisitResult<T extends Node | undefined> = T | readonly Node[];
    interface Printer {
        /**
         * Print a node and its subtree as-is, without any emit transformations.
         * @param hint A value indicating the purpose of a node. This is primarily used to
         * distinguish between an `Identifier` used in an expression position, versus an
         * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you
         * should just pass `Unspecified`.
         * @param node The node to print. The node and its subtree are printed as-is, without any
         * emit transformations.
         * @param sourceFile A source file that provides context for the node. The source text of
         * the file is used to emit the original source content for literals and identifiers, while
         * the identifiers of the source file are used when generating unique names to avoid
         * collisions.
         */
        printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;
        /**
         * Prints a list of nodes using the given format flags
         */
        printList<T extends Node>(format: ListFormat, list: NodeArray<T>, sourceFile: SourceFile): string;
        /**
         * Prints a source file as-is, without any emit transformations.
         */
        printFile(sourceFile: SourceFile): string;
        /**
         * Prints a bundle of source files as-is, without any emit transformations.
         */
        printBundle(bundle: Bundle): string;
        /** @internal */ writeNode(hint: EmitHint, node: Node, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;
        /** @internal */ writeList<T extends Node>(format: ListFormat, list: NodeArray<T> | undefined, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;
        /** @internal */ writeFile(sourceFile: SourceFile, writer: EmitTextWriter, sourceMapGenerator: SourceMapGenerator | undefined): void;
        /** @internal */ writeBundle(bundle: Bundle, writer: EmitTextWriter, sourceMapGenerator: SourceMapGenerator | undefined): void;
        /** @deprecated @internal */ bundleFileInfo?: BundleFileInfo;
    }
    /** @deprecated @internal */
    enum BundleFileSectionKind {
        Prologue = "prologue",
        EmitHelpers = "emitHelpers",
        NoDefaultLib = "no-default-lib",
        Reference = "reference",
        Type = "type",
        TypeResolutionModeRequire = "type-require",
        TypeResolutionModeImport = "type-import",
        Lib = "lib",
        Prepend = "prepend",
        Text = "text",
        Internal = "internal"
    }
    /** @deprecated @internal */
    interface BundleFileSectionBase extends TextRange {
        kind: BundleFileSectionKind;
        data?: string;
    }
    /** @deprecated @internal */
    interface BundleFilePrologue extends BundleFileSectionBase {
        kind: BundleFileSectionKind.Prologue;
        data: string;
    }
    /** @deprecated @internal */
    interface BundleFileEmitHelpers extends BundleFileSectionBase {
        kind: BundleFileSectionKind.EmitHelpers;
        data: string;
    }
    /** @deprecated @internal */
    interface BundleFileHasNoDefaultLib extends BundleFileSectionBase {
        kind: BundleFileSectionKind.NoDefaultLib;
    }
    /** @deprecated @internal */
    interface BundleFileReference extends BundleFileSectionBase {
        kind: BundleFileSectionKind.Reference | BundleFileSectionKind.Type | BundleFileSectionKind.Lib | BundleFileSectionKind.TypeResolutionModeImport | BundleFileSectionKind.TypeResolutionModeRequire;
        data: string;
    }
    /** @deprecated @internal */
    interface BundleFilePrepend extends BundleFileSectionBase {
        kind: BundleFileSectionKind.Prepend;
        data: string;
        texts: BundleFileTextLike[];
    }
    /** @deprecated @internal */
    type BundleFileTextLikeKind = BundleFileSectionKind.Text | BundleFileSectionKind.Internal;
    /** @deprecated @internal */
    interface BundleFileTextLike extends BundleFileSectionBase {
        kind: BundleFileTextLikeKind;
    }
    /** @deprecated @internal */
    type BundleFileSection = BundleFilePrologue | BundleFileEmitHelpers | BundleFileHasNoDefaultLib | BundleFileReference | BundleFilePrepend | BundleFileTextLike;
    /** @deprecated @internal */
    interface SourceFilePrologueDirectiveExpression extends TextRange {
        text: string;
    }
    /** @deprecated @internal */
    interface SourceFilePrologueDirective extends TextRange {
        expression: SourceFilePrologueDirectiveExpression;
    }
    /** @deprecated @internal */
    interface SourceFilePrologueInfo {
        file: number;
        text: string;
        directives: SourceFilePrologueDirective[];
    }
    /** @deprecated @internal */
    interface SourceFileInfo {
        helpers?: string[];
        prologues?: SourceFilePrologueInfo[];
    }
    /** @deprecated @internal */
    interface BundleFileInfo {
        sections: BundleFileSection[];
        hash?: string;
        mapHash?: string;
        sources?: SourceFileInfo;
    }
    /** @deprecated @internal */
    interface BundleBuildInfo {
        js?: BundleFileInfo;
        dts?: BundleFileInfo;
        commonSourceDirectory: string;
        sourceFiles: readonly string[];
    }
    /** @internal */
    interface BuildInfo {
        /** @deprecated */
        bundle?: BundleBuildInfo;
        program?: ProgramBuildInfo;
        version: string;
    }
    interface PrintHandlers {
        /**
         * A hook used by the Printer when generating unique names to avoid collisions with
         * globally defined names that exist outside of the current source file.
         */
        hasGlobalName?(name: string): boolean;
        /**
         * A hook used by the Printer to provide notifications prior to emitting a node. A
         * compatible implementation **must** invoke `emitCallback` with the provided `hint` and
         * `node` values.
         * @param hint A hint indicating the intended purpose of the node.
         * @param node The node to emit.
         * @param emitCallback A callback that, when invoked, will emit the node.
         * @example
         * ```ts
         * var printer = createPrinter(printerOptions, {
         *   onEmitNode(hint, node, emitCallback) {
         *     // set up or track state prior to emitting the node...
         *     emitCallback(hint, node);
         *     // restore state after emitting the node...
         *   }
         * });
         * ```
         */
        onEmitNode?(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
        /**
         * A hook used to check if an emit notification is required for a node.
         * @param node The node to emit.
         */
        isEmitNotificationEnabled?(node: Node): boolean;
        /**
         * A hook used by the Printer to perform just-in-time substitution of a node. This is
         * primarily used by node transformations that need to substitute one node for another,
         * such as replacing `myExportedVar` with `exports.myExportedVar`.
         * @param hint A hint indicating the intended purpose of the node.
         * @param node The node to emit.
         * @example
         * ```ts
         * var printer = createPrinter(printerOptions, {
         *   substituteNode(hint, node) {
         *     // perform substitution if necessary...
         *     return node;
         *   }
         * });
         * ```
         */
        substituteNode?(hint: EmitHint, node: Node): Node;
        /** @internal */ onEmitSourceMapOfNode?: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
        /** @internal */ onEmitSourceMapOfToken?: (node: Node | undefined, token: SyntaxKind, writer: (s: string) => void, pos: number, emitCallback: (token: SyntaxKind, writer: (s: string) => void, pos: number) => number) => number;
        /** @internal */ onEmitSourceMapOfPosition?: (pos: number) => void;
        /** @internal */ onSetSourceFile?: (node: SourceFile) => void;
        /** @internal */ onBeforeEmitNode?: (node: Node | undefined) => void;
        /** @internal */ onAfterEmitNode?: (node: Node | undefined) => void;
        /** @internal */ onBeforeEmitNodeArray?: (nodes: NodeArray<any> | undefined) => void;
        /** @internal */ onAfterEmitNodeArray?: (nodes: NodeArray<any> | undefined) => void;
        /** @internal */ onBeforeEmitToken?: (node: Node) => void;
        /** @internal */ onAfterEmitToken?: (node: Node) => void;
    }
    interface PrinterOptions {
        removeComments?: boolean;
        newLine?: NewLineKind;
        omitTrailingSemicolon?: boolean;
        noEmitHelpers?: boolean;
        /** @internal */ module?: CompilerOptions["module"];
        /** @internal */ target?: CompilerOptions["target"];
        /** @internal */ sourceMap?: boolean;
        /** @internal */ inlineSourceMap?: boolean;
        /** @internal */ inlineSources?: boolean;
        /** @internal */ extendedDiagnostics?: boolean;
        /** @internal */ onlyPrintJsDocStyle?: boolean;
        /** @internal */ neverAsciiEscape?: boolean;
        /** @deprecated @internal */ writeBundleFileInfo?: boolean;
        /** @internal */ recordInternalSection?: boolean;
        /** @internal */ stripInternal?: boolean;
        /** @internal */ preserveSourceNewlines?: boolean;
        /** @internal */ terminateUnterminatedLiterals?: boolean;
        /** @internal */ relativeToBuildInfo?: (path: string) => string;
    }
    /** @internal */
    interface RawSourceMap {
        version: 3;
        file: string;
        sourceRoot?: string | null;
        sources: string[];
        sourcesContent?: (string | null)[] | null;
        mappings: string;
        names?: string[] | null;
    }
    /**
     * Generates a source map.
     *
     * @internal
     */
    interface SourceMapGenerator {
        getSources(): readonly string[];
        /**
         * Adds a source to the source map.
         */
        addSource(fileName: string): number;
        /**
         * Set the content for a source.
         */
        setSourceContent(sourceIndex: number, content: string | null): void;
        /**
         * Adds a name.
         */
        addName(name: string): number;
        /**
         * Adds a mapping without source information.
         */
        addMapping(generatedLine: number, generatedCharacter: number): void;
        /**
         * Adds a mapping with source information.
         */
        addMapping(generatedLine: number, generatedCharacter: number, sourceIndex: number, sourceLine: number, sourceCharacter: number, nameIndex?: number): void;
        /**
         * Appends a source map.
         */
        appendSourceMap(generatedLine: number, generatedCharacter: number, sourceMap: RawSourceMap, sourceMapPath: string, start?: LineAndCharacter, end?: LineAndCharacter): void;
        /**
         * Gets the source map as a `RawSourceMap` object.
         */
        toJSON(): RawSourceMap;
        /**
         * Gets the string representation of the source map.
         */
        toString(): string;
    }
    /** @internal */
    interface DocumentPositionMapperHost {
        getSourceFileLike(fileName: string): SourceFileLike | undefined;
        getCanonicalFileName(path: string): string;
        log(text: string): void;
    }
    /**
     * Maps positions between source and generated files.
     *
     * @internal
     */
    interface DocumentPositionMapper {
        getSourcePosition(input: DocumentPosition): DocumentPosition;
        getGeneratedPosition(input: DocumentPosition): DocumentPosition;
    }
    /** @internal */
    interface DocumentPosition {
        fileName: string;
        pos: number;
    }
    /** @internal */
    interface EmitTextWriter extends SymbolWriter {
        write(s: string): void;
        writeTrailingSemicolon(text: string): void;
        writeComment(text: string): void;
        getText(): string;
        rawWrite(s: string): void;
        writeLiteral(s: string): void;
        getTextPos(): number;
        getLine(): number;
        getColumn(): number;
        getIndent(): number;
        isAtStartOfLine(): boolean;
        hasTrailingComment(): boolean;
        hasTrailingWhitespace(): boolean;
        getTextPosWithWriteLine?(): number;
        nonEscapingWrite?(text: string): void;
    }
    interface GetEffectiveTypeRootsHost {
        directoryExists?(directoryName: string): boolean;
        getCurrentDirectory?(): string;
    }
    /** @internal */
    interface HasCurrentDirectory {
        getCurrentDirectory(): string;
    }
    /** @internal */
    interface ModuleSpecifierResolutionHost {
        useCaseSensitiveFileNames?(): boolean;
        fileExists(path: string): boolean;
        getCurrentDirectory(): string;
        directoryExists?(path: string): boolean;
        readFile?(path: string): string | undefined;
        realpath?(path: string): string;
        getSymlinkCache?(): SymlinkCache;
        getModuleSpecifierCache?(): ModuleSpecifierCache;
        getPackageJsonInfoCache?(): PackageJsonInfoCache | undefined;
        getGlobalTypingsCacheLocation?(): string | undefined;
        getNearestAncestorDirectoryWithPackageJson?(fileName: string, rootDir?: string): string | undefined;
        readonly redirectTargetsMap: RedirectTargetsMap;
        getProjectReferenceRedirect(fileName: string): string | undefined;
        isSourceOfProjectReferenceRedirect(fileName: string): boolean;
        getFileIncludeReasons(): MultiMap<Path, FileIncludeReason>;
    }
    /** @internal */
    interface ModulePath {
        path: string;
        isInNodeModules: boolean;
        isRedirect: boolean;
    }
    /** @internal */
    interface ResolvedModuleSpecifierInfo {
        modulePaths: readonly ModulePath[] | undefined;
        moduleSpecifiers: readonly string[] | undefined;
        isBlockedByPackageJsonDependencies: boolean | undefined;
    }
    /** @internal */
    interface ModuleSpecifierOptions {
        overrideImportMode?: ResolutionMode;
    }
    /** @internal */
    interface ModuleSpecifierCache {
        get(fromFileName: Path, toFileName: Path, preferences: UserPreferences, options: ModuleSpecifierOptions): Readonly<ResolvedModuleSpecifierInfo> | undefined;
        set(fromFileName: Path, toFileName: Path, preferences: UserPreferences, options: ModuleSpecifierOptions, modulePaths: readonly ModulePath[], moduleSpecifiers: readonly string[]): void;
        setBlockedByPackageJsonDependencies(fromFileName: Path, toFileName: Path, preferences: UserPreferences, options: ModuleSpecifierOptions, isBlockedByPackageJsonDependencies: boolean): void;
        setModulePaths(fromFileName: Path, toFileName: Path, preferences: UserPreferences, options: ModuleSpecifierOptions, modulePaths: readonly ModulePath[]): void;
        clear(): void;
        count(): number;
    }
    /** @internal */
    interface SymbolTracker {
        trackSymbol?(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean;
        reportInaccessibleThisError?(): void;
        reportPrivateInBaseOfClassExpression?(propertyName: string): void;
        reportInaccessibleUniqueSymbolError?(): void;
        reportCyclicStructureError?(): void;
        reportLikelyUnsafeImportRequiredError?(specifier: string): void;
        reportTruncationError?(): void;
        moduleResolverHost?: ModuleSpecifierResolutionHost & {
            getCommonSourceDirectory(): string;
        };
        trackReferencedAmbientModule?(decl: ModuleDeclaration, symbol: Symbol): void;
        trackExternalModuleSymbolOfImportTypeNode?(symbol: Symbol): void;
        reportNonlocalAugmentation?(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void;
        reportNonSerializableProperty?(propertyName: string): void;
        reportImportTypeNodeResolutionModeOverride?(): void;
    }
    interface TextSpan {
        start: number;
        length: number;
    }
    interface TextChangeRange {
        span: TextSpan;
        newLength: number;
    }
    /** @internal */
    interface DiagnosticCollection {
        add(diagnostic: Diagnostic): void;
        lookup(diagnostic: Diagnostic): Diagnostic | undefined;
        getGlobalDiagnostics(): Diagnostic[];
        getDiagnostics(): Diagnostic[];
        getDiagnostics(fileName: string): DiagnosticWithLocation[];
    }
    interface SyntaxList extends Node {
        kind: SyntaxKind.SyntaxList;
        _children: Node[];
    }
    enum ListFormat {
        None = 0,
        SingleLine = 0,
        MultiLine = 1,
        PreserveLines = 2,
        LinesMask = 3,
        NotDelimited = 0,
        BarDelimited = 4,
        AmpersandDelimited = 8,
        CommaDelimited = 16,
        AsteriskDelimited = 32,
        DelimitersMask = 60,
        AllowTrailingComma = 64,
        Indented = 128,
        SpaceBetweenBraces = 256,
        SpaceBetweenSiblings = 512,
        Braces = 1024,
        Parenthesis = 2048,
        AngleBrackets = 4096,
        SquareBrackets = 8192,
        BracketsMask = 15360,
        OptionalIfUndefined = 16384,
        OptionalIfEmpty = 32768,
        Optional = 49152,
        PreferNewLine = 65536,
        NoTrailingNewLine = 131072,
        NoInterveningComments = 262144,
        NoSpaceIfEmpty = 524288,
        SingleElement = 1048576,
        SpaceAfterList = 2097152,
        Modifiers = 2359808,
        HeritageClauses = 512,
        SingleLineTypeLiteralMembers = 768,
        MultiLineTypeLiteralMembers = 32897,
        SingleLineTupleTypeElements = 528,
        MultiLineTupleTypeElements = 657,
        UnionTypeConstituents = 516,
        IntersectionTypeConstituents = 520,
        ObjectBindingPatternElements = 525136,
        ArrayBindingPatternElements = 524880,
        ObjectLiteralExpressionProperties = 526226,
        ImportClauseEntries = 526226,
        ArrayLiteralExpressionElements = 8914,
        CommaListElements = 528,
        CallExpressionArguments = 2576,
        NewExpressionArguments = 18960,
        TemplateExpressionSpans = 262144,
        SingleLineBlockStatements = 768,
        MultiLineBlockStatements = 129,
        VariableDeclarationList = 528,
        SingleLineFunctionBodyStatements = 768,
        MultiLineFunctionBodyStatements = 1,
        ClassHeritageClauses = 0,
        ClassMembers = 129,
        InterfaceMembers = 129,
        EnumMembers = 145,
        CaseBlockClauses = 129,
        NamedImportsOrExportsElements = 525136,
        JsxElementOrFragmentChildren = 262144,
        JsxElementAttributes = 262656,
        CaseOrDefaultClauseStatements = 163969,
        HeritageClauseTypes = 528,
        SourceFileStatements = 131073,
        Decorators = 2146305,
        TypeArguments = 53776,
        TypeParameters = 53776,
        Parameters = 2576,
        IndexSignatureParameters = 8848,
        JSDocComment = 33
    }
    /** @internal */
    enum PragmaKindFlags {
        None = 0,
        /**
         * Triple slash comment of the form
         * /// <pragma-name argname="value" />
         */
        TripleSlashXML = 1,
        /**
         * Single line comment of the form
         * // @pragma-name argval1 argval2
         * or
         * /// @pragma-name argval1 argval2
         */
        SingleLine = 2,
        /**
         * Multiline non-jsdoc pragma of the form
         * /* @pragma-name argval1 argval2 * /
         */
        MultiLine = 4,
        All = 7,
        Default = 7
    }
    /** @internal */
    interface PragmaArgumentSpecification<TName extends string> {
        name: TName;
        optional?: boolean;
        captureSpan?: boolean;
    }
    /** @internal */
    interface PragmaDefinition<T1 extends string = string, T2 extends string = string, T3 extends string = string, T4 extends string = string> {
        args?: readonly [
            PragmaArgumentSpecification<T1>
        ] | readonly [
            PragmaArgumentSpecification<T1>,
            PragmaArgumentSpecification<T2>
        ] | readonly [
            PragmaArgumentSpecification<T1>,
            PragmaArgumentSpecification<T2>,
            PragmaArgumentSpecification<T3>
        ] | readonly [
            PragmaArgumentSpecification<T1>,
            PragmaArgumentSpecification<T2>,
            PragmaArgumentSpecification<T3>,
            PragmaArgumentSpecification<T4>
        ];
        kind?: PragmaKindFlags;
    }
    /** @internal */
    const commentPragmas: {
        readonly reference: {
            readonly args: readonly [
                {
                    readonly name: "types";
                    readonly optional: true;
                    readonly captureSpan: true;
                },
                {
                    readonly name: "lib";
                    readonly optional: true;
                    readonly captureSpan: true;
                },
                {
                    readonly name: "path";
                    readonly optional: true;
                    readonly captureSpan: true;
                },
                {
                    readonly name: "no-default-lib";
                    readonly optional: true;
                },
                {
                    readonly name: "resolution-mode";
                    readonly optional: true;
                }
            ];
            readonly kind: PragmaKindFlags.TripleSlashXML;
        };
        readonly "amd-dependency": {
            readonly args: readonly [
                {
                    readonly name: "path";
                },
                {
                    readonly name: "name";
                    readonly optional: true;
                }
            ];
            readonly kind: PragmaKindFlags.TripleSlashXML;
        };
        readonly "amd-module": {
            readonly args: readonly [
                {
                    readonly name: "name";
                }
            ];
            readonly kind: PragmaKindFlags.TripleSlashXML;
        };
        readonly "ts-check": {
            readonly kind: PragmaKindFlags.SingleLine;
        };
        readonly "ts-nocheck": {
            readonly kind: PragmaKindFlags.SingleLine;
        };
        readonly jsx: {
            readonly args: readonly [
                {
                    readonly name: "factory";
                }
            ];
            readonly kind: PragmaKindFlags.MultiLine;
        };
        readonly jsxfrag: {
            readonly args: readonly [
                {
                    readonly name: "factory";
                }
            ];
            readonly kind: PragmaKindFlags.MultiLine;
        };
        readonly jsximportsource: {
            readonly args: readonly [
                {
                    readonly name: "factory";
                }
            ];
            readonly kind: PragmaKindFlags.MultiLine;
        };
        readonly jsxruntime: {
            readonly args: readonly [
                {
                    readonly name: "factory";
                }
            ];
            readonly kind: PragmaKindFlags.MultiLine;
        };
    };
    /** @internal */
    type PragmaArgTypeMaybeCapture<TDesc> = TDesc extends {
        captureSpan: true;
    } ? {
        value: string;
        pos: number;
        end: number;
    } : string;
    /** @internal */
    type PragmaArgTypeOptional<TDesc, TName extends string> = TDesc extends {
        optional: true;
    } ? {
        [K in TName]?: PragmaArgTypeMaybeCapture<TDesc>;
    } : {
        [K in TName]: PragmaArgTypeMaybeCapture<TDesc>;
    };
    /** @internal */
    type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
    /** @internal */
    type ArgumentDefinitionToFieldUnion<T extends readonly PragmaArgumentSpecification<any>[]> = {
        [K in keyof T]: PragmaArgTypeOptional<T[K], T[K] extends {
            name: infer TName;
        } ? TName extends string ? TName : never : never>;
    }[Extract<keyof T, number>];
    /**
     * Maps a pragma definition into the desired shape for its arguments object
     *
     * @internal
     */
    type PragmaArgumentType<KPrag extends keyof ConcretePragmaSpecs> = ConcretePragmaSpecs[KPrag] extends {
        args: readonly PragmaArgumentSpecification<any>[];
    } ? UnionToIntersection<ArgumentDefinitionToFieldUnion<ConcretePragmaSpecs[KPrag]["args"]>> : never;
    /** @internal */
    type ConcretePragmaSpecs = typeof commentPragmas;
    /** @internal */
    type PragmaPseudoMap = {
        [K in keyof ConcretePragmaSpecs]: {
            arguments: PragmaArgumentType<K>;
            range: CommentRange;
        };
    };
    /** @internal */
    type PragmaPseudoMapEntry = {
        [K in keyof PragmaPseudoMap]: {
            name: K;
            args: PragmaPseudoMap[K];
        };
    }[keyof PragmaPseudoMap];
    /** @internal */
    interface ReadonlyPragmaMap extends ReadonlyMap<string, PragmaPseudoMap[keyof PragmaPseudoMap] | PragmaPseudoMap[keyof PragmaPseudoMap][]> {
        get<TKey extends keyof PragmaPseudoMap>(key: TKey): PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][];
        forEach(action: <TKey extends keyof PragmaPseudoMap>(value: PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][], key: TKey, map: ReadonlyPragmaMap) => void): void;
    }
    /**
     * A strongly-typed es6 map of pragma entries, the values of which are either a single argument
     * value (if only one was found), or an array of multiple argument values if the pragma is present
     * in multiple places
     *
     * @internal
     */
    interface PragmaMap extends Map<string, PragmaPseudoMap[keyof PragmaPseudoMap] | PragmaPseudoMap[keyof PragmaPseudoMap][]>, ReadonlyPragmaMap {
        set<TKey extends keyof PragmaPseudoMap>(key: TKey, value: PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][]): this;
        get<TKey extends keyof PragmaPseudoMap>(key: TKey): PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][];
        forEach(action: <TKey extends keyof PragmaPseudoMap>(value: PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][], key: TKey, map: PragmaMap) => void): void;
    }
    /** @internal */
    interface CommentDirectivesMap {
        getUnusedExpectations(): CommentDirective[];
        markUsed(matchedLine: number): boolean;
    }
    interface UserPreferences {
        readonly disableSuggestions?: boolean;
        readonly quotePreference?: "auto" | "double" | "single";
        readonly includeCompletionsForModuleExports?: boolean;
        readonly includeCompletionsForImportStatements?: boolean;
        readonly includeCompletionsWithSnippetText?: boolean;
        readonly includeAutomaticOptionalChainCompletions?: boolean;
        readonly includeCompletionsWithInsertText?: boolean;
        readonly includeCompletionsWithClassMemberSnippets?: boolean;
        readonly includeCompletionsWithObjectLiteralMethodSnippets?: boolean;
        readonly useLabelDetailsInCompletionEntries?: boolean;
        readonly allowIncompleteCompletions?: boolean;
        readonly importModuleSpecifierPreference?: "shortest" | "project-relative" | "relative" | "non-relative";
        /** Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js" */
        readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";
        readonly allowTextChangesInNewFiles?: boolean;
        readonly providePrefixAndSuffixTextForRename?: boolean;
        readonly includePackageJsonAutoImports?: "auto" | "on" | "off";
        readonly provideRefactorNotApplicableReason?: boolean;
        readonly jsxAttributeCompletionStyle?: "auto" | "braces" | "none";
        readonly includeInlayParameterNameHints?: "none" | "literals" | "all";
        readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;
        readonly includeInlayFunctionParameterTypeHints?: boolean;
        readonly includeInlayVariableTypeHints?: boolean;
        readonly includeInlayVariableTypeHintsWhenTypeMatchesName?: boolean;
        readonly includeInlayPropertyDeclarationTypeHints?: boolean;
        readonly includeInlayFunctionLikeReturnTypeHints?: boolean;
        readonly includeInlayEnumMemberValueHints?: boolean;
        readonly allowRenameOfImportPath?: boolean;
        readonly autoImportFileExcludePatterns?: string[];
        readonly organizeImportsIgnoreCase?: "auto" | boolean;
        readonly organizeImportsCollation?: "ordinal" | "unicode";
        readonly organizeImportsLocale?: string;
        readonly organizeImportsNumericCollation?: boolean;
        readonly organizeImportsAccentCollation?: boolean;
        readonly organizeImportsCaseFirst?: "upper" | "lower" | false;
    }
    /** Represents a bigint literal value without requiring bigint support */
    interface PseudoBigInt {
        negative: boolean;
        base10Value: string;
    }
    /** @internal */
    interface Queue<T> {
        enqueue(...items: T[]): void;
        dequeue(): T;
        isEmpty(): boolean;
    }
    /**
     * djb2 hashing algorithm
     * http://www.cse.yorku.ca/~oz/hash.html
     *
     * @internal
     */
    function generateDjb2Hash(data: string): string;
    /**
     * Set a high stack trace limit to provide more information in case of an error.
     * Called for command-line and server use cases.
     * Not called if TypeScript is used as a library.
     *
     * @internal
     */
    function setStackTraceLimit(): void;
    /** @internal */
    function getModifiedTime(host: {
        getModifiedTime: NonNullable<System["getModifiedTime"]>;
    }, fileName: string): Date;
    /** @internal */
    function getFileWatcherEventKind(oldTime: number, newTime: number): FileWatcherEventKind;
    /** @internal */
    function sysLog(s: string): void;
    /** @internal */
    function setSysLog(logger: typeof sysLog): void;
    /** @internal */
    function createSystemWatchFunctions({ pollingWatchFileWorker, getModifiedTime, setTimeout, clearTimeout, fsWatchWorker, fileSystemEntryExists, useCaseSensitiveFileNames, getCurrentDirectory, fsSupportsRecursiveFsWatch, getAccessibleSortedChildDirectories, realpath, tscWatchFile, useNonPollingWatchers, tscWatchDirectory, inodeWatching, sysLog, }: CreateSystemWatchFunctions): {
        watchFile: HostWatchFile;
        watchDirectory: HostWatchDirectory;
    };
    /**
     * patch writefile to create folder before writing the file
     *
     * @internal
     */
    function patchWriteFileEnsuringDirectory(sys: System): void;
    /** @internal */
    function setSys(s: System): void;
    enum FileWatcherEventKind {
        Created = 0,
        Changed = 1,
        Deleted = 2
    }
    type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind, modifiedTime?: Date) => void;
    type DirectoryWatcherCallback = (fileName: string) => void;
    /** @internal */
    enum PollingInterval {
        High = 2000,
        Medium = 500,
        Low = 250
    }
    /** @internal */
    type HostWatchFile = (fileName: string, callback: FileWatcherCallback, pollingInterval: PollingInterval, options: WatchOptions | undefined) => FileWatcher;
    /** @internal */
    type HostWatchDirectory = (fileName: string, callback: DirectoryWatcherCallback, recursive: boolean, options: WatchOptions | undefined) => FileWatcher;
    /** @internal */
    const missingFileModifiedTime: Date;
    /** @internal */
    let unchangedPollThresholds: {
        250: number;
        500: number;
        2000: number;
    };
    /** @internal */
    const ignoredPaths: string[];
    /** @internal */
    type FsWatchCallback = (eventName: "rename" | "change", relativeFileName: string | undefined, modifiedTime?: Date) => void;
    /** @internal */
    type FsWatch = (fileOrDirectory: string, entryKind: FileSystemEntryKind, callback: FsWatchCallback, recursive: boolean, fallbackPollingInterval: PollingInterval, fallbackOptions: WatchOptions | undefined) => FileWatcher;
    /** @internal */
    interface FsWatchWorkerWatcher extends FileWatcher {
        on(eventName: string, listener: () => void): void;
    }
    /** @internal */
    type FsWatchWorker = (fileOrDirectory: string, recursive: boolean, callback: FsWatchCallback) => FsWatchWorkerWatcher;
    /** @internal */
    enum FileSystemEntryKind {
        File = 0,
        Directory = 1
    }
    /** @internal */
    type FileSystemEntryExists = (fileorDirectrory: string, entryKind: FileSystemEntryKind) => boolean;
    /** @internal */
    interface CreateSystemWatchFunctions {
        pollingWatchFileWorker: HostWatchFile;
        getModifiedTime: NonNullable<System["getModifiedTime"]>;
        setTimeout: NonNullable<System["setTimeout"]>;
        clearTimeout: NonNullable<System["clearTimeout"]>;
        fsWatchWorker: FsWatchWorker;
        fileSystemEntryExists: FileSystemEntryExists;
        useCaseSensitiveFileNames: boolean;
        getCurrentDirectory: System["getCurrentDirectory"];
        fsSupportsRecursiveFsWatch: boolean;
        getAccessibleSortedChildDirectories(path: string): readonly string[];
        realpath(s: string): string;
        tscWatchFile: string | undefined;
        useNonPollingWatchers?: boolean;
        tscWatchDirectory: string | undefined;
        inodeWatching: boolean;
        sysLog: (s: string) => void;
    }
    type BufferEncoding = "ascii" | "utf8" | "utf-8" | "utf16le" | "ucs2" | "ucs-2" | "base64" | "latin1" | "binary" | "hex";
    /** @internal */
    interface NodeBuffer extends Uint8Array {
        constructor: any;
        write(str: string, encoding?: BufferEncoding): number;
        write(str: string, offset: number, encoding?: BufferEncoding): number;
        write(str: string, offset: number, length: number, encoding?: BufferEncoding): number;
        toString(encoding?: string, start?: number, end?: number): string;
        toJSON(): {
            type: "Buffer";
            data: number[];
        };
        equals(otherBuffer: Uint8Array): boolean;
        compare(otherBuffer: Uint8Array, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;
        copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
        slice(begin?: number, end?: number): Buffer;
        subarray(begin?: number, end?: number): Buffer;
        writeUIntLE(value: number, offset: number, byteLength: number): number;
        writeUIntBE(value: number, offset: number, byteLength: number): number;
        writeIntLE(value: number, offset: number, byteLength: number): number;
        writeIntBE(value: number, offset: number, byteLength: number): number;
        readUIntLE(offset: number, byteLength: number): number;
        readUIntBE(offset: number, byteLength: number): number;
        readIntLE(offset: number, byteLength: number): number;
        readIntBE(offset: number, byteLength: number): number;
        readUInt8(offset: number): number;
        readUInt16LE(offset: number): number;
        readUInt16BE(offset: number): number;
        readUInt32LE(offset: number): number;
        readUInt32BE(offset: number): number;
        readInt8(offset: number): number;
        readInt16LE(offset: number): number;
        readInt16BE(offset: number): number;
        readInt32LE(offset: number): number;
        readInt32BE(offset: number): number;
        readFloatLE(offset: number): number;
        readFloatBE(offset: number): number;
        readDoubleLE(offset: number): number;
        readDoubleBE(offset: number): number;
        reverse(): this;
        swap16(): Buffer;
        swap32(): Buffer;
        swap64(): Buffer;
        writeUInt8(value: number, offset: number): number;
        writeUInt16LE(value: number, offset: number): number;
        writeUInt16BE(value: number, offset: number): number;
        writeUInt32LE(value: number, offset: number): number;
        writeUInt32BE(value: number, offset: number): number;
        writeInt8(value: number, offset: number): number;
        writeInt16LE(value: number, offset: number): number;
        writeInt16BE(value: number, offset: number): number;
        writeInt32LE(value: number, offset: number): number;
        writeInt32BE(value: number, offset: number): number;
        writeFloatLE(value: number, offset: number): number;
        writeFloatBE(value: number, offset: number): number;
        writeDoubleLE(value: number, offset: number): number;
        writeDoubleBE(value: number, offset: number): number;
        readBigUInt64BE?(offset?: number): bigint;
        readBigUInt64LE?(offset?: number): bigint;
        readBigInt64BE?(offset?: number): bigint;
        readBigInt64LE?(offset?: number): bigint;
        writeBigInt64BE?(value: bigint, offset?: number): number;
        writeBigInt64LE?(value: bigint, offset?: number): number;
        writeBigUInt64BE?(value: bigint, offset?: number): number;
        writeBigUInt64LE?(value: bigint, offset?: number): number;
        fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;
        indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
        lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
        entries(): IterableIterator<[
            number,
            number
        ]>;
        includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
        keys(): IterableIterator<number>;
        values(): IterableIterator<number>;
    }
    /** @internal */
    interface Buffer extends NodeBuffer {
    }
    interface System {
        args: string[];
        newLine: string;
        useCaseSensitiveFileNames: boolean;
        write(s: string): void;
        writeOutputIsTTY?(): boolean;
        getWidthOfTerminal?(): number;
        readFile(path: string, encoding?: string): string | undefined;
        getFileSize?(path: string): number;
        writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;
        /**
         * @pollingInterval - this parameter is used in polling-based watchers and ignored in watchers that
         * use native OS file watching
         */
        watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
        watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
        resolvePath(path: string): string;
        fileExists(path: string): boolean;
        directoryExists(path: string): boolean;
        createDirectory(path: string): void;
        getExecutingFilePath(): string;
        getCurrentDirectory(): string;
        getDirectories(path: string): string[];
        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
        getModifiedTime?(path: string): Date | undefined;
        setModifiedTime?(path: string, time: Date): void;
        deleteFile?(path: string): void;
        /**
         * A good implementation is node.js' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)
         */
        createHash?(data: string): string;
        /** This must be cryptographically secure. Only implement this method using `crypto.createHash("sha256")`. */
        createSHA256Hash?(data: string): string;
        getMemoryUsage?(): number;
        exit(exitCode?: number): void;
        /** @internal */ enableCPUProfiler?(path: string, continuation: () => void): boolean;
        /** @internal */ disableCPUProfiler?(continuation: () => void): boolean;
        /** @internal */ cpuProfilingEnabled?(): boolean;
        realpath?(path: string): string;
        /** @internal */ getEnvironmentVariable(name: string): string;
        /** @internal */ tryEnableSourceMapsForHost?(): void;
        /** @internal */ debugMode?: boolean;
        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
        clearTimeout?(timeoutId: any): void;
        clearScreen?(): void;
        /** @internal */ setBlocking?(): void;
        base64decode?(input: string): string;
        base64encode?(input: string): string;
        /** @internal */ bufferFrom?(input: string, encoding?: string): Buffer;
        /** @internal */ require?(baseDir: string, moduleName: string): RequireResult;
        /** @internal */ now?(): Date;
        /** @internal */ storeFilesChangingSignatureDuringEmit?: boolean;
    }
    interface FileWatcher {
        close(): void;
    }
    let sys: System;
    /**
     * Determines whether a charCode corresponds to `/` or `\`.
     *
     * @internal
     */
    function isAnyDirectorySeparator(charCode: number): boolean;
    /**
     * Determines whether a path starts with a URL scheme (e.g. starts with `http://`, `ftp://`, `file://`, etc.).
     *
     * @internal
     */
    function isUrl(path: string): boolean;
    /**
     * Determines whether a path is an absolute disk path (e.g. starts with `/`, or a dos path
     * like `c:`, `c:\` or `c:/`).
     *
     * @internal
     */
    function isRootedDiskPath(path: string): boolean;
    /**
     * Determines whether a path consists only of a path root.
     *
     * @internal
     */
    function isDiskPathRoot(path: string): boolean;
    /**
     * Determines whether a path starts with an absolute path component (i.e. `/`, `c:/`, `file://`, etc.).
     *
     * ```ts
     * // POSIX
     * pathIsAbsolute("/path/to/file.ext") === true
     * // DOS
     * pathIsAbsolute("c:/path/to/file.ext") === true
     * // URL
     * pathIsAbsolute("file:///path/to/file.ext") === true
     * // Non-absolute
     * pathIsAbsolute("path/to/file.ext") === false
     * pathIsAbsolute("./path/to/file.ext") === false
     * ```
     *
     * @internal
     */
    function pathIsAbsolute(path: string): boolean;
    /**
     * Determines whether a path starts with a relative path component (i.e. `.` or `..`).
     *
     * @internal
     */
    function pathIsRelative(path: string): boolean;
    /**
     * Determines whether a path is neither relative nor absolute, e.g. "path/to/file".
     * Also known misleadingly as "non-relative".
     *
     * @internal
     */
    function pathIsBareSpecifier(path: string): boolean;
    /** @internal */
    function hasExtension(fileName: string): boolean;
    /** @internal */
    function fileExtensionIs(path: string, extension: string): boolean;
    /** @internal */
    function fileExtensionIsOneOf(path: string, extensions: readonly string[]): boolean;
    /**
     * Determines whether a path has a trailing separator (`/` or `\\`).
     *
     * @internal
     */
    function hasTrailingDirectorySeparator(path: string): boolean;
    /**
     * Returns length of the root part of a path or URL (i.e. length of "/", "x:/", "//server/share/, file:///user/files").
     *
     * For example:
     * ```ts
     * getRootLength("a") === 0                   // ""
     * getRootLength("/") === 1                   // "/"
     * getRootLength("c:") === 2                  // "c:"
     * getRootLength("c:d") === 0                 // ""
     * getRootLength("c:/") === 3                 // "c:/"
     * getRootLength("c:\\") === 3                // "c:\\"
     * getRootLength("//server") === 7            // "//server"
     * getRootLength("//server/share") === 8      // "//server/"
     * getRootLength("\\\\server") === 7          // "\\\\server"
     * getRootLength("\\\\server\\share") === 8   // "\\\\server\\"
     * getRootLength("file:///path") === 8        // "file:///"
     * getRootLength("file:///c:") === 10         // "file:///c:"
     * getRootLength("file:///c:d") === 8         // "file:///"
     * getRootLength("file:///c:/path") === 11    // "file:///c:/"
     * getRootLength("file://server") === 13      // "file://server"
     * getRootLength("file://server/path") === 14 // "file://server/"
     * getRootLength("http://server") === 13      // "http://server"
     * getRootLength("http://server/path") === 14 // "http://server/"
     * ```
     *
     * @internal
     */
    function getRootLength(path: string): number;
    /**
     * Returns the path except for its basename. Semantics align with NodeJS's `path.dirname`
     * except that we support URLs as well.
     *
     * ```ts
     * // POSIX
     * getDirectoryPath("/path/to/file.ext") === "/path/to"
     * getDirectoryPath("/path/to/") === "/path"
     * getDirectoryPath("/") === "/"
     * // DOS
     * getDirectoryPath("c:/path/to/file.ext") === "c:/path/to"
     * getDirectoryPath("c:/path/to/") === "c:/path"
     * getDirectoryPath("c:/") === "c:/"
     * getDirectoryPath("c:") === "c:"
     * // URL
     * getDirectoryPath("http://typescriptlang.org/path/to/file.ext") === "http://typescriptlang.org/path/to"
     * getDirectoryPath("http://typescriptlang.org/path/to") === "http://typescriptlang.org/path"
     * getDirectoryPath("http://typescriptlang.org/") === "http://typescriptlang.org/"
     * getDirectoryPath("http://typescriptlang.org") === "http://typescriptlang.org"
     * ```
     *
     * @internal
     */
    function getDirectoryPath(path: Path): Path;
    /**
     * Returns the path except for its basename. Semantics align with NodeJS's `path.dirname`
     * except that we support URLs as well.
     *
     * ```ts
     * // POSIX
     * getDirectoryPath("/path/to/file.ext") === "/path/to"
     * getDirectoryPath("/path/to/") === "/path"
     * getDirectoryPath("/") === "/"
     * // DOS
     * getDirectoryPath("c:/path/to/file.ext") === "c:/path/to"
     * getDirectoryPath("c:/path/to/") === "c:/path"
     * getDirectoryPath("c:/") === "c:/"
     * getDirectoryPath("c:") === "c:"
     * // URL
     * getDirectoryPath("http://typescriptlang.org/path/to/file.ext") === "http://typescriptlang.org/path/to"
     * getDirectoryPath("http://typescriptlang.org/path/to") === "http://typescriptlang.org/path"
     * getDirectoryPath("http://typescriptlang.org/") === "http://typescriptlang.org/"
     * getDirectoryPath("http://typescriptlang.org") === "http://typescriptlang.org"
     * getDirectoryPath("file://server/path/to/file.ext") === "file://server/path/to"
     * getDirectoryPath("file://server/path/to") === "file://server/path"
     * getDirectoryPath("file://server/") === "file://server/"
     * getDirectoryPath("file://server") === "file://server"
     * getDirectoryPath("file:///path/to/file.ext") === "file:///path/to"
     * getDirectoryPath("file:///path/to") === "file:///path"
     * getDirectoryPath("file:///") === "file:///"
     * getDirectoryPath("file://") === "file://"
     * ```
     *
     * @internal
     */
    function getDirectoryPath(path: string): string;
    /**
     * Returns the path except for its containing directory name.
     * Semantics align with NodeJS's `path.basename` except that we support URL's as well.
     *
     * ```ts
     * // POSIX
     * getBaseFileName("/path/to/file.ext") === "file.ext"
     * getBaseFileName("/path/to/") === "to"
     * getBaseFileName("/") === ""
     * // DOS
     * getBaseFileName("c:/path/to/file.ext") === "file.ext"
     * getBaseFileName("c:/path/to/") === "to"
     * getBaseFileName("c:/") === ""
     * getBaseFileName("c:") === ""
     * // URL
     * getBaseFileName("http://typescriptlang.org/path/to/file.ext") === "file.ext"
     * getBaseFileName("http://typescriptlang.org/path/to/") === "to"
     * getBaseFileName("http://typescriptlang.org/") === ""
     * getBaseFileName("http://typescriptlang.org") === ""
     * getBaseFileName("file://server/path/to/file.ext") === "file.ext"
     * getBaseFileName("file://server/path/to/") === "to"
     * getBaseFileName("file://server/") === ""
     * getBaseFileName("file://server") === ""
     * getBaseFileName("file:///path/to/file.ext") === "file.ext"
     * getBaseFileName("file:///path/to/") === "to"
     * getBaseFileName("file:///") === ""
     * getBaseFileName("file://") === ""
     * ```
     *
     * @internal
     */
    function getBaseFileName(path: string): string;
    /**
     * Gets the portion of a path following the last (non-terminal) separator (`/`).
     * Semantics align with NodeJS's `path.basename` except that we support URL's as well.
     * If the base name has any one of the provided extensions, it is removed.
     *
     * ```ts
     * getBaseFileName("/path/to/file.ext", ".ext", true) === "file"
     * getBaseFileName("/path/to/file.js", ".ext", true) === "file.js"
     * getBaseFileName("/path/to/file.js", [".ext", ".js"], true) === "file"
     * getBaseFileName("/path/to/file.ext", ".EXT", false) === "file.ext"
     * ```
     *
     * @internal
     */
    function getBaseFileName(path: string, extensions: string | readonly string[], ignoreCase: boolean): string;
    /**
     * Gets the file extension for a path.
     *
     * ```ts
     * getAnyExtensionFromPath("/path/to/file.ext") === ".ext"
     * getAnyExtensionFromPath("/path/to/file.ext/") === ".ext"
     * getAnyExtensionFromPath("/path/to/file") === ""
     * getAnyExtensionFromPath("/path/to.ext/file") === ""
     * ```
     *
     * @internal
     */
    function getAnyExtensionFromPath(path: string): string;
    /**
     * Gets the file extension for a path, provided it is one of the provided extensions.
     *
     * ```ts
     * getAnyExtensionFromPath("/path/to/file.ext", ".ext", true) === ".ext"
     * getAnyExtensionFromPath("/path/to/file.js", ".ext", true) === ""
     * getAnyExtensionFromPath("/path/to/file.js", [".ext", ".js"], true) === ".js"
     * getAnyExtensionFromPath("/path/to/file.ext", ".EXT", false) === ""
     *
     * @internal
     */
    function getAnyExtensionFromPath(path: string, extensions: string | readonly string[], ignoreCase: boolean): string;
    /**
     * Parse a path into an array containing a root component (at index 0) and zero or more path
     * components (at indices > 0). The result is not normalized.
     * If the path is relative, the root component is `""`.
     * If the path is absolute, the root component includes the first path separator (`/`).
     *
     * ```ts
     * // POSIX
     * getPathComponents("/path/to/file.ext") === ["/", "path", "to", "file.ext"]
     * getPathComponents("/path/to/") === ["/", "path", "to"]
     * getPathComponents("/") === ["/"]
     * // DOS
     * getPathComponents("c:/path/to/file.ext") === ["c:/", "path", "to", "file.ext"]
     * getPathComponents("c:/path/to/") === ["c:/", "path", "to"]
     * getPathComponents("c:/") === ["c:/"]
     * getPathComponents("c:") === ["c:"]
     * // URL
     * getPathComponents("http://typescriptlang.org/path/to/file.ext") === ["http://typescriptlang.org/", "path", "to", "file.ext"]
     * getPathComponents("http://typescriptlang.org/path/to/") === ["http://typescriptlang.org/", "path", "to"]
     * getPathComponents("http://typescriptlang.org/") === ["http://typescriptlang.org/"]
     * getPathComponents("http://typescriptlang.org") === ["http://typescriptlang.org"]
     * getPathComponents("file://server/path/to/file.ext") === ["file://server/", "path", "to", "file.ext"]
     * getPathComponents("file://server/path/to/") === ["file://server/", "path", "to"]
     * getPathComponents("file://server/") === ["file://server/"]
     * getPathComponents("file://server") === ["file://server"]
     * getPathComponents("file:///path/to/file.ext") === ["file:///", "path", "to", "file.ext"]
     * getPathComponents("file:///path/to/") === ["file:///", "path", "to"]
     * getPathComponents("file:///") === ["file:///"]
     * getPathComponents("file://") === ["file://"]
     * ```
     *
     * @internal
     */
    function getPathComponents(path: string, currentDirectory?: string): string[];
    /**
     * Formats a parsed path consisting of a root component (at index 0) and zero or more path
     * segments (at indices > 0).
     *
     * ```ts
     * getPathFromPathComponents(["/", "path", "to", "file.ext"]) === "/path/to/file.ext"
     * ```
     *
     * @internal
     */
    function getPathFromPathComponents(pathComponents: readonly string[]): string;
    /**
     * Normalize path separators, converting `\` into `/`.
     *
     * @internal
     */
    function normalizeSlashes(path: string): string;
    /**
     * Reduce an array of path components to a more simplified path by navigating any
     * `"."` or `".."` entries in the path.
     *
     * @internal
     */
    function reducePathComponents(components: readonly string[]): string[];
    /**
     * Combines paths. If a path is absolute, it replaces any previous path. Relative paths are not simplified.
     *
     * ```ts
     * // Non-rooted
     * combinePaths("path", "to", "file.ext") === "path/to/file.ext"
     * combinePaths("path", "dir", "..", "to", "file.ext") === "path/dir/../to/file.ext"
     * // POSIX
     * combinePaths("/path", "to", "file.ext") === "/path/to/file.ext"
     * combinePaths("/path", "/to", "file.ext") === "/to/file.ext"
     * // DOS
     * combinePaths("c:/path", "to", "file.ext") === "c:/path/to/file.ext"
     * combinePaths("c:/path", "c:/to", "file.ext") === "c:/to/file.ext"
     * // URL
     * combinePaths("file:///path", "to", "file.ext") === "file:///path/to/file.ext"
     * combinePaths("file:///path", "file:///to", "file.ext") === "file:///to/file.ext"
     * ```
     *
     * @internal
     */
    function combinePaths(path: string, ...paths: (string | undefined)[]): string;
    /**
     * Combines and resolves paths. If a path is absolute, it replaces any previous path. Any
     * `.` and `..` path components are resolved. Trailing directory separators are preserved.
     *
     * ```ts
     * resolvePath("/path", "to", "file.ext") === "path/to/file.ext"
     * resolvePath("/path", "to", "file.ext/") === "path/to/file.ext/"
     * resolvePath("/path", "dir", "..", "to", "file.ext") === "path/to/file.ext"
     * ```
     *
     * @internal
     */
    function resolvePath(path: string, ...paths: (string | undefined)[]): string;
    /**
     * Parse a path into an array containing a root component (at index 0) and zero or more path
     * components (at indices > 0). The result is normalized.
     * If the path is relative, the root component is `""`.
     * If the path is absolute, the root component includes the first path separator (`/`).
     *
     * ```ts
     * getNormalizedPathComponents("to/dir/../file.ext", "/path/") === ["/", "path", "to", "file.ext"]
     * ```
     *
     * @internal
     */
    function getNormalizedPathComponents(path: string, currentDirectory: string | undefined): string[];
    /** @internal */
    function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string;
    /** @internal */
    function normalizePath(path: string): string;
    /** @internal */
    function getNormalizedAbsolutePathWithoutRoot(fileName: string, currentDirectory: string | undefined): string;
    /** @internal */
    function toPath(fileName: string, basePath: string | undefined, getCanonicalFileName: (path: string) => string): Path;
    /**
     * Removes a trailing directory separator from a path, if it does not already have one.
     *
     * ```ts
     * removeTrailingDirectorySeparator("/path/to/file.ext") === "/path/to/file.ext"
     * removeTrailingDirectorySeparator("/path/to/file.ext/") === "/path/to/file.ext"
     * ```
     *
     * @internal
     */
    function removeTrailingDirectorySeparator(path: Path): Path;
    /** @internal */
    function removeTrailingDirectorySeparator(path: string): string;
    /**
     * Adds a trailing directory separator to a path, if it does not already have one.
     *
     * ```ts
     * ensureTrailingDirectorySeparator("/path/to/file.ext") === "/path/to/file.ext/"
     * ensureTrailingDirectorySeparator("/path/to/file.ext/") === "/path/to/file.ext/"
     * ```
     *
     * @internal
     */
    function ensureTrailingDirectorySeparator(path: Path): Path;
    /** @internal */
    function ensureTrailingDirectorySeparator(path: string): string;
    /**
     * Ensures a path is either absolute (prefixed with `/` or `c:`) or dot-relative (prefixed
     * with `./` or `../`) so as not to be confused with an unprefixed module name.
     *
     * ```ts
     * ensurePathIsNonModuleName("/path/to/file.ext") === "/path/to/file.ext"
     * ensurePathIsNonModuleName("./path/to/file.ext") === "./path/to/file.ext"
     * ensurePathIsNonModuleName("../path/to/file.ext") === "../path/to/file.ext"
     * ensurePathIsNonModuleName("path/to/file.ext") === "./path/to/file.ext"
     * ```
     *
     * @internal
     */
    function ensurePathIsNonModuleName(path: string): string;
    /**
     * Changes the extension of a path to the provided extension.
     *
     * ```ts
     * changeAnyExtension("/path/to/file.ext", ".js") === "/path/to/file.js"
     * ```
     *
     * @internal
     */
    function changeAnyExtension(path: string, ext: string): string;
    /**
     * Changes the extension of a path to the provided extension if it has one of the provided extensions.
     *
     * ```ts
     * changeAnyExtension("/path/to/file.ext", ".js", ".ext") === "/path/to/file.js"
     * changeAnyExtension("/path/to/file.ext", ".js", ".ts") === "/path/to/file.ext"
     * changeAnyExtension("/path/to/file.ext", ".js", [".ext", ".ts"]) === "/path/to/file.js"
     * ```
     *
     * @internal
     */
    function changeAnyExtension(path: string, ext: string, extensions: string | readonly string[], ignoreCase: boolean): string;
    /**
     * Performs a case-sensitive comparison of two paths. Path roots are always compared case-insensitively.
     *
     * @internal
     */
    function comparePathsCaseSensitive(a: string, b: string): Comparison;
    /**
     * Performs a case-insensitive comparison of two paths.
     *
     * @internal
     */
    function comparePathsCaseInsensitive(a: string, b: string): Comparison;
    /**
     * Compare two paths using the provided case sensitivity.
     *
     * @internal
     */
    function comparePaths(a: string, b: string, ignoreCase?: boolean): Comparison;
    /** @internal */
    function comparePaths(a: string, b: string, currentDirectory: string, ignoreCase?: boolean): Comparison;
    /**
     * Determines whether a `parent` path contains a `child` path using the provide case sensitivity.
     *
     * @internal
     */
    function containsPath(parent: string, child: string, ignoreCase?: boolean): boolean;
    /** @internal */
    function containsPath(parent: string, child: string, currentDirectory: string, ignoreCase?: boolean): boolean;
    /**
     * Determines whether `fileName` starts with the specified `directoryName` using the provided path canonicalization callback.
     * Comparison is case-sensitive between the canonical paths.
     *
     * Use `containsPath` if file names are not already reduced and absolute.
     *
     * @internal
     */
    function startsWithDirectory(fileName: string, directoryName: string, getCanonicalFileName: GetCanonicalFileName): boolean;
    /** @internal */
    function getPathComponentsRelativeTo(from: string, to: string, stringEqualityComparer: (a: string, b: string) => boolean, getCanonicalFileName: GetCanonicalFileName): string[];
    /**
     * Gets a relative path that can be used to traverse between `from` and `to`.
     *
     * @internal
     */
    function getRelativePathFromDirectory(from: string, to: string, ignoreCase: boolean): string;
    /**
     * Gets a relative path that can be used to traverse between `from` and `to`.
     *
     * @internal
     */
    function getRelativePathFromDirectory(fromDirectory: string, to: string, getCanonicalFileName: GetCanonicalFileName): string;
    /** @internal */
    function convertToRelativePath(absoluteOrRelativePath: string, basePath: string, getCanonicalFileName: (path: string) => string): string;
    /** @internal */
    function getRelativePathFromFile(from: string, to: string, getCanonicalFileName: GetCanonicalFileName): string;
    /** @internal */
    function getRelativePathToDirectoryOrUrl(directoryPathOrUrl: string, relativeOrAbsolutePath: string, currentDirectory: string, getCanonicalFileName: GetCanonicalFileName, isAbsolutePathAnUrl: boolean): string;
    /**
     * Calls `callback` on `directory` and every ancestor directory it has, returning the first defined result.
     *
     * @internal
     */
    function forEachAncestorDirectory<T>(directory: Path, callback: (directory: Path) => T | undefined): T | undefined;
    /** @internal */
    function forEachAncestorDirectory<T>(directory: string, callback: (directory: string) => T | undefined): T | undefined;
    /** @internal */
    function isNodeModulesDirectory(dirPath: Path): boolean;
    /**
     * Internally, we represent paths as strings with '/' as the directory separator.
     * When we make system calls (eg: LanguageServiceHost.getDirectory()),
     * we expect the host to correctly handle paths in our specified format.
     *
     * @internal
     */
    const directorySeparator = "/";
    /** @internal */
    const altDirectorySeparator = "\\";
    /** @internal */
    const Diagnostics: {
        Unterminated_string_literal: DiagnosticMessage;
        Identifier_expected: DiagnosticMessage;
        _0_expected: DiagnosticMessage;
        A_file_cannot_have_a_reference_to_itself: DiagnosticMessage;
        The_parser_expected_to_find_a_1_to_match_the_0_token_here: DiagnosticMessage;
        Trailing_comma_not_allowed: DiagnosticMessage;
        Asterisk_Slash_expected: DiagnosticMessage;
        An_element_access_expression_should_take_an_argument: DiagnosticMessage;
        Unexpected_token: DiagnosticMessage;
        A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma: DiagnosticMessage;
        A_rest_parameter_must_be_last_in_a_parameter_list: DiagnosticMessage;
        Parameter_cannot_have_question_mark_and_initializer: DiagnosticMessage;
        A_required_parameter_cannot_follow_an_optional_parameter: DiagnosticMessage;
        An_index_signature_cannot_have_a_rest_parameter: DiagnosticMessage;
        An_index_signature_parameter_cannot_have_an_accessibility_modifier: DiagnosticMessage;
        An_index_signature_parameter_cannot_have_a_question_mark: DiagnosticMessage;
        An_index_signature_parameter_cannot_have_an_initializer: DiagnosticMessage;
        An_index_signature_must_have_a_type_annotation: DiagnosticMessage;
        An_index_signature_parameter_must_have_a_type_annotation: DiagnosticMessage;
        readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature: DiagnosticMessage;
        An_index_signature_cannot_have_a_trailing_comma: DiagnosticMessage;
        Accessibility_modifier_already_seen: DiagnosticMessage;
        _0_modifier_must_precede_1_modifier: DiagnosticMessage;
        _0_modifier_already_seen: DiagnosticMessage;
        _0_modifier_cannot_appear_on_class_elements_of_this_kind: DiagnosticMessage;
        super_must_be_followed_by_an_argument_list_or_member_access: DiagnosticMessage;
        Only_ambient_modules_can_use_quoted_names: DiagnosticMessage;
        Statements_are_not_allowed_in_ambient_contexts: DiagnosticMessage;
        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: DiagnosticMessage;
        Initializers_are_not_allowed_in_ambient_contexts: DiagnosticMessage;
        _0_modifier_cannot_be_used_in_an_ambient_context: DiagnosticMessage;
        _0_modifier_cannot_be_used_here: DiagnosticMessage;
        _0_modifier_cannot_appear_on_a_module_or_namespace_element: DiagnosticMessage;
        Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier: DiagnosticMessage;
        A_rest_parameter_cannot_be_optional: DiagnosticMessage;
        A_rest_parameter_cannot_have_an_initializer: DiagnosticMessage;
        A_set_accessor_must_have_exactly_one_parameter: DiagnosticMessage;
        A_set_accessor_cannot_have_an_optional_parameter: DiagnosticMessage;
        A_set_accessor_parameter_cannot_have_an_initializer: DiagnosticMessage;
        A_set_accessor_cannot_have_rest_parameter: DiagnosticMessage;
        A_get_accessor_cannot_have_parameters: DiagnosticMessage;
        Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value: DiagnosticMessage;
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: DiagnosticMessage;
        The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: DiagnosticMessage;
        A_promise_must_have_a_then_method: DiagnosticMessage;
        The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback: DiagnosticMessage;
        Enum_member_must_have_initializer: DiagnosticMessage;
        Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method: DiagnosticMessage;
        An_export_assignment_cannot_be_used_in_a_namespace: DiagnosticMessage;
        The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0: DiagnosticMessage;
        In_ambient_enum_declarations_member_initializer_must_be_constant_expression: DiagnosticMessage;
        Unexpected_token_A_constructor_method_accessor_or_property_was_expected: DiagnosticMessage;
        Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces: DiagnosticMessage;
        _0_modifier_cannot_appear_on_a_type_member: DiagnosticMessage;
        _0_modifier_cannot_appear_on_an_index_signature: DiagnosticMessage;
        A_0_modifier_cannot_be_used_with_an_import_declaration: DiagnosticMessage;
        Invalid_reference_directive_syntax: DiagnosticMessage;
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0: DiagnosticMessage;
        _0_modifier_cannot_appear_on_a_constructor_declaration: DiagnosticMessage;
        _0_modifier_cannot_appear_on_a_parameter: DiagnosticMessage;
        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: DiagnosticMessage;
        Type_parameters_cannot_appear_on_a_constructor_declaration: DiagnosticMessage;
        Type_annotation_cannot_appear_on_a_constructor_declaration: DiagnosticMessage;
        An_accessor_cannot_have_type_parameters: DiagnosticMessage;
        A_set_accessor_cannot_have_a_return_type_annotation: DiagnosticMessage;
        An_index_signature_must_have_exactly_one_parameter: DiagnosticMessage;
        _0_list_cannot_be_empty: DiagnosticMessage;
        Type_parameter_list_cannot_be_empty: DiagnosticMessage;
        Type_argument_list_cannot_be_empty: DiagnosticMessage;
        Invalid_use_of_0_in_strict_mode: DiagnosticMessage;
        with_statements_are_not_allowed_in_strict_mode: DiagnosticMessage;
        delete_cannot_be_called_on_an_identifier_in_strict_mode: DiagnosticMessage;
        for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: DiagnosticMessage;
        A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: DiagnosticMessage;
        A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: DiagnosticMessage;
        The_left_hand_side_of_a_for_of_statement_may_not_be_async: DiagnosticMessage;
        Jump_target_cannot_cross_function_boundary: DiagnosticMessage;
        A_return_statement_can_only_be_used_within_a_function_body: DiagnosticMessage;
        Expression_expected: DiagnosticMessage;
        Type_expected: DiagnosticMessage;
        A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: DiagnosticMessage;
        Duplicate_label_0: DiagnosticMessage;
        A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: DiagnosticMessage;
        A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: DiagnosticMessage;
        An_object_literal_cannot_have_multiple_properties_with_the_same_name: DiagnosticMessage;
        An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: DiagnosticMessage;
        An_object_literal_cannot_have_property_and_accessor_with_the_same_name: DiagnosticMessage;
        An_export_assignment_cannot_have_modifiers: DiagnosticMessage;
        Octal_literals_are_not_allowed_in_strict_mode: DiagnosticMessage;
        Variable_declaration_list_cannot_be_empty: DiagnosticMessage;
        Digit_expected: DiagnosticMessage;
        Hexadecimal_digit_expected: DiagnosticMessage;
        Unexpected_end_of_text: DiagnosticMessage;
        Invalid_character: DiagnosticMessage;
        Declaration_or_statement_expected: DiagnosticMessage;
        Statement_expected: DiagnosticMessage;
        case_or_default_expected: DiagnosticMessage;
        Property_or_signature_expected: DiagnosticMessage;
        Enum_member_expected: DiagnosticMessage;
        Variable_declaration_expected: DiagnosticMessage;
        Argument_expression_expected: DiagnosticMessage;
        Property_assignment_expected: DiagnosticMessage;
        Expression_or_comma_expected: DiagnosticMessage;
        Parameter_declaration_expected: DiagnosticMessage;
        Type_parameter_declaration_expected: DiagnosticMessage;
        Type_argument_expected: DiagnosticMessage;
        String_literal_expected: DiagnosticMessage;
        Line_break_not_permitted_here: DiagnosticMessage;
        or_expected: DiagnosticMessage;
        or_JSX_element_expected: DiagnosticMessage;
        Declaration_expected: DiagnosticMessage;
        Import_declarations_in_a_namespace_cannot_reference_a_module: DiagnosticMessage;
        Cannot_use_imports_exports_or_module_augmentations_when_module_is_none: DiagnosticMessage;
        File_name_0_differs_from_already_included_file_name_1_only_in_casing: DiagnosticMessage;
        const_declarations_must_be_initialized: DiagnosticMessage;
        const_declarations_can_only_be_declared_inside_a_block: DiagnosticMessage;
        let_declarations_can_only_be_declared_inside_a_block: DiagnosticMessage;
        Unterminated_template_literal: DiagnosticMessage;
        Unterminated_regular_expression_literal: DiagnosticMessage;
        An_object_member_cannot_be_declared_optional: DiagnosticMessage;
        A_yield_expression_is_only_allowed_in_a_generator_body: DiagnosticMessage;
        Computed_property_names_are_not_allowed_in_enums: DiagnosticMessage;
        A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: DiagnosticMessage;
        A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type: DiagnosticMessage;
        A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: DiagnosticMessage;
        A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: DiagnosticMessage;
        A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: DiagnosticMessage;
        A_comma_expression_is_not_allowed_in_a_computed_property_name: DiagnosticMessage;
        extends_clause_already_seen: DiagnosticMessage;
        extends_clause_must_precede_implements_clause: DiagnosticMessage;
        Classes_can_only_extend_a_single_class: DiagnosticMessage;
        implements_clause_already_seen: DiagnosticMessage;
        Interface_declaration_cannot_have_implements_clause: DiagnosticMessage;
        Binary_digit_expected: DiagnosticMessage;
        Octal_digit_expected: DiagnosticMessage;
        Unexpected_token_expected: DiagnosticMessage;
        Property_destructuring_pattern_expected: DiagnosticMessage;
        Array_element_destructuring_pattern_expected: DiagnosticMessage;
        A_destructuring_declaration_must_have_an_initializer: DiagnosticMessage;
        An_implementation_cannot_be_declared_in_ambient_contexts: DiagnosticMessage;
        Modifiers_cannot_appear_here: DiagnosticMessage;
        Merge_conflict_marker_encountered: DiagnosticMessage;
        A_rest_element_cannot_have_an_initializer: DiagnosticMessage;
        A_parameter_property_may_not_be_declared_using_a_binding_pattern: DiagnosticMessage;
        Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement: DiagnosticMessage;
        The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer: DiagnosticMessage;
        The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer: DiagnosticMessage;
        An_import_declaration_cannot_have_modifiers: DiagnosticMessage;
        Module_0_has_no_default_export: DiagnosticMessage;
        An_export_declaration_cannot_have_modifiers: DiagnosticMessage;
        Export_declarations_are_not_permitted_in_a_namespace: DiagnosticMessage;
        export_Asterisk_does_not_re_export_a_default: DiagnosticMessage;
        Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified: DiagnosticMessage;
        Catch_clause_variable_cannot_have_an_initializer: DiagnosticMessage;
        An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive: DiagnosticMessage;
        Unterminated_Unicode_escape_sequence: DiagnosticMessage;
        Line_terminator_not_permitted_before_arrow: DiagnosticMessage;
        Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead: DiagnosticMessage;
        Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead: DiagnosticMessage;
        Re_exporting_a_type_when_0_is_enabled_requires_using_export_type: DiagnosticMessage;
        Decorators_are_not_valid_here: DiagnosticMessage;
        Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name: DiagnosticMessage;
        Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0: DiagnosticMessage;
        Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode: DiagnosticMessage;
        A_class_declaration_without_the_default_modifier_must_have_a_name: DiagnosticMessage;
        Identifier_expected_0_is_a_reserved_word_in_strict_mode: DiagnosticMessage;
        Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode: DiagnosticMessage;
        Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode: DiagnosticMessage;
        Invalid_use_of_0_Modules_are_automatically_in_strict_mode: DiagnosticMessage;
        Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules: DiagnosticMessage;
        Export_assignment_is_not_supported_when_module_flag_is_system: DiagnosticMessage;
        Generators_are_not_allowed_in_an_ambient_context: DiagnosticMessage;
        An_overload_signature_cannot_be_declared_as_a_generator: DiagnosticMessage;
        _0_tag_already_specified: DiagnosticMessage;
        Signature_0_must_be_a_type_predicate: DiagnosticMessage;
        Cannot_find_parameter_0: DiagnosticMessage;
        Type_predicate_0_is_not_assignable_to_1: DiagnosticMessage;
        Parameter_0_is_not_in_the_same_position_as_parameter_1: DiagnosticMessage;
        A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods: DiagnosticMessage;
        A_type_predicate_cannot_reference_a_rest_parameter: DiagnosticMessage;
        A_type_predicate_cannot_reference_element_0_in_a_binding_pattern: DiagnosticMessage;
        An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration: DiagnosticMessage;
        An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: DiagnosticMessage;
        An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: DiagnosticMessage;
        An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file: DiagnosticMessage;
        A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module: DiagnosticMessage;
        The_return_type_of_a_property_decorator_function_must_be_either_void_or_any: DiagnosticMessage;
        The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any: DiagnosticMessage;
        Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression: DiagnosticMessage;
        Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression: DiagnosticMessage;
        Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression: DiagnosticMessage;
        Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression: DiagnosticMessage;
        abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration: DiagnosticMessage;
        _0_modifier_cannot_be_used_with_1_modifier: DiagnosticMessage;
        Abstract_methods_can_only_appear_within_an_abstract_class: DiagnosticMessage;
        Method_0_cannot_have_an_implementation_because_it_is_marked_abstract: DiagnosticMessage;
        An_interface_property_cannot_have_an_initializer: DiagnosticMessage;
        A_type_literal_property_cannot_have_an_initializer: DiagnosticMessage;
        A_class_member_cannot_have_the_0_keyword: DiagnosticMessage;
        A_decorator_can_only_decorate_a_method_implementation_not_an_overload: DiagnosticMessage;
        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5: DiagnosticMessage;
        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode: DiagnosticMessage;
        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode: DiagnosticMessage;
        A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference: DiagnosticMessage;
        A_definite_assignment_assertion_is_not_permitted_in_this_context: DiagnosticMessage;
        A_required_element_cannot_follow_an_optional_element: DiagnosticMessage;
        A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration: DiagnosticMessage;
        Module_0_can_only_be_default_imported_using_the_1_flag: DiagnosticMessage;
        Keywords_cannot_contain_escape_characters: DiagnosticMessage;
        Already_included_file_name_0_differs_from_file_name_1_only_in_casing: DiagnosticMessage;
        Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module: DiagnosticMessage;
        Declarations_with_initializers_cannot_also_have_definite_assignment_assertions: DiagnosticMessage;
        Declarations_with_definite_assignment_assertions_must_also_have_type_annotations: DiagnosticMessage;
        A_rest_element_cannot_follow_another_rest_element: DiagnosticMessage;
        An_optional_element_cannot_follow_a_rest_element: DiagnosticMessage;
        Property_0_cannot_have_an_initializer_because_it_is_marked_abstract: DiagnosticMessage;
        An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type: DiagnosticMessage;
        Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled: DiagnosticMessage;
        Decorator_function_return_type_0_is_not_assignable_to_type_1: DiagnosticMessage;
        Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any: DiagnosticMessage;
        A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled: DiagnosticMessage;
        _0_modifier_cannot_appear_on_a_type_parameter: DiagnosticMessage;
        _0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias: DiagnosticMessage;
        accessor_modifier_can_only_appear_on_a_property_declaration: DiagnosticMessage;
        An_accessor_property_cannot_be_declared_optional: DiagnosticMessage;
        _0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class: DiagnosticMessage;
        The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0: DiagnosticMessage;
        The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0: DiagnosticMessage;
        Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement: DiagnosticMessage;
        Cannot_access_0_from_another_file_without_qualification_when_1_is_enabled_Use_2_instead: DiagnosticMessage;
        An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type: DiagnosticMessage;
        An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration: DiagnosticMessage;
        An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type: DiagnosticMessage;
        An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration: DiagnosticMessage;
        ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled: DiagnosticMessage;
        A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled: DiagnosticMessage;
        An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled: DiagnosticMessage;
        with_statements_are_not_allowed_in_an_async_function_block: DiagnosticMessage;
        await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: DiagnosticMessage;
        The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level: DiagnosticMessage;
        Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern: DiagnosticMessage;
        The_body_of_an_if_statement_cannot_be_the_empty_statement: DiagnosticMessage;
        Global_module_exports_may_only_appear_in_module_files: DiagnosticMessage;
        Global_module_exports_may_only_appear_in_declaration_files: DiagnosticMessage;
        Global_module_exports_may_only_appear_at_top_level: DiagnosticMessage;
        A_parameter_property_cannot_be_declared_using_a_rest_parameter: DiagnosticMessage;
        An_abstract_accessor_cannot_have_an_implementation: DiagnosticMessage;
        A_default_export_can_only_be_used_in_an_ECMAScript_style_module: DiagnosticMessage;
        Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: DiagnosticMessage;
        Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: DiagnosticMessage;
        Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: DiagnosticMessage;
        Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext: DiagnosticMessage;
        Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nodenext: DiagnosticMessage;
        Argument_of_dynamic_import_cannot_be_spread_element: DiagnosticMessage;
        This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments: DiagnosticMessage;
        String_literal_with_double_quotes_expected: DiagnosticMessage;
        Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal: DiagnosticMessage;
        _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0: DiagnosticMessage;
        A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly: DiagnosticMessage;
        A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly: DiagnosticMessage;
        A_variable_whose_type_is_a_unique_symbol_type_must_be_const: DiagnosticMessage;
        unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name: DiagnosticMessage;
        unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement: DiagnosticMessage;
        unique_symbol_types_are_not_allowed_here: DiagnosticMessage;
        An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead: DiagnosticMessage;
        infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type: DiagnosticMessage;
        Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here: DiagnosticMessage;
        Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0: DiagnosticMessage;
        Class_constructor_may_not_be_an_accessor: DiagnosticMessage;
        The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext: DiagnosticMessage;
        A_label_is_not_allowed_here: DiagnosticMessage;
        An_expression_of_type_void_cannot_be_tested_for_truthiness: DiagnosticMessage;
        This_parameter_is_not_allowed_with_use_strict_directive: DiagnosticMessage;
        use_strict_directive_cannot_be_used_with_non_simple_parameter_list: DiagnosticMessage;
        Non_simple_parameter_declared_here: DiagnosticMessage;
        use_strict_directive_used_here: DiagnosticMessage;
        Print_the_final_configuration_instead_of_building: DiagnosticMessage;
        An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal: DiagnosticMessage;
        A_bigint_literal_cannot_use_exponential_notation: DiagnosticMessage;
        A_bigint_literal_must_be_an_integer: DiagnosticMessage;
        readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types: DiagnosticMessage;
        A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals: DiagnosticMessage;
        Did_you_mean_to_mark_this_function_as_async: DiagnosticMessage;
        An_enum_member_name_must_be_followed_by_a_or: DiagnosticMessage;
        Tagged_template_expressions_are_not_permitted_in_an_optional_chain: DiagnosticMessage;
        Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here: DiagnosticMessage;
        Type_0_does_not_satisfy_the_expected_type_1: DiagnosticMessage;
        _0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type: DiagnosticMessage;
        _0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type: DiagnosticMessage;
        A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both: DiagnosticMessage;
        Convert_to_type_only_export: DiagnosticMessage;
        Convert_all_re_exported_types_to_type_only_exports: DiagnosticMessage;
        Split_into_two_separate_import_declarations: DiagnosticMessage;
        Split_all_invalid_type_only_imports: DiagnosticMessage;
        Class_constructor_may_not_be_a_generator: DiagnosticMessage;
        Did_you_mean_0: DiagnosticMessage;
        This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error: DiagnosticMessage;
        Convert_to_type_only_import: DiagnosticMessage;
        Convert_all_imports_not_used_as_a_value_to_type_only_imports: DiagnosticMessage;
        await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: DiagnosticMessage;
        _0_was_imported_here: DiagnosticMessage;
        _0_was_exported_here: DiagnosticMessage;
        Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher: DiagnosticMessage;
        An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type: DiagnosticMessage;
        An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type: DiagnosticMessage;
        Unexpected_token_Did_you_mean_or_rbrace: DiagnosticMessage;
        Unexpected_token_Did_you_mean_or_gt: DiagnosticMessage;
        Function_type_notation_must_be_parenthesized_when_used_in_a_union_type: DiagnosticMessage;
        Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type: DiagnosticMessage;
        Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: DiagnosticMessage;
        Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: DiagnosticMessage;
        _0_is_not_allowed_as_a_variable_declaration_name: DiagnosticMessage;
        _0_is_not_allowed_as_a_parameter_name: DiagnosticMessage;
        An_import_alias_cannot_use_import_type: DiagnosticMessage;
        Imported_via_0_from_file_1: DiagnosticMessage;
        Imported_via_0_from_file_1_with_packageId_2: DiagnosticMessage;
        Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions: DiagnosticMessage;
        Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions: DiagnosticMessage;
        Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions: DiagnosticMessage;
        Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions: DiagnosticMessage;
        File_is_included_via_import_here: DiagnosticMessage;
        Referenced_via_0_from_file_1: DiagnosticMessage;
        File_is_included_via_reference_here: DiagnosticMessage;
        Type_library_referenced_via_0_from_file_1: DiagnosticMessage;
        Type_library_referenced_via_0_from_file_1_with_packageId_2: DiagnosticMessage;
        File_is_included_via_type_library_reference_here: DiagnosticMessage;
        Library_referenced_via_0_from_file_1: DiagnosticMessage;
        File_is_included_via_library_reference_here: DiagnosticMessage;
        Matched_by_include_pattern_0_in_1: DiagnosticMessage;
        File_is_matched_by_include_pattern_specified_here: DiagnosticMessage;
        Part_of_files_list_in_tsconfig_json: DiagnosticMessage;
        File_is_matched_by_files_list_specified_here: DiagnosticMessage;
        Output_from_referenced_project_0_included_because_1_specified: DiagnosticMessage;
        Output_from_referenced_project_0_included_because_module_is_specified_as_none: DiagnosticMessage;
        File_is_output_from_referenced_project_specified_here: DiagnosticMessage;
        Source_from_referenced_project_0_included_because_1_specified: DiagnosticMessage;
        Source_from_referenced_project_0_included_because_module_is_specified_as_none: DiagnosticMessage;
        File_is_source_from_referenced_project_specified_here: DiagnosticMessage;
        Entry_point_of_type_library_0_specified_in_compilerOptions: DiagnosticMessage;
        Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1: DiagnosticMessage;
        File_is_entry_point_of_type_library_specified_here: DiagnosticMessage;
        Entry_point_for_implicit_type_library_0: DiagnosticMessage;
        Entry_point_for_implicit_type_library_0_with_packageId_1: DiagnosticMessage;
        Library_0_specified_in_compilerOptions: DiagnosticMessage;
        File_is_library_specified_here: DiagnosticMessage;
        Default_library: DiagnosticMessage;
        Default_library_for_target_0: DiagnosticMessage;
        File_is_default_library_for_target_specified_here: DiagnosticMessage;
        Root_file_specified_for_compilation: DiagnosticMessage;
        File_is_output_of_project_reference_source_0: DiagnosticMessage;
        File_redirects_to_file_0: DiagnosticMessage;
        The_file_is_in_the_program_because_Colon: DiagnosticMessage;
        for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: DiagnosticMessage;
        Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher: DiagnosticMessage;
        Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters: DiagnosticMessage;
        Unexpected_keyword_or_identifier: DiagnosticMessage;
        Unknown_keyword_or_identifier_Did_you_mean_0: DiagnosticMessage;
        Decorators_must_precede_the_name_and_all_keywords_of_property_declarations: DiagnosticMessage;
        Namespace_must_be_given_a_name: DiagnosticMessage;
        Interface_must_be_given_a_name: DiagnosticMessage;
        Type_alias_must_be_given_a_name: DiagnosticMessage;
        Variable_declaration_not_allowed_at_this_location: DiagnosticMessage;
        Cannot_start_a_function_call_in_a_type_annotation: DiagnosticMessage;
        Expected_for_property_initializer: DiagnosticMessage;
        Module_declaration_names_may_only_use_or_quoted_strings: DiagnosticMessage;
        _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled: DiagnosticMessage;
        _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled: DiagnosticMessage;
        _0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled: DiagnosticMessage;
        Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed: DiagnosticMessage;
        Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments: DiagnosticMessage;
        Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression: DiagnosticMessage;
        resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext: DiagnosticMessage;
        resolution_mode_should_be_either_require_or_import: DiagnosticMessage;
        resolution_mode_can_only_be_set_for_type_only_imports: DiagnosticMessage;
        resolution_mode_is_the_only_valid_key_for_type_import_assertions: DiagnosticMessage;
        Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require: DiagnosticMessage;
        Matched_by_default_include_pattern_Asterisk_Asterisk_Slash_Asterisk: DiagnosticMessage;
        File_is_ECMAScript_module_because_0_has_field_type_with_value_module: DiagnosticMessage;
        File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module: DiagnosticMessage;
        File_is_CommonJS_module_because_0_does_not_have_field_type: DiagnosticMessage;
        File_is_CommonJS_module_because_package_json_was_not_found: DiagnosticMessage;
        The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output: DiagnosticMessage;
        Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead: DiagnosticMessage;
        catch_or_finally_expected: DiagnosticMessage;
        An_import_declaration_can_only_be_used_at_the_top_level_of_a_module: DiagnosticMessage;
        An_export_declaration_can_only_be_used_at_the_top_level_of_a_module: DiagnosticMessage;
        Control_what_method_is_used_to_detect_module_format_JS_files: DiagnosticMessage;
        auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_with_module_Colon_node16_as_modules: DiagnosticMessage;
        An_instantiation_expression_cannot_be_followed_by_a_property_access: DiagnosticMessage;
        Identifier_or_string_literal_expected: DiagnosticMessage;
        The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead: DiagnosticMessage;
        To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_package_json_file_with_type_Colon_module: DiagnosticMessage;
        To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1: DiagnosticMessage;
        To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0: DiagnosticMessage;
        To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module: DiagnosticMessage;
        _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled: DiagnosticMessage;
        _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled: DiagnosticMessage;
        Decorator_used_before_export_here: DiagnosticMessage;
        The_types_of_0_are_incompatible_between_these_types: DiagnosticMessage;
        The_types_returned_by_0_are_incompatible_between_these_types: DiagnosticMessage;
        Call_signature_return_types_0_and_1_are_incompatible: DiagnosticMessage;
        Construct_signature_return_types_0_and_1_are_incompatible: DiagnosticMessage;
        Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: DiagnosticMessage;
        Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: DiagnosticMessage;
        The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement: DiagnosticMessage;
        The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement: DiagnosticMessage;
        This_type_parameter_might_need_an_extends_0_constraint: DiagnosticMessage;
        The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: DiagnosticMessage;
        The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: DiagnosticMessage;
        Add_extends_constraint: DiagnosticMessage;
        Add_extends_constraint_to_all_type_parameters: DiagnosticMessage;
        Duplicate_identifier_0: DiagnosticMessage;
        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: DiagnosticMessage;
        Static_members_cannot_reference_class_type_parameters: DiagnosticMessage;
        Circular_definition_of_import_alias_0: DiagnosticMessage;
        Cannot_find_name_0: DiagnosticMessage;
        Module_0_has_no_exported_member_1: DiagnosticMessage;
        File_0_is_not_a_module: DiagnosticMessage;
        Cannot_find_module_0_or_its_corresponding_type_declarations: DiagnosticMessage;
        Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity: DiagnosticMessage;
        An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: DiagnosticMessage;
        Type_0_recursively_references_itself_as_a_base_type: DiagnosticMessage;
        Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function: DiagnosticMessage;
        An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members: DiagnosticMessage;
        Type_parameter_0_has_a_circular_constraint: DiagnosticMessage;
        Generic_type_0_requires_1_type_argument_s: DiagnosticMessage;
        Type_0_is_not_generic: DiagnosticMessage;
        Global_type_0_must_be_a_class_or_interface_type: DiagnosticMessage;
        Global_type_0_must_have_1_type_parameter_s: DiagnosticMessage;
        Cannot_find_global_type_0: DiagnosticMessage;
        Named_property_0_of_types_1_and_2_are_not_identical: DiagnosticMessage;
        Interface_0_cannot_simultaneously_extend_types_1_and_2: DiagnosticMessage;
        Excessive_stack_depth_comparing_types_0_and_1: DiagnosticMessage;
        Type_0_is_not_assignable_to_type_1: DiagnosticMessage;
        Cannot_redeclare_exported_variable_0: DiagnosticMessage;
        Property_0_is_missing_in_type_1: DiagnosticMessage;
        Property_0_is_private_in_type_1_but_not_in_type_2: DiagnosticMessage;
        Types_of_property_0_are_incompatible: DiagnosticMessage;
        Property_0_is_optional_in_type_1_but_required_in_type_2: DiagnosticMessage;
        Types_of_parameters_0_and_1_are_incompatible: DiagnosticMessage;
        Index_signature_for_type_0_is_missing_in_type_1: DiagnosticMessage;
        _0_and_1_index_signatures_are_incompatible: DiagnosticMessage;
        this_cannot_be_referenced_in_a_module_or_namespace_body: DiagnosticMessage;
        this_cannot_be_referenced_in_current_location: DiagnosticMessage;
        this_cannot_be_referenced_in_constructor_arguments: DiagnosticMessage;
        this_cannot_be_referenced_in_a_static_property_initializer: DiagnosticMessage;
        super_can_only_be_referenced_in_a_derived_class: DiagnosticMessage;
        super_cannot_be_referenced_in_constructor_arguments: DiagnosticMessage;
        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: DiagnosticMessage;
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: DiagnosticMessage;
        Property_0_does_not_exist_on_type_1: DiagnosticMessage;
        Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: DiagnosticMessage;
        Property_0_is_private_and_only_accessible_within_class_1: DiagnosticMessage;
        This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0: DiagnosticMessage;
        Type_0_does_not_satisfy_the_constraint_1: DiagnosticMessage;
        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: DiagnosticMessage;
        Call_target_does_not_contain_any_signatures: DiagnosticMessage;
        Untyped_function_calls_may_not_accept_type_arguments: DiagnosticMessage;
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: DiagnosticMessage;
        This_expression_is_not_callable: DiagnosticMessage;
        Only_a_void_function_can_be_called_with_the_new_keyword: DiagnosticMessage;
        This_expression_is_not_constructable: DiagnosticMessage;
        Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first: DiagnosticMessage;
        Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1: DiagnosticMessage;
        This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found: DiagnosticMessage;
        A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value: DiagnosticMessage;
        An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type: DiagnosticMessage;
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access: DiagnosticMessage;
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: DiagnosticMessage;
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: DiagnosticMessage;
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: DiagnosticMessage;
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: DiagnosticMessage;
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access: DiagnosticMessage;
        Operator_0_cannot_be_applied_to_types_1_and_2: DiagnosticMessage;
        Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined: DiagnosticMessage;
        This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap: DiagnosticMessage;
        Type_parameter_name_cannot_be_0: DiagnosticMessage;
        A_parameter_property_is_only_allowed_in_a_constructor_implementation: DiagnosticMessage;
        A_rest_parameter_must_be_of_an_array_type: DiagnosticMessage;
        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: DiagnosticMessage;
        Parameter_0_cannot_reference_itself: DiagnosticMessage;
        Parameter_0_cannot_reference_identifier_1_declared_after_it: DiagnosticMessage;
        Duplicate_index_signature_for_type_0: DiagnosticMessage;
        Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: DiagnosticMessage;
        A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers: DiagnosticMessage;
        Constructors_for_derived_classes_must_contain_a_super_call: DiagnosticMessage;
        A_get_accessor_must_return_a_value: DiagnosticMessage;
        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: DiagnosticMessage;
        The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type: DiagnosticMessage;
        Overload_signatures_must_all_be_exported_or_non_exported: DiagnosticMessage;
        Overload_signatures_must_all_be_ambient_or_non_ambient: DiagnosticMessage;
        Overload_signatures_must_all_be_public_private_or_protected: DiagnosticMessage;
        Overload_signatures_must_all_be_optional_or_required: DiagnosticMessage;
        Function_overload_must_be_static: DiagnosticMessage;
        Function_overload_must_not_be_static: DiagnosticMessage;
        Function_implementation_name_must_be_0: DiagnosticMessage;
        Constructor_implementation_is_missing: DiagnosticMessage;
        Function_implementation_is_missing_or_not_immediately_following_the_declaration: DiagnosticMessage;
        Multiple_constructor_implementations_are_not_allowed: DiagnosticMessage;
        Duplicate_function_implementation: DiagnosticMessage;
        This_overload_signature_is_not_compatible_with_its_implementation_signature: DiagnosticMessage;
        Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: DiagnosticMessage;
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: DiagnosticMessage;
        Declaration_name_conflicts_with_built_in_global_identifier_0: DiagnosticMessage;
        constructor_cannot_be_used_as_a_parameter_property_name: DiagnosticMessage;
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: DiagnosticMessage;
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: DiagnosticMessage;
        A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers: DiagnosticMessage;
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: DiagnosticMessage;
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: DiagnosticMessage;
        The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: DiagnosticMessage;
        The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: DiagnosticMessage;
        The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access: DiagnosticMessage;
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0: DiagnosticMessage;
        Setters_cannot_return_a_value: DiagnosticMessage;
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: DiagnosticMessage;
        The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any: DiagnosticMessage;
        Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target: DiagnosticMessage;
        Property_0_of_type_1_is_not_assignable_to_2_index_type_3: DiagnosticMessage;
        _0_index_type_1_is_not_assignable_to_2_index_type_3: DiagnosticMessage;
        Class_name_cannot_be_0: DiagnosticMessage;
        Class_0_incorrectly_extends_base_class_1: DiagnosticMessage;
        Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2: DiagnosticMessage;
        Class_static_side_0_incorrectly_extends_base_class_static_side_1: DiagnosticMessage;
        Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1: DiagnosticMessage;
        Types_of_construct_signatures_are_incompatible: DiagnosticMessage;
        Class_0_incorrectly_implements_interface_1: DiagnosticMessage;
        A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members: DiagnosticMessage;
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: DiagnosticMessage;
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: DiagnosticMessage;
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: DiagnosticMessage;
        Interface_name_cannot_be_0: DiagnosticMessage;
        All_declarations_of_0_must_have_identical_type_parameters: DiagnosticMessage;
        Interface_0_incorrectly_extends_interface_1: DiagnosticMessage;
        Enum_name_cannot_be_0: DiagnosticMessage;
        In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: DiagnosticMessage;
        A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: DiagnosticMessage;
        A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: DiagnosticMessage;
        Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces: DiagnosticMessage;
        Ambient_module_declaration_cannot_specify_relative_module_name: DiagnosticMessage;
        Module_0_is_hidden_by_a_local_declaration_with_the_same_name: DiagnosticMessage;
        Import_name_cannot_be_0: DiagnosticMessage;
        Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name: DiagnosticMessage;
        Import_declaration_conflicts_with_local_declaration_of_0: DiagnosticMessage;
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module: DiagnosticMessage;
        Types_have_separate_declarations_of_a_private_property_0: DiagnosticMessage;
        Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: DiagnosticMessage;
        Property_0_is_protected_in_type_1_but_public_in_type_2: DiagnosticMessage;
        Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: DiagnosticMessage;
        Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2: DiagnosticMessage;
        The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead: DiagnosticMessage;
        Block_scoped_variable_0_used_before_its_declaration: DiagnosticMessage;
        Class_0_used_before_its_declaration: DiagnosticMessage;
        Enum_0_used_before_its_declaration: DiagnosticMessage;
        Cannot_redeclare_block_scoped_variable_0: DiagnosticMessage;
        An_enum_member_cannot_have_a_numeric_name: DiagnosticMessage;
        Variable_0_is_used_before_being_assigned: DiagnosticMessage;
        Type_alias_0_circularly_references_itself: DiagnosticMessage;
        Type_alias_name_cannot_be_0: DiagnosticMessage;
        An_AMD_module_cannot_have_multiple_name_assignments: DiagnosticMessage;
        Module_0_declares_1_locally_but_it_is_not_exported: DiagnosticMessage;
        Module_0_declares_1_locally_but_it_is_exported_as_2: DiagnosticMessage;
        Type_0_is_not_an_array_type: DiagnosticMessage;
        A_rest_element_must_be_last_in_a_destructuring_pattern: DiagnosticMessage;
        A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature: DiagnosticMessage;
        A_computed_property_name_must_be_of_type_string_number_symbol_or_any: DiagnosticMessage;
        this_cannot_be_referenced_in_a_computed_property_name: DiagnosticMessage;
        super_cannot_be_referenced_in_a_computed_property_name: DiagnosticMessage;
        A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type: DiagnosticMessage;
        Cannot_find_global_value_0: DiagnosticMessage;
        The_0_operator_cannot_be_applied_to_type_symbol: DiagnosticMessage;
        Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher: DiagnosticMessage;
        Enum_declarations_must_all_be_const_or_non_const: DiagnosticMessage;
        const_enum_member_initializers_must_be_constant_expressions: DiagnosticMessage;
        const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query: DiagnosticMessage;
        A_const_enum_member_can_only_be_accessed_using_a_string_literal: DiagnosticMessage;
        const_enum_member_initializer_was_evaluated_to_a_non_finite_value: DiagnosticMessage;
        const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN: DiagnosticMessage;
        let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations: DiagnosticMessage;
        Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1: DiagnosticMessage;
        The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation: DiagnosticMessage;
        Export_declaration_conflicts_with_exported_declaration_of_0: DiagnosticMessage;
        The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access: DiagnosticMessage;
        Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator: DiagnosticMessage;
        An_iterator_must_have_a_next_method: DiagnosticMessage;
        The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property: DiagnosticMessage;
        The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern: DiagnosticMessage;
        Cannot_redeclare_identifier_0_in_catch_clause: DiagnosticMessage;
        Tuple_type_0_of_length_1_has_no_element_at_index_2: DiagnosticMessage;
        Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher: DiagnosticMessage;
        Type_0_is_not_an_array_type_or_a_string_type: DiagnosticMessage;
        The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression: DiagnosticMessage;
        This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export: DiagnosticMessage;
        Module_0_uses_export_and_cannot_be_used_with_export_Asterisk: DiagnosticMessage;
        An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments: DiagnosticMessage;
        A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments: DiagnosticMessage;
        A_rest_element_cannot_contain_a_binding_pattern: DiagnosticMessage;
        _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation: DiagnosticMessage;
        Cannot_find_namespace_0: DiagnosticMessage;
        Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator: DiagnosticMessage;
        A_generator_cannot_have_a_void_type_annotation: DiagnosticMessage;
        _0_is_referenced_directly_or_indirectly_in_its_own_base_expression: DiagnosticMessage;
        Type_0_is_not_a_constructor_function_type: DiagnosticMessage;
        No_base_constructor_has_the_specified_number_of_type_arguments: DiagnosticMessage;
        Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members: DiagnosticMessage;
        Base_constructors_must_all_have_the_same_return_type: DiagnosticMessage;
        Cannot_create_an_instance_of_an_abstract_class: DiagnosticMessage;
        Overload_signatures_must_all_be_abstract_or_non_abstract: DiagnosticMessage;
        Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression: DiagnosticMessage;
        A_tuple_type_cannot_be_indexed_with_a_negative_value: DiagnosticMessage;
        Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2: DiagnosticMessage;
        All_declarations_of_an_abstract_method_must_be_consecutive: DiagnosticMessage;
        Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type: DiagnosticMessage;
        A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard: DiagnosticMessage;
        An_async_iterator_must_have_a_next_method: DiagnosticMessage;
        Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions: DiagnosticMessage;
        The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method: DiagnosticMessage;
        yield_expressions_cannot_be_used_in_a_parameter_initializer: DiagnosticMessage;
        await_expressions_cannot_be_used_in_a_parameter_initializer: DiagnosticMessage;
        Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value: DiagnosticMessage;
        A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface: DiagnosticMessage;
        The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary: DiagnosticMessage;
        A_module_cannot_have_multiple_default_exports: DiagnosticMessage;
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions: DiagnosticMessage;
        Property_0_is_incompatible_with_index_signature: DiagnosticMessage;
        Object_is_possibly_null: DiagnosticMessage;
        Object_is_possibly_undefined: DiagnosticMessage;
        Object_is_possibly_null_or_undefined: DiagnosticMessage;
        A_function_returning_never_cannot_have_a_reachable_end_point: DiagnosticMessage;
        Type_0_cannot_be_used_to_index_type_1: DiagnosticMessage;
        Type_0_has_no_matching_index_signature_for_type_1: DiagnosticMessage;
        Type_0_cannot_be_used_as_an_index_type: DiagnosticMessage;
        Cannot_assign_to_0_because_it_is_not_a_variable: DiagnosticMessage;
        Cannot_assign_to_0_because_it_is_a_read_only_property: DiagnosticMessage;
        Index_signature_in_type_0_only_permits_reading: DiagnosticMessage;
        Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference: DiagnosticMessage;
        Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference: DiagnosticMessage;
        A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any: DiagnosticMessage;
        The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property: DiagnosticMessage;
        Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: DiagnosticMessage;
        Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: DiagnosticMessage;
        Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later: DiagnosticMessage;
        Property_0_does_not_exist_on_type_1_Did_you_mean_2: DiagnosticMessage;
        Cannot_find_name_0_Did_you_mean_1: DiagnosticMessage;
        Computed_values_are_not_permitted_in_an_enum_with_string_valued_members: DiagnosticMessage;
        Expected_0_arguments_but_got_1: DiagnosticMessage;
        Expected_at_least_0_arguments_but_got_1: DiagnosticMessage;
        A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter: DiagnosticMessage;
        Expected_0_type_arguments_but_got_1: DiagnosticMessage;
        Type_0_has_no_properties_in_common_with_type_1: DiagnosticMessage;
        Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it: DiagnosticMessage;
        Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2: DiagnosticMessage;
        Base_class_expressions_cannot_reference_class_type_parameters: DiagnosticMessage;
        The_containing_function_or_module_body_is_too_large_for_control_flow_analysis: DiagnosticMessage;
        Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor: DiagnosticMessage;
        Property_0_is_used_before_being_assigned: DiagnosticMessage;
        A_rest_element_cannot_have_a_property_name: DiagnosticMessage;
        Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations: DiagnosticMessage;
        Property_0_may_not_exist_on_type_1_Did_you_mean_2: DiagnosticMessage;
        Could_not_find_name_0_Did_you_mean_1: DiagnosticMessage;
        Object_is_of_type_unknown: DiagnosticMessage;
        A_rest_element_type_must_be_an_array_type: DiagnosticMessage;
        No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments: DiagnosticMessage;
        Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead: DiagnosticMessage;
        Return_type_annotation_circularly_references_itself: DiagnosticMessage;
        Unused_ts_expect_error_directive: DiagnosticMessage;
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode: DiagnosticMessage;
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery: DiagnosticMessage;
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha: DiagnosticMessage;
        Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later: DiagnosticMessage;
        Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom: DiagnosticMessage;
        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later: DiagnosticMessage;
        Cannot_assign_to_0_because_it_is_a_constant: DiagnosticMessage;
        Type_instantiation_is_excessively_deep_and_possibly_infinite: DiagnosticMessage;
        Expression_produces_a_union_type_that_is_too_complex_to_represent: DiagnosticMessage;
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig: DiagnosticMessage;
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig: DiagnosticMessage;
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig: DiagnosticMessage;
        This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag: DiagnosticMessage;
        _0_can_only_be_imported_by_using_a_default_import: DiagnosticMessage;
        _0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: DiagnosticMessage;
        _0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import: DiagnosticMessage;
        _0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: DiagnosticMessage;
        JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist: DiagnosticMessage;
        Property_0_in_type_1_is_not_assignable_to_type_2: DiagnosticMessage;
        JSX_element_type_0_does_not_have_any_construct_or_call_signatures: DiagnosticMessage;
        Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property: DiagnosticMessage;
        JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property: DiagnosticMessage;
        The_global_type_JSX_0_may_not_have_more_than_one_property: DiagnosticMessage;
        JSX_spread_child_must_be_an_array_type: DiagnosticMessage;
        _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property: DiagnosticMessage;
        _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor: DiagnosticMessage;
        Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration: DiagnosticMessage;
        Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead: DiagnosticMessage;
        Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead: DiagnosticMessage;
        Type_of_property_0_circularly_references_itself_in_mapped_type_1: DiagnosticMessage;
        _0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import: DiagnosticMessage;
        _0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: DiagnosticMessage;
        Source_has_0_element_s_but_target_requires_1: DiagnosticMessage;
        Source_has_0_element_s_but_target_allows_only_1: DiagnosticMessage;
        Target_requires_0_element_s_but_source_may_have_fewer: DiagnosticMessage;
        Target_allows_only_0_element_s_but_source_may_have_more: DiagnosticMessage;
        Source_provides_no_match_for_required_element_at_position_0_in_target: DiagnosticMessage;
        Source_provides_no_match_for_variadic_element_at_position_0_in_target: DiagnosticMessage;
        Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target: DiagnosticMessage;
        Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target: DiagnosticMessage;
        Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target: DiagnosticMessage;
        Cannot_assign_to_0_because_it_is_an_enum: DiagnosticMessage;
        Cannot_assign_to_0_because_it_is_a_class: DiagnosticMessage;
        Cannot_assign_to_0_because_it_is_a_function: DiagnosticMessage;
        Cannot_assign_to_0_because_it_is_a_namespace: DiagnosticMessage;
        Cannot_assign_to_0_because_it_is_an_import: DiagnosticMessage;
        JSX_property_access_expressions_cannot_include_JSX_namespace_names: DiagnosticMessage;
        _0_index_signatures_are_incompatible: DiagnosticMessage;
        Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable: DiagnosticMessage;
        Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation: DiagnosticMessage;
        Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types: DiagnosticMessage;
        Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator: DiagnosticMessage;
        Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity: DiagnosticMessage;
        A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums: DiagnosticMessage;
        Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead: DiagnosticMessage;
        Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1: DiagnosticMessage;
        JSX_expressions_must_have_one_parent_element: DiagnosticMessage;
        Type_0_provides_no_match_for_the_signature_1: DiagnosticMessage;
        super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher: DiagnosticMessage;
        super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions: DiagnosticMessage;
        Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module: DiagnosticMessage;
        Cannot_find_name_0_Did_you_mean_the_static_member_1_0: DiagnosticMessage;
        Cannot_find_name_0_Did_you_mean_the_instance_member_this_0: DiagnosticMessage;
        Invalid_module_name_in_augmentation_module_0_cannot_be_found: DiagnosticMessage;
        Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented: DiagnosticMessage;
        Exports_and_export_assignments_are_not_permitted_in_module_augmentations: DiagnosticMessage;
        Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module: DiagnosticMessage;
        export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible: DiagnosticMessage;
        Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations: DiagnosticMessage;
        Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context: DiagnosticMessage;
        Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity: DiagnosticMessage;
        Cannot_assign_a_0_constructor_type_to_a_1_constructor_type: DiagnosticMessage;
        Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration: DiagnosticMessage;
        Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration: DiagnosticMessage;
        Cannot_extend_a_class_0_Class_constructor_is_marked_as_private: DiagnosticMessage;
        Accessors_must_both_be_abstract_or_non_abstract: DiagnosticMessage;
        A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type: DiagnosticMessage;
        Type_0_is_not_comparable_to_type_1: DiagnosticMessage;
        A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void: DiagnosticMessage;
        A_0_parameter_must_be_the_first_parameter: DiagnosticMessage;
        A_constructor_cannot_have_a_this_parameter: DiagnosticMessage;
        this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation: DiagnosticMessage;
        The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1: DiagnosticMessage;
        The_this_types_of_each_signature_are_incompatible: DiagnosticMessage;
        _0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead: DiagnosticMessage;
        All_declarations_of_0_must_have_identical_modifiers: DiagnosticMessage;
        Cannot_find_type_definition_file_for_0: DiagnosticMessage;
        Cannot_extend_an_interface_0_Did_you_mean_implements: DiagnosticMessage;
        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0: DiagnosticMessage;
        _0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible: DiagnosticMessage;
        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here: DiagnosticMessage;
        Namespace_0_has_no_exported_member_1: DiagnosticMessage;
        Left_side_of_comma_operator_is_unused_and_has_no_side_effects: DiagnosticMessage;
        The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead: DiagnosticMessage;
        An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: DiagnosticMessage;
        Spread_types_may_only_be_created_from_object_types: DiagnosticMessage;
        Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1: DiagnosticMessage;
        Rest_types_may_only_be_created_from_object_types: DiagnosticMessage;
        The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access: DiagnosticMessage;
        _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here: DiagnosticMessage;
        The_operand_of_a_delete_operator_must_be_a_property_reference: DiagnosticMessage;
        The_operand_of_a_delete_operator_cannot_be_a_read_only_property: DiagnosticMessage;
        An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: DiagnosticMessage;
        Required_type_parameters_may_not_follow_optional_type_parameters: DiagnosticMessage;
        Generic_type_0_requires_between_1_and_2_type_arguments: DiagnosticMessage;
        Cannot_use_namespace_0_as_a_value: DiagnosticMessage;
        Cannot_use_namespace_0_as_a_type: DiagnosticMessage;
        _0_are_specified_twice_The_attribute_named_0_will_be_overwritten: DiagnosticMessage;
        A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: DiagnosticMessage;
        A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: DiagnosticMessage;
        Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1: DiagnosticMessage;
        The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context: DiagnosticMessage;
        Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor: DiagnosticMessage;
        Type_parameter_0_has_a_circular_default: DiagnosticMessage;
        Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2: DiagnosticMessage;
        Duplicate_property_0: DiagnosticMessage;
        Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated: DiagnosticMessage;
        Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass: DiagnosticMessage;
        Cannot_invoke_an_object_which_is_possibly_null: DiagnosticMessage;
        Cannot_invoke_an_object_which_is_possibly_undefined: DiagnosticMessage;
        Cannot_invoke_an_object_which_is_possibly_null_or_undefined: DiagnosticMessage;
        _0_has_no_exported_member_named_1_Did_you_mean_2: DiagnosticMessage;
        Class_name_cannot_be_Object_when_targeting_ES5_with_module_0: DiagnosticMessage;
        Cannot_find_lib_definition_for_0: DiagnosticMessage;
        Cannot_find_lib_definition_for_0_Did_you_mean_1: DiagnosticMessage;
        _0_is_declared_here: DiagnosticMessage;
        Property_0_is_used_before_its_initialization: DiagnosticMessage;
        An_arrow_function_cannot_have_a_this_parameter: DiagnosticMessage;
        Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String: DiagnosticMessage;
        Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension: DiagnosticMessage;
        Property_0_was_also_declared_here: DiagnosticMessage;
        Are_you_missing_a_semicolon: DiagnosticMessage;
        Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1: DiagnosticMessage;
        Operator_0_cannot_be_applied_to_type_1: DiagnosticMessage;
        BigInt_literals_are_not_available_when_targeting_lower_than_ES2020: DiagnosticMessage;
        An_outer_value_of_this_is_shadowed_by_this_container: DiagnosticMessage;
        Type_0_is_missing_the_following_properties_from_type_1_Colon_2: DiagnosticMessage;
        Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more: DiagnosticMessage;
        Property_0_is_missing_in_type_1_but_required_in_type_2: DiagnosticMessage;
        The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_annotation_is_necessary: DiagnosticMessage;
        No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments: DiagnosticMessage;
        Type_parameter_defaults_can_only_reference_previously_declared_type_parameters: DiagnosticMessage;
        This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided: DiagnosticMessage;
        This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided: DiagnosticMessage;
        _0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2: DiagnosticMessage;
        Cannot_access_ambient_const_enums_when_0_is_enabled: DiagnosticMessage;
        _0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0: DiagnosticMessage;
        The_implementation_signature_is_declared_here: DiagnosticMessage;
        Circularity_originates_in_type_at_this_location: DiagnosticMessage;
        The_first_export_default_is_here: DiagnosticMessage;
        Another_export_default_is_here: DiagnosticMessage;
        super_may_not_use_type_arguments: DiagnosticMessage;
        No_constituent_of_type_0_is_callable: DiagnosticMessage;
        Not_all_constituents_of_type_0_are_callable: DiagnosticMessage;
        Type_0_has_no_call_signatures: DiagnosticMessage;
        Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other: DiagnosticMessage;
        No_constituent_of_type_0_is_constructable: DiagnosticMessage;
        Not_all_constituents_of_type_0_are_constructable: DiagnosticMessage;
        Type_0_has_no_construct_signatures: DiagnosticMessage;
        Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other: DiagnosticMessage;
        Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0: DiagnosticMessage;
        Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0: DiagnosticMessage;
        Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0: DiagnosticMessage;
        Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0: DiagnosticMessage;
        The_0_property_of_an_iterator_must_be_a_method: DiagnosticMessage;
        The_0_property_of_an_async_iterator_must_be_a_method: DiagnosticMessage;
        No_overload_matches_this_call: DiagnosticMessage;
        The_last_overload_gave_the_following_error: DiagnosticMessage;
        The_last_overload_is_declared_here: DiagnosticMessage;
        Overload_0_of_1_2_gave_the_following_error: DiagnosticMessage;
        Did_you_forget_to_use_await: DiagnosticMessage;
        This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead: DiagnosticMessage;
        Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation: DiagnosticMessage;
        Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name: DiagnosticMessage;
        The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access: DiagnosticMessage;
        The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access: DiagnosticMessage;
        The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access: DiagnosticMessage;
        The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access: DiagnosticMessage;
        The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access: DiagnosticMessage;
        _0_needs_an_explicit_type_annotation: DiagnosticMessage;
        _0_is_specified_more_than_once_so_this_usage_will_be_overwritten: DiagnosticMessage;
        get_and_set_accessors_cannot_declare_this_parameters: DiagnosticMessage;
        This_spread_always_overwrites_this_property: DiagnosticMessage;
        _0_cannot_be_used_as_a_JSX_component: DiagnosticMessage;
        Its_return_type_0_is_not_a_valid_JSX_element: DiagnosticMessage;
        Its_instance_type_0_is_not_a_valid_JSX_element: DiagnosticMessage;
        Its_element_type_0_is_not_a_valid_JSX_element: DiagnosticMessage;
        The_operand_of_a_delete_operator_must_be_optional: DiagnosticMessage;
        Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later: DiagnosticMessage;
        Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option: DiagnosticMessage;
        The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible: DiagnosticMessage;
        Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise: DiagnosticMessage;
        The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types: DiagnosticMessage;
        It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked: DiagnosticMessage;
        A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract: DiagnosticMessage;
        The_declaration_was_marked_as_deprecated_here: DiagnosticMessage;
        Type_produces_a_tuple_type_that_is_too_large_to_represent: DiagnosticMessage;
        Expression_produces_a_tuple_type_that_is_too_large_to_represent: DiagnosticMessage;
        This_condition_will_always_return_true_since_this_0_is_always_defined: DiagnosticMessage;
        Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher: DiagnosticMessage;
        Cannot_assign_to_private_method_0_Private_methods_are_not_writable: DiagnosticMessage;
        Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name: DiagnosticMessage;
        Private_accessor_was_defined_without_a_getter: DiagnosticMessage;
        This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0: DiagnosticMessage;
        A_get_accessor_must_be_at_least_as_accessible_as_the_setter: DiagnosticMessage;
        Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_whole_assignment_in_parentheses: DiagnosticMessage;
        Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments: DiagnosticMessage;
        Initializer_for_property_0: DiagnosticMessage;
        Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom: DiagnosticMessage;
        Class_declaration_cannot_implement_overload_list_for_0: DiagnosticMessage;
        Function_with_bodies_can_only_merge_with_classes_that_are_ambient: DiagnosticMessage;
        arguments_cannot_be_referenced_in_property_initializers: DiagnosticMessage;
        Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class: DiagnosticMessage;
        Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block: DiagnosticMessage;
        Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers: DiagnosticMessage;
        Namespace_name_cannot_be_0: DiagnosticMessage;
        Type_0_is_not_assignable_to_type_1_Did_you_mean_2: DiagnosticMessage;
        Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext: DiagnosticMessage;
        Import_assertions_cannot_be_used_with_type_only_imports_or_exports: DiagnosticMessage;
        Cannot_find_namespace_0_Did_you_mean_1: DiagnosticMessage;
        Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path: DiagnosticMessage;
        Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0: DiagnosticMessage;
        Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls: DiagnosticMessage;
        Import_assertion_values_must_be_string_literal_expressions: DiagnosticMessage;
        All_declarations_of_0_must_have_identical_constraints: DiagnosticMessage;
        This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value: DiagnosticMessage;
        An_interface_cannot_extend_a_primitive_type_like_0_an_interface_can_only_extend_named_types_and_classes: DiagnosticMessage;
        The_type_of_this_expression_cannot_be_named_without_a_resolution_mode_assertion_which_is_an_unstable_feature_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: DiagnosticMessage;
        _0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation: DiagnosticMessage;
        We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here: DiagnosticMessage;
        Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: DiagnosticMessage;
        This_condition_will_always_return_0: DiagnosticMessage;
        A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead: DiagnosticMessage;
        Import_declaration_0_is_using_private_name_1: DiagnosticMessage;
        Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
        Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: DiagnosticMessage;
        Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: DiagnosticMessage;
        extends_clause_of_exported_class_0_has_or_is_using_private_name_1: DiagnosticMessage;
        extends_clause_of_exported_class_has_or_is_using_private_name_0: DiagnosticMessage;
        extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: DiagnosticMessage;
        Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Exported_variable_0_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Exported_variable_0_has_or_is_using_private_name_1: DiagnosticMessage;
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Public_property_0_of_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Property_0_of_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
        Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: DiagnosticMessage;
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: DiagnosticMessage;
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: DiagnosticMessage;
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: DiagnosticMessage;
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: DiagnosticMessage;
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: DiagnosticMessage;
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: DiagnosticMessage;
        Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
        Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: DiagnosticMessage;
        Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: DiagnosticMessage;
        Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: DiagnosticMessage;
        Return_type_of_exported_function_has_or_is_using_private_name_0: DiagnosticMessage;
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_0_of_exported_function_has_or_is_using_private_name_1: DiagnosticMessage;
        Exported_type_alias_0_has_or_is_using_private_name_1: DiagnosticMessage;
        Default_export_of_the_module_has_or_is_using_private_name_0: DiagnosticMessage;
        Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1: DiagnosticMessage;
        Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2: DiagnosticMessage;
        Extends_clause_for_inferred_type_0_has_or_is_using_private_name_1: DiagnosticMessage;
        Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict: DiagnosticMessage;
        Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
        Property_0_of_exported_class_expression_may_not_be_private_or_protected: DiagnosticMessage;
        Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Public_static_method_0_of_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Public_method_0_of_exported_class_has_or_is_using_private_name_1: DiagnosticMessage;
        Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Method_0_of_exported_interface_has_or_is_using_private_name_1: DiagnosticMessage;
        Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1: DiagnosticMessage;
        The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1: DiagnosticMessage;
        Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter: DiagnosticMessage;
        Parameter_0_of_accessor_has_or_is_using_private_name_1: DiagnosticMessage;
        Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2: DiagnosticMessage;
        Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: DiagnosticMessage;
        Type_arguments_for_0_circularly_reference_themselves: DiagnosticMessage;
        Tuple_type_arguments_circularly_reference_themselves: DiagnosticMessage;
        Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0: DiagnosticMessage;
        This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class: DiagnosticMessage;
        This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0: DiagnosticMessage;
        This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0: DiagnosticMessage;
        This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0: DiagnosticMessage;
        This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0: DiagnosticMessage;
        This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: DiagnosticMessage;
        The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized: DiagnosticMessage;
        This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: DiagnosticMessage;
        This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: DiagnosticMessage;
        This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class: DiagnosticMessage;
        This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0: DiagnosticMessage;
        This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: DiagnosticMessage;
        Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: DiagnosticMessage;
        resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: DiagnosticMessage;
        The_current_host_does_not_support_the_0_option: DiagnosticMessage;
        Cannot_find_the_common_subdirectory_path_for_the_input_files: DiagnosticMessage;
        File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: DiagnosticMessage;
        Cannot_read_file_0_Colon_1: DiagnosticMessage;
        Failed_to_parse_file_0_Colon_1: DiagnosticMessage;
        Unknown_compiler_option_0: DiagnosticMessage;
        Compiler_option_0_requires_a_value_of_type_1: DiagnosticMessage;
        Unknown_compiler_option_0_Did_you_mean_1: DiagnosticMessage;
        Could_not_write_file_0_Colon_1: DiagnosticMessage;
        Option_project_cannot_be_mixed_with_source_files_on_a_command_line: DiagnosticMessage;
        Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher: DiagnosticMessage;
        Option_0_cannot_be_specified_when_option_target_is_ES3: DiagnosticMessage;
        Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided: DiagnosticMessage;
        Option_0_cannot_be_specified_without_specifying_option_1: DiagnosticMessage;
        Option_0_cannot_be_specified_with_option_1: DiagnosticMessage;
        A_tsconfig_json_file_is_already_defined_at_Colon_0: DiagnosticMessage;
        Cannot_write_file_0_because_it_would_overwrite_input_file: DiagnosticMessage;
        Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files: DiagnosticMessage;
        Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0: DiagnosticMessage;
        The_specified_path_does_not_exist_Colon_0: DiagnosticMessage;
        Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier: DiagnosticMessage;
        Pattern_0_can_have_at_most_one_Asterisk_character: DiagnosticMessage;
        Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character: DiagnosticMessage;
        Substitutions_for_pattern_0_should_be_an_array: DiagnosticMessage;
        Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2: DiagnosticMessage;
        File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: DiagnosticMessage;
        Substitutions_for_pattern_0_shouldn_t_be_an_empty_array: DiagnosticMessage;
        Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name: DiagnosticMessage;
        Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig: DiagnosticMessage;
        Option_0_cannot_be_specified_without_specifying_option_1_or_option_2: DiagnosticMessage;
        Option_resolveJsonModule_cannot_be_specified_when_moduleResolution_is_set_to_classic: DiagnosticMessage;
        Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_esNext: DiagnosticMessage;
        Unknown_build_option_0: DiagnosticMessage;
        Build_option_0_requires_a_value_of_type_1: DiagnosticMessage;
        Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified: DiagnosticMessage;
        _0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2: DiagnosticMessage;
        _0_and_1_operations_cannot_be_mixed_without_parentheses: DiagnosticMessage;
        Unknown_build_option_0_Did_you_mean_1: DiagnosticMessage;
        Unknown_watch_option_0: DiagnosticMessage;
        Unknown_watch_option_0_Did_you_mean_1: DiagnosticMessage;
        Watch_option_0_requires_a_value_of_type_1: DiagnosticMessage;
        Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0: DiagnosticMessage;
        _0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1: DiagnosticMessage;
        Cannot_read_file_0: DiagnosticMessage;
        Tuple_members_must_all_have_names_or_all_not_have_names: DiagnosticMessage;
        A_tuple_member_cannot_be_both_optional_and_rest: DiagnosticMessage;
        A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type: DiagnosticMessage;
        A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type: DiagnosticMessage;
        The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialized_A_type_annotation_is_necessary: DiagnosticMessage;
        Option_0_cannot_be_specified_when_option_jsx_is_1: DiagnosticMessage;
        Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash: DiagnosticMessage;
        Option_preserveConstEnums_cannot_be_disabled_when_0_is_enabled: DiagnosticMessage;
        The_root_value_of_a_0_file_must_be_an_object: DiagnosticMessage;
        Compiler_option_0_may_only_be_used_with_build: DiagnosticMessage;
        Compiler_option_0_may_not_be_used_with_build: DiagnosticMessage;
        Option_0_can_only_be_used_when_module_is_set_to_es2015_or_later: DiagnosticMessage;
        Option_allowImportingTsExtensions_can_only_be_used_when_either_noEmit_or_emitDeclarationOnly_is_set: DiagnosticMessage;
        An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled: DiagnosticMessage;
        Option_0_can_only_be_used_when_moduleResolution_is_set_to_node16_nodenext_or_bundler: DiagnosticMessage;
        Option_0_is_deprecated_and_will_stop_functioning_in_TypeScript_1_Specify_compilerOption_ignoreDeprecations_Colon_2_to_silence_this_error: DiagnosticMessage;
        Option_0_has_been_removed_Please_remove_it_from_your_configuration: DiagnosticMessage;
        Invalid_value_for_ignoreDeprecations: DiagnosticMessage;
        Option_0_is_redundant_and_cannot_be_specified_with_option_1: DiagnosticMessage;
        Option_verbatimModuleSyntax_cannot_be_used_when_module_is_set_to_UMD_AMD_or_System: DiagnosticMessage;
        Use_0_instead: DiagnosticMessage;
        Option_0_1_is_deprecated_and_will_stop_functioning_in_TypeScript_2_Specify_compilerOption_ignoreDeprecations_Colon_3_to_silence_this_error: DiagnosticMessage;
        Option_0_1_has_been_removed_Please_remove_it_from_your_configuration: DiagnosticMessage;
        Generates_a_sourcemap_for_each_corresponding_d_ts_file: DiagnosticMessage;
        Concatenate_and_emit_output_to_single_file: DiagnosticMessage;
        Generates_corresponding_d_ts_file: DiagnosticMessage;
        Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: DiagnosticMessage;
        Watch_input_files: DiagnosticMessage;
        Redirect_output_structure_to_the_directory: DiagnosticMessage;
        Do_not_erase_const_enum_declarations_in_generated_code: DiagnosticMessage;
        Do_not_emit_outputs_if_any_errors_were_reported: DiagnosticMessage;
        Do_not_emit_comments_to_output: DiagnosticMessage;
        Do_not_emit_outputs: DiagnosticMessage;
        Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking: DiagnosticMessage;
        Skip_type_checking_of_declaration_files: DiagnosticMessage;
        Do_not_resolve_the_real_path_of_symlinks: DiagnosticMessage;
        Only_emit_d_ts_declaration_files: DiagnosticMessage;
        Specify_ECMAScript_target_version: DiagnosticMessage;
        Specify_module_code_generation: DiagnosticMessage;
        Print_this_message: DiagnosticMessage;
        Print_the_compiler_s_version: DiagnosticMessage;
        Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json: DiagnosticMessage;
        Syntax_Colon_0: DiagnosticMessage;
        options: DiagnosticMessage;
        file: DiagnosticMessage;
        Examples_Colon_0: DiagnosticMessage;
        Options_Colon: DiagnosticMessage;
        Version_0: DiagnosticMessage;
        Insert_command_line_options_and_files_from_a_file: DiagnosticMessage;
        Starting_compilation_in_watch_mode: DiagnosticMessage;
        File_change_detected_Starting_incremental_compilation: DiagnosticMessage;
        KIND: DiagnosticMessage;
        FILE: DiagnosticMessage;
        VERSION: DiagnosticMessage;
        LOCATION: DiagnosticMessage;
        DIRECTORY: DiagnosticMessage;
        STRATEGY: DiagnosticMessage;
        FILE_OR_DIRECTORY: DiagnosticMessage;
        Errors_Files: DiagnosticMessage;
        Generates_corresponding_map_file: DiagnosticMessage;
        Compiler_option_0_expects_an_argument: DiagnosticMessage;
        Unterminated_quoted_string_in_response_file_0: DiagnosticMessage;
        Argument_for_0_option_must_be_Colon_1: DiagnosticMessage;
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: DiagnosticMessage;
        Unable_to_open_file_0: DiagnosticMessage;
        Corrupted_locale_file_0: DiagnosticMessage;
        Raise_error_on_expressions_and_declarations_with_an_implied_any_type: DiagnosticMessage;
        File_0_not_found: DiagnosticMessage;
        File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1: DiagnosticMessage;
        Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures: DiagnosticMessage;
        Do_not_emit_declarations_for_code_that_has_an_internal_annotation: DiagnosticMessage;
        Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir: DiagnosticMessage;
        File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files: DiagnosticMessage;
        Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix: DiagnosticMessage;
        NEWLINE: DiagnosticMessage;
        Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line: DiagnosticMessage;
        Enables_experimental_support_for_ES7_decorators: DiagnosticMessage;
        Enables_experimental_support_for_emitting_type_metadata_for_decorators: DiagnosticMessage;
        Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file: DiagnosticMessage;
        Successfully_created_a_tsconfig_json_file: DiagnosticMessage;
        Suppress_excess_property_checks_for_object_literals: DiagnosticMessage;
        Stylize_errors_and_messages_using_color_and_context_experimental: DiagnosticMessage;
        Do_not_report_errors_on_unused_labels: DiagnosticMessage;
        Report_error_when_not_all_code_paths_in_function_return_a_value: DiagnosticMessage;
        Report_errors_for_fallthrough_cases_in_switch_statement: DiagnosticMessage;
        Do_not_report_errors_on_unreachable_code: DiagnosticMessage;
        Disallow_inconsistently_cased_references_to_the_same_file: DiagnosticMessage;
        Specify_library_files_to_be_included_in_the_compilation: DiagnosticMessage;
        Specify_JSX_code_generation: DiagnosticMessage;
        File_0_has_an_unsupported_extension_so_skipping_it: DiagnosticMessage;
        Only_amd_and_system_modules_are_supported_alongside_0: DiagnosticMessage;
        Base_directory_to_resolve_non_absolute_module_names: DiagnosticMessage;
        Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit: DiagnosticMessage;
        Enable_tracing_of_the_name_resolution_process: DiagnosticMessage;
        Resolving_module_0_from_1: DiagnosticMessage;
        Explicitly_specified_module_resolution_kind_Colon_0: DiagnosticMessage;
        Module_resolution_kind_is_not_specified_using_0: DiagnosticMessage;
        Module_name_0_was_successfully_resolved_to_1: DiagnosticMessage;
        Module_name_0_was_not_resolved: DiagnosticMessage;
        paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0: DiagnosticMessage;
        Module_name_0_matched_pattern_1: DiagnosticMessage;
        Trying_substitution_0_candidate_module_location_Colon_1: DiagnosticMessage;
        Resolving_module_name_0_relative_to_base_url_1_2: DiagnosticMessage;
        Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_types_Colon_1: DiagnosticMessage;
        File_0_does_not_exist: DiagnosticMessage;
        File_0_exists_use_it_as_a_name_resolution_result: DiagnosticMessage;
        Loading_module_0_from_node_modules_folder_target_file_types_Colon_1: DiagnosticMessage;
        Found_package_json_at_0: DiagnosticMessage;
        package_json_does_not_have_a_0_field: DiagnosticMessage;
        package_json_has_0_field_1_that_references_2: DiagnosticMessage;
        Allow_javascript_files_to_be_compiled: DiagnosticMessage;
        Checking_if_0_is_the_longest_matching_prefix_for_1_2: DiagnosticMessage;
        Expected_type_of_0_field_in_package_json_to_be_1_got_2: DiagnosticMessage;
        baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1: DiagnosticMessage;
        rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0: DiagnosticMessage;
        Longest_matching_prefix_for_0_is_1: DiagnosticMessage;
        Loading_0_from_the_root_dir_1_candidate_location_2: DiagnosticMessage;
        Trying_other_entries_in_rootDirs: DiagnosticMessage;
        Module_resolution_using_rootDirs_has_failed: DiagnosticMessage;
        Do_not_emit_use_strict_directives_in_module_output: DiagnosticMessage;
        Enable_strict_null_checks: DiagnosticMessage;
        Unknown_option_excludes_Did_you_mean_exclude: DiagnosticMessage;
        Raise_error_on_this_expressions_with_an_implied_any_type: DiagnosticMessage;
        Resolving_type_reference_directive_0_containing_file_1_root_directory_2: DiagnosticMessage;
        Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2: DiagnosticMessage;
        Type_reference_directive_0_was_not_resolved: DiagnosticMessage;
        Resolving_with_primary_search_path_0: DiagnosticMessage;
        Root_directory_cannot_be_determined_skipping_primary_search_paths: DiagnosticMessage;
        Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set: DiagnosticMessage;
        Type_declaration_files_to_be_included_in_compilation: DiagnosticMessage;
        Looking_up_in_node_modules_folder_initial_location_0: DiagnosticMessage;
        Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder: DiagnosticMessage;
        Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1: DiagnosticMessage;
        Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set: DiagnosticMessage;
        Resolving_real_path_for_0_result_1: DiagnosticMessage;
        Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system: DiagnosticMessage;
        File_name_0_has_a_1_extension_stripping_it: DiagnosticMessage;
        _0_is_declared_but_its_value_is_never_read: DiagnosticMessage;
        Report_errors_on_unused_locals: DiagnosticMessage;
        Report_errors_on_unused_parameters: DiagnosticMessage;
        The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files: DiagnosticMessage;
        Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1: DiagnosticMessage;
        Property_0_is_declared_but_its_value_is_never_read: DiagnosticMessage;
        Import_emit_helpers_from_tslib: DiagnosticMessage;
        Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2: DiagnosticMessage;
        Parse_in_strict_mode_and_emit_use_strict_for_each_source_file: DiagnosticMessage;
        Module_0_was_resolved_to_1_but_jsx_is_not_set: DiagnosticMessage;
        Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1: DiagnosticMessage;
        Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified: DiagnosticMessage;
        Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h: DiagnosticMessage;
        Resolution_for_module_0_was_found_in_cache_from_location_1: DiagnosticMessage;
        Directory_0_does_not_exist_skipping_all_lookups_in_it: DiagnosticMessage;
        Show_diagnostic_information: DiagnosticMessage;
        Show_verbose_diagnostic_information: DiagnosticMessage;
        Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file: DiagnosticMessage;
        Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set: DiagnosticMessage;
        Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule: DiagnosticMessage;
        Print_names_of_generated_files_part_of_the_compilation: DiagnosticMessage;
        Print_names_of_files_part_of_the_compilation: DiagnosticMessage;
        The_locale_used_when_displaying_messages_to_the_user_e_g_en_us: DiagnosticMessage;
        Do_not_generate_custom_helper_functions_like_extends_in_compiled_output: DiagnosticMessage;
        Do_not_include_the_default_library_file_lib_d_ts: DiagnosticMessage;
        Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files: DiagnosticMessage;
        Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files: DiagnosticMessage;
        List_of_folders_to_include_type_definitions_from: DiagnosticMessage;
        Disable_size_limitations_on_JavaScript_projects: DiagnosticMessage;
        The_character_set_of_the_input_files: DiagnosticMessage;
        Do_not_truncate_error_messages: DiagnosticMessage;
        Output_directory_for_generated_declaration_files: DiagnosticMessage;
        A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl: DiagnosticMessage;
        List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime: DiagnosticMessage;
        Show_all_compiler_options: DiagnosticMessage;
        Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file: DiagnosticMessage;
        Command_line_Options: DiagnosticMessage;
        Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3: DiagnosticMessage;
        Enable_all_strict_type_checking_options: DiagnosticMessage;
        Scoped_package_detected_looking_in_0: DiagnosticMessage;
        Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2: DiagnosticMessage;
        Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: DiagnosticMessage;
        Enable_strict_checking_of_function_types: DiagnosticMessage;
        Enable_strict_checking_of_property_initialization_in_classes: DiagnosticMessage;
        Numeric_separators_are_not_allowed_here: DiagnosticMessage;
        Multiple_consecutive_numeric_separators_are_not_permitted: DiagnosticMessage;
        Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen: DiagnosticMessage;
        All_imports_in_import_declaration_are_unused: DiagnosticMessage;
        Found_1_error_Watching_for_file_changes: DiagnosticMessage;
        Found_0_errors_Watching_for_file_changes: DiagnosticMessage;
        Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols: DiagnosticMessage;
        _0_is_declared_but_never_used: DiagnosticMessage;
        Include_modules_imported_with_json_extension: DiagnosticMessage;
        All_destructured_elements_are_unused: DiagnosticMessage;
        All_variables_are_unused: DiagnosticMessage;
        Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0: DiagnosticMessage;
        Conflicts_are_in_this_file: DiagnosticMessage;
        Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0: DiagnosticMessage;
        _0_was_also_declared_here: DiagnosticMessage;
        and_here: DiagnosticMessage;
        All_type_parameters_are_unused: DiagnosticMessage;
        package_json_has_a_typesVersions_field_with_version_specific_path_mappings: DiagnosticMessage;
        package_json_does_not_have_a_typesVersions_entry_that_matches_version_0: DiagnosticMessage;
        package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2: DiagnosticMessage;
        package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range: DiagnosticMessage;
        An_argument_for_0_was_not_provided: DiagnosticMessage;
        An_argument_matching_this_binding_pattern_was_not_provided: DiagnosticMessage;
        Did_you_mean_to_call_this_expression: DiagnosticMessage;
        Did_you_mean_to_use_new_with_this_expression: DiagnosticMessage;
        Enable_strict_bind_call_and_apply_methods_on_functions: DiagnosticMessage;
        Using_compiler_options_of_project_reference_redirect_0: DiagnosticMessage;
        Found_1_error: DiagnosticMessage;
        Found_0_errors: DiagnosticMessage;
        Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2: DiagnosticMessage;
        Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3: DiagnosticMessage;
        package_json_had_a_falsy_0_field: DiagnosticMessage;
        Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects: DiagnosticMessage;
        Emit_class_fields_with_Define_instead_of_Set: DiagnosticMessage;
        Generates_a_CPU_profile: DiagnosticMessage;
        Disable_solution_searching_for_this_project: DiagnosticMessage;
        Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling_UseFsEvents_UseFsEventsOnParentDirectory: DiagnosticMessage;
        Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively_Colon_UseFsEvents_default_FixedPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling: DiagnosticMessage;
        Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_FixedInterval_default_PriorityInterval_DynamicPriority_FixedChunkSize: DiagnosticMessage;
        Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3: DiagnosticMessage;
        Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line: DiagnosticMessage;
        Could_not_resolve_the_path_0_with_the_extensions_Colon_1: DiagnosticMessage;
        Declaration_augments_declaration_in_another_file_This_cannot_be_serialized: DiagnosticMessage;
        This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_file: DiagnosticMessage;
        This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without: DiagnosticMessage;
        Disable_loading_referenced_projects: DiagnosticMessage;
        Arguments_for_the_rest_parameter_0_were_not_provided: DiagnosticMessage;
        Generates_an_event_trace_and_a_list_of_types: DiagnosticMessage;
        Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react: DiagnosticMessage;
        File_0_exists_according_to_earlier_cached_lookups: DiagnosticMessage;
        File_0_does_not_exist_according_to_earlier_cached_lookups: DiagnosticMessage;
        Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1: DiagnosticMessage;
        Resolving_type_reference_directive_0_containing_file_1: DiagnosticMessage;
        Interpret_optional_property_types_as_written_rather_than_adding_undefined: DiagnosticMessage;
        Modules: DiagnosticMessage;
        File_Management: DiagnosticMessage;
        Emit: DiagnosticMessage;
        JavaScript_Support: DiagnosticMessage;
        Type_Checking: DiagnosticMessage;
        Editor_Support: DiagnosticMessage;
        Watch_and_Build_Modes: DiagnosticMessage;
        Compiler_Diagnostics: DiagnosticMessage;
        Interop_Constraints: DiagnosticMessage;
        Backwards_Compatibility: DiagnosticMessage;
        Language_and_Environment: DiagnosticMessage;
        Projects: DiagnosticMessage;
        Output_Formatting: DiagnosticMessage;
        Completeness: DiagnosticMessage;
        _0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file: DiagnosticMessage;
        Found_1_error_in_1: DiagnosticMessage;
        Found_0_errors_in_the_same_file_starting_at_Colon_1: DiagnosticMessage;
        Found_0_errors_in_1_files: DiagnosticMessage;
        File_name_0_has_a_1_extension_looking_up_2_instead: DiagnosticMessage;
        Module_0_was_resolved_to_1_but_allowArbitraryExtensions_is_not_set: DiagnosticMessage;
        Enable_importing_files_with_any_extension_provided_a_declaration_file_is_present: DiagnosticMessage;
        Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve: DiagnosticMessage;
        Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1: DiagnosticMessage;
        Invalid_import_specifier_0_has_no_possible_resolutions: DiagnosticMessage;
        package_json_scope_0_has_no_imports_defined: DiagnosticMessage;
        package_json_scope_0_explicitly_maps_specifier_1_to_null: DiagnosticMessage;
        package_json_scope_0_has_invalid_type_for_target_of_specifier_1: DiagnosticMessage;
        Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1: DiagnosticMessage;
        Resolution_of_non_relative_name_failed_trying_with_modern_Node_resolution_features_disabled_to_see_if_npm_library_needs_configuration_update: DiagnosticMessage;
        There_are_types_at_0_but_this_result_could_not_be_resolved_when_respecting_package_json_exports_The_1_library_may_need_to_update_its_package_json_or_typings: DiagnosticMessage;
        Enable_project_compilation: DiagnosticMessage;
        Composite_projects_may_not_disable_declaration_emit: DiagnosticMessage;
        Output_file_0_has_not_been_built_from_source_file_1: DiagnosticMessage;
        Referenced_project_0_must_have_setting_composite_Colon_true: DiagnosticMessage;
        File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern: DiagnosticMessage;
        Cannot_prepend_project_0_because_it_does_not_have_outFile_set: DiagnosticMessage;
        Output_file_0_from_project_1_does_not_exist: DiagnosticMessage;
        Referenced_project_0_may_not_disable_emit: DiagnosticMessage;
        Project_0_is_out_of_date_because_output_1_is_older_than_input_2: DiagnosticMessage;
        Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2: DiagnosticMessage;
        Project_0_is_out_of_date_because_output_file_1_does_not_exist: DiagnosticMessage;
        Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date: DiagnosticMessage;
        Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies: DiagnosticMessage;
        Projects_in_this_build_Colon_0: DiagnosticMessage;
        A_non_dry_build_would_delete_the_following_files_Colon_0: DiagnosticMessage;
        A_non_dry_build_would_build_project_0: DiagnosticMessage;
        Building_project_0: DiagnosticMessage;
        Updating_output_timestamps_of_project_0: DiagnosticMessage;
        Project_0_is_up_to_date: DiagnosticMessage;
        Skipping_build_of_project_0_because_its_dependency_1_has_errors: DiagnosticMessage;
        Project_0_can_t_be_built_because_its_dependency_1_has_errors: DiagnosticMessage;
        Build_one_or_more_projects_and_their_dependencies_if_out_of_date: DiagnosticMessage;
        Delete_the_outputs_of_all_projects: DiagnosticMessage;
        Show_what_would_be_built_or_deleted_if_specified_with_clean: DiagnosticMessage;
        Option_build_must_be_the_first_command_line_argument: DiagnosticMessage;
        Options_0_and_1_cannot_be_combined: DiagnosticMessage;
        Updating_unchanged_output_timestamps_of_project_0: DiagnosticMessage;
        Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed: DiagnosticMessage;
        Updating_output_of_project_0: DiagnosticMessage;
        A_non_dry_build_would_update_timestamps_for_output_of_project_0: DiagnosticMessage;
        A_non_dry_build_would_update_output_of_project_0: DiagnosticMessage;
        Cannot_update_output_of_project_0_because_there_was_error_reading_file_1: DiagnosticMessage;
        Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1: DiagnosticMessage;
        Composite_projects_may_not_disable_incremental_compilation: DiagnosticMessage;
        Specify_file_to_store_incremental_compilation_information: DiagnosticMessage;
        Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2: DiagnosticMessage;
        Skipping_build_of_project_0_because_its_dependency_1_was_not_built: DiagnosticMessage;
        Project_0_can_t_be_built_because_its_dependency_1_was_not_built: DiagnosticMessage;
        Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: DiagnosticMessage;
        _0_is_deprecated: DiagnosticMessage;
        Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_native_implementation_of_the_Web_Performance_API_could_not_be_found: DiagnosticMessage;
        The_signature_0_of_1_is_deprecated: DiagnosticMessage;
        Project_0_is_being_forcibly_rebuilt: DiagnosticMessage;
        Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved: DiagnosticMessage;
        Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2: DiagnosticMessage;
        Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: DiagnosticMessage;
        Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved: DiagnosticMessage;
        Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: DiagnosticMessage;
        Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: DiagnosticMessage;
        Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: DiagnosticMessage;
        Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: DiagnosticMessage;
        Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: DiagnosticMessage;
        Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: DiagnosticMessage;
        Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitted: DiagnosticMessage;
        Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_files: DiagnosticMessage;
        Project_0_is_out_of_date_because_there_was_error_reading_file_1: DiagnosticMessage;
        Resolving_in_0_mode_with_conditions_1: DiagnosticMessage;
        Matched_0_condition_1: DiagnosticMessage;
        Using_0_subpath_1_with_target_2: DiagnosticMessage;
        Saw_non_matching_condition_0: DiagnosticMessage;
        Project_0_is_out_of_date_because_buildinfo_file_1_indicates_there_is_change_in_compilerOptions: DiagnosticMessage;
        Allow_imports_to_include_TypeScript_file_extensions_Requires_moduleResolution_bundler_and_either_noEmit_or_emitDeclarationOnly_to_be_set: DiagnosticMessage;
        Use_the_package_json_exports_field_when_resolving_package_imports: DiagnosticMessage;
        Use_the_package_json_imports_field_when_resolving_imports: DiagnosticMessage;
        Conditions_to_set_in_addition_to_the_resolver_specific_defaults_when_resolving_imports: DiagnosticMessage;
        true_when_moduleResolution_is_node16_nodenext_or_bundler_otherwise_false: DiagnosticMessage;
        Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_file_2_was_root_file_of_compilation_but_not_any_more: DiagnosticMessage;
        Entering_conditional_exports: DiagnosticMessage;
        Resolved_under_condition_0: DiagnosticMessage;
        Failed_to_resolve_under_condition_0: DiagnosticMessage;
        Exiting_conditional_exports: DiagnosticMessage;
        The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1: DiagnosticMessage;
        The_expected_type_comes_from_this_index_signature: DiagnosticMessage;
        The_expected_type_comes_from_the_return_type_of_this_signature: DiagnosticMessage;
        Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing: DiagnosticMessage;
        File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option: DiagnosticMessage;
        Print_names_of_files_and_the_reason_they_are_part_of_the_compilation: DiagnosticMessage;
        Consider_adding_a_declare_modifier_to_this_class: DiagnosticMessage;
        Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these_files: DiagnosticMessage;
        Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export: DiagnosticMessage;
        Allow_accessing_UMD_globals_from_modules: DiagnosticMessage;
        Disable_error_reporting_for_unreachable_code: DiagnosticMessage;
        Disable_error_reporting_for_unused_labels: DiagnosticMessage;
        Ensure_use_strict_is_always_emitted: DiagnosticMessage;
        Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: DiagnosticMessage;
        Specify_the_base_directory_to_resolve_non_relative_module_names: DiagnosticMessage;
        No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files: DiagnosticMessage;
        Enable_error_reporting_in_type_checked_JavaScript_files: DiagnosticMessage;
        Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references: DiagnosticMessage;
        Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project: DiagnosticMessage;
        Specify_the_output_directory_for_generated_declaration_files: DiagnosticMessage;
        Create_sourcemaps_for_d_ts_files: DiagnosticMessage;
        Output_compiler_performance_information_after_building: DiagnosticMessage;
        Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project: DiagnosticMessage;
        Reduce_the_number_of_projects_loaded_automatically_by_TypeScript: DiagnosticMessage;
        Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server: DiagnosticMessage;
        Opt_a_project_out_of_multi_project_reference_checking_when_editing: DiagnosticMessage;
        Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects: DiagnosticMessage;
        Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration: DiagnosticMessage;
        Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files: DiagnosticMessage;
        Only_output_d_ts_files_and_not_JavaScript_files: DiagnosticMessage;
        Emit_design_type_metadata_for_decorated_declarations_in_source_files: DiagnosticMessage;
        Disable_the_type_acquisition_for_JavaScript_projects: DiagnosticMessage;
        Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheticDefaultImports_for_type_compatibility: DiagnosticMessage;
        Filters_results_from_the_include_option: DiagnosticMessage;
        Remove_a_list_of_directories_from_the_watch_process: DiagnosticMessage;
        Remove_a_list_of_files_from_the_watch_mode_s_processing: DiagnosticMessage;
        Enable_experimental_support_for_legacy_experimental_decorators: DiagnosticMessage;
        Print_files_read_during_the_compilation_including_why_it_was_included: DiagnosticMessage;
        Output_more_detailed_compiler_performance_information_after_building: DiagnosticMessage;
        Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_are_inherited: DiagnosticMessage;
        Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers: DiagnosticMessage;
        Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include: DiagnosticMessage;
        Build_all_projects_including_those_that_appear_to_be_up_to_date: DiagnosticMessage;
        Ensure_that_casing_is_correct_in_imports: DiagnosticMessage;
        Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging: DiagnosticMessage;
        Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file: DiagnosticMessage;
        Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation: DiagnosticMessage;
        Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects: DiagnosticMessage;
        Include_sourcemap_files_inside_the_emitted_JavaScript: DiagnosticMessage;
        Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript: DiagnosticMessage;
        Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports: DiagnosticMessage;
        Specify_what_JSX_code_is_generated: DiagnosticMessage;
        Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h: DiagnosticMessage;
        Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragment_or_Fragment: DiagnosticMessage;
        Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Asterisk: DiagnosticMessage;
        Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option: DiagnosticMessage;
        Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment: DiagnosticMessage;
        Print_the_names_of_emitted_files_after_a_compilation: DiagnosticMessage;
        Print_all_of_the_files_read_during_the_compilation: DiagnosticMessage;
        Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit: DiagnosticMessage;
        Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: DiagnosticMessage;
        Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicable_with_allowJs: DiagnosticMessage;
        Specify_what_module_code_is_generated: DiagnosticMessage;
        Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier: DiagnosticMessage;
        Set_the_newline_character_for_emitting_files: DiagnosticMessage;
        Disable_emitting_files_from_a_compilation: DiagnosticMessage;
        Disable_generating_custom_helper_functions_like_extends_in_compiled_output: DiagnosticMessage;
        Disable_emitting_files_if_any_type_checking_errors_are_reported: DiagnosticMessage;
        Disable_truncating_types_in_error_messages: DiagnosticMessage;
        Enable_error_reporting_for_fallthrough_cases_in_switch_statements: DiagnosticMessage;
        Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type: DiagnosticMessage;
        Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier: DiagnosticMessage;
        Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function: DiagnosticMessage;
        Enable_error_reporting_when_this_is_given_the_type_any: DiagnosticMessage;
        Disable_adding_use_strict_directives_in_emitted_JavaScript_files: DiagnosticMessage;
        Disable_including_any_library_files_including_the_default_lib_d_ts: DiagnosticMessage;
        Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type: DiagnosticMessage;
        Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add_to_a_project: DiagnosticMessage;
        Disable_strict_checking_of_generic_signatures_in_function_types: DiagnosticMessage;
        Add_undefined_to_a_type_when_accessed_using_an_index: DiagnosticMessage;
        Enable_error_reporting_when_local_variables_aren_t_read: DiagnosticMessage;
        Raise_an_error_when_a_function_parameter_isn_t_read: DiagnosticMessage;
        Deprecated_setting_Use_outFile_instead: DiagnosticMessage;
        Specify_an_output_folder_for_all_emitted_files: DiagnosticMessage;
        Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designates_a_file_that_bundles_all_d_ts_output: DiagnosticMessage;
        Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations: DiagnosticMessage;
        Specify_a_list_of_language_service_plugins_to_include: DiagnosticMessage;
        Disable_erasing_const_enum_declarations_in_generated_code: DiagnosticMessage;
        Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node: DiagnosticMessage;
        Disable_wiping_the_console_in_watch_mode: DiagnosticMessage;
        Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read: DiagnosticMessage;
        Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit: DiagnosticMessage;
        Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references: DiagnosticMessage;
        Disable_emitting_comments: DiagnosticMessage;
        Enable_importing_json_files: DiagnosticMessage;
        Specify_the_root_folder_within_your_source_files: DiagnosticMessage;
        Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules: DiagnosticMessage;
        Skip_type_checking_d_ts_files_that_are_included_with_TypeScript: DiagnosticMessage;
        Skip_type_checking_all_d_ts_files: DiagnosticMessage;
        Create_source_map_files_for_emitted_JavaScript_files: DiagnosticMessage;
        Specify_the_root_path_for_debuggers_to_find_the_reference_source_code: DiagnosticMessage;
        Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function: DiagnosticMessage;
        When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible: DiagnosticMessage;
        When_type_checking_take_into_account_null_and_undefined: DiagnosticMessage;
        Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor: DiagnosticMessage;
        Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments: DiagnosticMessage;
        Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals: DiagnosticMessage;
        Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures: DiagnosticMessage;
        Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively: DiagnosticMessage;
        Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declarations: DiagnosticMessage;
        Log_paths_used_during_the_moduleResolution_process: DiagnosticMessage;
        Specify_the_path_to_tsbuildinfo_incremental_compilation_file: DiagnosticMessage;
        Specify_options_for_automatic_acquisition_of_declaration_files: DiagnosticMessage;
        Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types: DiagnosticMessage;
        Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file: DiagnosticMessage;
        Emit_ECMAScript_standard_compliant_class_fields: DiagnosticMessage;
        Enable_verbose_logging: DiagnosticMessage;
        Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality: DiagnosticMessage;
        Specify_how_the_TypeScript_watch_mode_works: DiagnosticMessage;
        Require_undeclared_properties_from_index_signatures_to_use_element_accesses: DiagnosticMessage;
        Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types: DiagnosticMessage;
        Default_catch_clause_variables_as_unknown_instead_of_any: DiagnosticMessage;
        Do_not_transform_or_elide_any_imports_or_exports_not_marked_as_type_only_ensuring_they_are_written_in_the_output_file_s_format_based_on_the_module_setting: DiagnosticMessage;
        one_of_Colon: DiagnosticMessage;
        one_or_more_Colon: DiagnosticMessage;
        type_Colon: DiagnosticMessage;
        default_Colon: DiagnosticMessage;
        module_system_or_esModuleInterop: DiagnosticMessage;
        false_unless_strict_is_set: DiagnosticMessage;
        false_unless_composite_is_set: DiagnosticMessage;
        node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified: DiagnosticMessage;
        if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk: DiagnosticMessage;
        true_if_composite_false_otherwise: DiagnosticMessage;
        module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node: DiagnosticMessage;
        Computed_from_the_list_of_input_files: DiagnosticMessage;
        Platform_specific: DiagnosticMessage;
        You_can_learn_about_all_of_the_compiler_options_at_0: DiagnosticMessage;
        Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_config_watch_mode_with_Colon: DiagnosticMessage;
        Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_trigger_building_composite_projects_which_you_can_learn_more_about_at_0: DiagnosticMessage;
        COMMON_COMMANDS: DiagnosticMessage;
        ALL_COMPILER_OPTIONS: DiagnosticMessage;
        WATCH_OPTIONS: DiagnosticMessage;
        BUILD_OPTIONS: DiagnosticMessage;
        COMMON_COMPILER_OPTIONS: DiagnosticMessage;
        COMMAND_LINE_FLAGS: DiagnosticMessage;
        tsc_Colon_The_TypeScript_Compiler: DiagnosticMessage;
        Compiles_the_current_project_tsconfig_json_in_the_working_directory: DiagnosticMessage;
        Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options: DiagnosticMessage;
        Build_a_composite_project_in_the_working_directory: DiagnosticMessage;
        Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory: DiagnosticMessage;
        Compiles_the_TypeScript_project_located_at_the_specified_path: DiagnosticMessage;
        An_expanded_version_of_this_information_showing_all_possible_compiler_options: DiagnosticMessage;
        Compiles_the_current_project_with_additional_settings: DiagnosticMessage;
        true_for_ES2022_and_above_including_ESNext: DiagnosticMessage;
        List_of_file_name_suffixes_to_search_when_resolving_a_module: DiagnosticMessage;
        Variable_0_implicitly_has_an_1_type: DiagnosticMessage;
        Parameter_0_implicitly_has_an_1_type: DiagnosticMessage;
        Member_0_implicitly_has_an_1_type: DiagnosticMessage;
        new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: DiagnosticMessage;
        _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: DiagnosticMessage;
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: DiagnosticMessage;
        This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation: DiagnosticMessage;
        Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: DiagnosticMessage;
        Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: DiagnosticMessage;
        Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number: DiagnosticMessage;
        Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type: DiagnosticMessage;
        Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature: DiagnosticMessage;
        Object_literal_s_property_0_implicitly_has_an_1_type: DiagnosticMessage;
        Rest_parameter_0_implicitly_has_an_any_type: DiagnosticMessage;
        Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: DiagnosticMessage;
        _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: DiagnosticMessage;
        _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: DiagnosticMessage;
        Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: DiagnosticMessage;
        Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation: DiagnosticMessage;
        JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists: DiagnosticMessage;
        Unreachable_code_detected: DiagnosticMessage;
        Unused_label: DiagnosticMessage;
        Fallthrough_case_in_switch: DiagnosticMessage;
        Not_all_code_paths_return_a_value: DiagnosticMessage;
        Binding_element_0_implicitly_has_an_1_type: DiagnosticMessage;
        Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation: DiagnosticMessage;
        Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation: DiagnosticMessage;
        Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined: DiagnosticMessage;
        Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0: DiagnosticMessage;
        Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0: DiagnosticMessage;
        Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for_all_imports_Implies_allowSyntheticDefaultImports: DiagnosticMessage;
        Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead: DiagnosticMessage;
        Mapped_object_type_implicitly_has_an_any_template_type: DiagnosticMessage;
        If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1: DiagnosticMessage;
        The_containing_arrow_function_captures_the_global_value_of_this: DiagnosticMessage;
        Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used: DiagnosticMessage;
        Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
        Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
        Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
        Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
        Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
        Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage: DiagnosticMessage;
        Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage: DiagnosticMessage;
        _0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage: DiagnosticMessage;
        Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1: DiagnosticMessage;
        Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1: DiagnosticMessage;
        Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1: DiagnosticMessage;
        No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1: DiagnosticMessage;
        _0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type: DiagnosticMessage;
        The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_type_annotation_is_needed: DiagnosticMessage;
        yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation: DiagnosticMessage;
        If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1: DiagnosticMessage;
        This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead: DiagnosticMessage;
        This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint: DiagnosticMessage;
        A_mapped_type_may_not_declare_properties_or_methods: DiagnosticMessage;
        You_cannot_rename_this_element: DiagnosticMessage;
        You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library: DiagnosticMessage;
        import_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        export_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        Type_parameter_declarations_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        implements_clauses_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        _0_declarations_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        Type_aliases_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        The_0_modifier_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        Type_annotations_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        Type_arguments_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        Parameter_modifiers_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        Non_null_assertions_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        Type_assertion_expressions_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0: DiagnosticMessage;
        Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0: DiagnosticMessage;
        Report_errors_in_js_files: DiagnosticMessage;
        JSDoc_types_can_only_be_used_inside_documentation_comments: DiagnosticMessage;
        JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags: DiagnosticMessage;
        JSDoc_0_is_not_attached_to_a_class: DiagnosticMessage;
        JSDoc_0_1_does_not_match_the_extends_2_clause: DiagnosticMessage;
        JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name: DiagnosticMessage;
        Class_declarations_cannot_have_more_than_one_augments_or_extends_tag: DiagnosticMessage;
        Expected_0_type_arguments_provide_these_with_an_extends_tag: DiagnosticMessage;
        Expected_0_1_type_arguments_provide_these_with_an_extends_tag: DiagnosticMessage;
        JSDoc_may_only_appear_in_the_last_parameter_of_a_signature: DiagnosticMessage;
        JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type: DiagnosticMessage;
        The_type_of_a_function_declaration_must_match_the_function_s_signature: DiagnosticMessage;
        You_cannot_rename_a_module_via_a_global_import: DiagnosticMessage;
        Qualified_name_0_is_not_allowed_without_a_leading_param_object_1: DiagnosticMessage;
        A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags: DiagnosticMessage;
        The_tag_was_first_specified_here: DiagnosticMessage;
        You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder: DiagnosticMessage;
        You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder: DiagnosticMessage;
        Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files: DiagnosticMessage;
        Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export: DiagnosticMessage;
        Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_declaration_emit: DiagnosticMessage;
        Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotation_may_unblock_declaration_emit: DiagnosticMessage;
        JSX_attributes_must_only_be_assigned_a_non_empty_expression: DiagnosticMessage;
        JSX_elements_cannot_have_multiple_attributes_with_the_same_name: DiagnosticMessage;
        Expected_corresponding_JSX_closing_tag_for_0: DiagnosticMessage;
        Cannot_use_JSX_unless_the_jsx_flag_is_provided: DiagnosticMessage;
        A_constructor_cannot_contain_a_super_call_when_its_class_extends_null: DiagnosticMessage;
        An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: DiagnosticMessage;
        A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: DiagnosticMessage;
        JSX_element_0_has_no_corresponding_closing_tag: DiagnosticMessage;
        super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class: DiagnosticMessage;
        Unknown_type_acquisition_option_0: DiagnosticMessage;
        super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class: DiagnosticMessage;
        _0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2: DiagnosticMessage;
        Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor: DiagnosticMessage;
        JSX_fragment_has_no_corresponding_closing_tag: DiagnosticMessage;
        Expected_corresponding_closing_tag_for_JSX_fragment: DiagnosticMessage;
        The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option: DiagnosticMessage;
        An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments: DiagnosticMessage;
        Unknown_type_acquisition_option_0_Did_you_mean_1: DiagnosticMessage;
        _0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1: DiagnosticMessage;
        _0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1: DiagnosticMessage;
        Circularity_detected_while_resolving_configuration_Colon_0: DiagnosticMessage;
        The_files_list_in_config_file_0_is_empty: DiagnosticMessage;
        No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2: DiagnosticMessage;
        File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module: DiagnosticMessage;
        This_constructor_function_may_be_converted_to_a_class_declaration: DiagnosticMessage;
        Import_may_be_converted_to_a_default_import: DiagnosticMessage;
        JSDoc_types_may_be_moved_to_TypeScript_types: DiagnosticMessage;
        require_call_may_be_converted_to_an_import: DiagnosticMessage;
        This_may_be_converted_to_an_async_function: DiagnosticMessage;
        await_has_no_effect_on_the_type_of_this_expression: DiagnosticMessage;
        Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers: DiagnosticMessage;
        Add_missing_super_call: DiagnosticMessage;
        Make_super_call_the_first_statement_in_the_constructor: DiagnosticMessage;
        Change_extends_to_implements: DiagnosticMessage;
        Remove_unused_declaration_for_Colon_0: DiagnosticMessage;
        Remove_import_from_0: DiagnosticMessage;
        Implement_interface_0: DiagnosticMessage;
        Implement_inherited_abstract_class: DiagnosticMessage;
        Add_0_to_unresolved_variable: DiagnosticMessage;
        Remove_variable_statement: DiagnosticMessage;
        Remove_template_tag: DiagnosticMessage;
        Remove_type_parameters: DiagnosticMessage;
        Import_0_from_1: DiagnosticMessage;
        Change_0_to_1: DiagnosticMessage;
        Declare_property_0: DiagnosticMessage;
        Add_index_signature_for_property_0: DiagnosticMessage;
        Disable_checking_for_this_file: DiagnosticMessage;
        Ignore_this_error_message: DiagnosticMessage;
        Initialize_property_0_in_the_constructor: DiagnosticMessage;
        Initialize_static_property_0: DiagnosticMessage;
        Change_spelling_to_0: DiagnosticMessage;
        Declare_method_0: DiagnosticMessage;
        Declare_static_method_0: DiagnosticMessage;
        Prefix_0_with_an_underscore: DiagnosticMessage;
        Rewrite_as_the_indexed_access_type_0: DiagnosticMessage;
        Declare_static_property_0: DiagnosticMessage;
        Call_decorator_expression: DiagnosticMessage;
        Add_async_modifier_to_containing_function: DiagnosticMessage;
        Replace_infer_0_with_unknown: DiagnosticMessage;
        Replace_all_unused_infer_with_unknown: DiagnosticMessage;
        Add_parameter_name: DiagnosticMessage;
        Declare_private_property_0: DiagnosticMessage;
        Replace_0_with_Promise_1: DiagnosticMessage;
        Fix_all_incorrect_return_type_of_an_async_functions: DiagnosticMessage;
        Declare_private_method_0: DiagnosticMessage;
        Remove_unused_destructuring_declaration: DiagnosticMessage;
        Remove_unused_declarations_for_Colon_0: DiagnosticMessage;
        Declare_a_private_field_named_0: DiagnosticMessage;
        Includes_imports_of_types_referenced_by_0: DiagnosticMessage;
        Remove_type_from_import_declaration_from_0: DiagnosticMessage;
        Remove_type_from_import_of_0_from_1: DiagnosticMessage;
        Add_import_from_0: DiagnosticMessage;
        Update_import_from_0: DiagnosticMessage;
        Export_0_from_module_1: DiagnosticMessage;
        Export_all_referenced_locals: DiagnosticMessage;
        Convert_function_to_an_ES2015_class: DiagnosticMessage;
        Convert_0_to_1_in_0: DiagnosticMessage;
        Extract_to_0_in_1: DiagnosticMessage;
        Extract_function: DiagnosticMessage;
        Extract_constant: DiagnosticMessage;
        Extract_to_0_in_enclosing_scope: DiagnosticMessage;
        Extract_to_0_in_1_scope: DiagnosticMessage;
        Annotate_with_type_from_JSDoc: DiagnosticMessage;
        Infer_type_of_0_from_usage: DiagnosticMessage;
        Infer_parameter_types_from_usage: DiagnosticMessage;
        Convert_to_default_import: DiagnosticMessage;
        Install_0: DiagnosticMessage;
        Replace_import_with_0: DiagnosticMessage;
        Use_synthetic_default_member: DiagnosticMessage;
        Convert_to_ES_module: DiagnosticMessage;
        Add_undefined_type_to_property_0: DiagnosticMessage;
        Add_initializer_to_property_0: DiagnosticMessage;
        Add_definite_assignment_assertion_to_property_0: DiagnosticMessage;
        Convert_all_type_literals_to_mapped_type: DiagnosticMessage;
        Add_all_missing_members: DiagnosticMessage;
        Infer_all_types_from_usage: DiagnosticMessage;
        Delete_all_unused_declarations: DiagnosticMessage;
        Prefix_all_unused_declarations_with_where_possible: DiagnosticMessage;
        Fix_all_detected_spelling_errors: DiagnosticMessage;
        Add_initializers_to_all_uninitialized_properties: DiagnosticMessage;
        Add_definite_assignment_assertions_to_all_uninitialized_properties: DiagnosticMessage;
        Add_undefined_type_to_all_uninitialized_properties: DiagnosticMessage;
        Change_all_jsdoc_style_types_to_TypeScript: DiagnosticMessage;
        Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types: DiagnosticMessage;
        Implement_all_unimplemented_interfaces: DiagnosticMessage;
        Install_all_missing_types_packages: DiagnosticMessage;
        Rewrite_all_as_indexed_access_types: DiagnosticMessage;
        Convert_all_to_default_imports: DiagnosticMessage;
        Make_all_super_calls_the_first_statement_in_their_constructor: DiagnosticMessage;
        Add_qualifier_to_all_unresolved_variables_matching_a_member_name: DiagnosticMessage;
        Change_all_extended_interfaces_to_implements: DiagnosticMessage;
        Add_all_missing_super_calls: DiagnosticMessage;
        Implement_all_inherited_abstract_classes: DiagnosticMessage;
        Add_all_missing_async_modifiers: DiagnosticMessage;
        Add_ts_ignore_to_all_error_messages: DiagnosticMessage;
        Annotate_everything_with_types_from_JSDoc: DiagnosticMessage;
        Add_to_all_uncalled_decorators: DiagnosticMessage;
        Convert_all_constructor_functions_to_classes: DiagnosticMessage;
        Generate_get_and_set_accessors: DiagnosticMessage;
        Convert_require_to_import: DiagnosticMessage;
        Convert_all_require_to_import: DiagnosticMessage;
        Move_to_a_new_file: DiagnosticMessage;
        Remove_unreachable_code: DiagnosticMessage;
        Remove_all_unreachable_code: DiagnosticMessage;
        Add_missing_typeof: DiagnosticMessage;
        Remove_unused_label: DiagnosticMessage;
        Remove_all_unused_labels: DiagnosticMessage;
        Convert_0_to_mapped_object_type: DiagnosticMessage;
        Convert_namespace_import_to_named_imports: DiagnosticMessage;
        Convert_named_imports_to_namespace_import: DiagnosticMessage;
        Add_or_remove_braces_in_an_arrow_function: DiagnosticMessage;
        Add_braces_to_arrow_function: DiagnosticMessage;
        Remove_braces_from_arrow_function: DiagnosticMessage;
        Convert_default_export_to_named_export: DiagnosticMessage;
        Convert_named_export_to_default_export: DiagnosticMessage;
        Add_missing_enum_member_0: DiagnosticMessage;
        Add_all_missing_imports: DiagnosticMessage;
        Convert_to_async_function: DiagnosticMessage;
        Convert_all_to_async_functions: DiagnosticMessage;
        Add_missing_call_parentheses: DiagnosticMessage;
        Add_all_missing_call_parentheses: DiagnosticMessage;
        Add_unknown_conversion_for_non_overlapping_types: DiagnosticMessage;
        Add_unknown_to_all_conversions_of_non_overlapping_types: DiagnosticMessage;
        Add_missing_new_operator_to_call: DiagnosticMessage;
        Add_missing_new_operator_to_all_calls: DiagnosticMessage;
        Add_names_to_all_parameters_without_names: DiagnosticMessage;
        Enable_the_experimentalDecorators_option_in_your_configuration_file: DiagnosticMessage;
        Convert_parameters_to_destructured_object: DiagnosticMessage;
        Extract_type: DiagnosticMessage;
        Extract_to_type_alias: DiagnosticMessage;
        Extract_to_typedef: DiagnosticMessage;
        Infer_this_type_of_0_from_usage: DiagnosticMessage;
        Add_const_to_unresolved_variable: DiagnosticMessage;
        Add_const_to_all_unresolved_variables: DiagnosticMessage;
        Add_await: DiagnosticMessage;
        Add_await_to_initializer_for_0: DiagnosticMessage;
        Fix_all_expressions_possibly_missing_await: DiagnosticMessage;
        Remove_unnecessary_await: DiagnosticMessage;
        Remove_all_unnecessary_uses_of_await: DiagnosticMessage;
        Enable_the_jsx_flag_in_your_configuration_file: DiagnosticMessage;
        Add_await_to_initializers: DiagnosticMessage;
        Extract_to_interface: DiagnosticMessage;
        Convert_to_a_bigint_numeric_literal: DiagnosticMessage;
        Convert_all_to_bigint_numeric_literals: DiagnosticMessage;
        Convert_const_to_let: DiagnosticMessage;
        Prefix_with_declare: DiagnosticMessage;
        Prefix_all_incorrect_property_declarations_with_declare: DiagnosticMessage;
        Convert_to_template_string: DiagnosticMessage;
        Add_export_to_make_this_file_into_a_module: DiagnosticMessage;
        Set_the_target_option_in_your_configuration_file_to_0: DiagnosticMessage;
        Set_the_module_option_in_your_configuration_file_to_0: DiagnosticMessage;
        Convert_invalid_character_to_its_html_entity_code: DiagnosticMessage;
        Convert_all_invalid_characters_to_HTML_entity_code: DiagnosticMessage;
        Convert_all_const_to_let: DiagnosticMessage;
        Convert_function_expression_0_to_arrow_function: DiagnosticMessage;
        Convert_function_declaration_0_to_arrow_function: DiagnosticMessage;
        Fix_all_implicit_this_errors: DiagnosticMessage;
        Wrap_invalid_character_in_an_expression_container: DiagnosticMessage;
        Wrap_all_invalid_characters_in_an_expression_container: DiagnosticMessage;
        Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file: DiagnosticMessage;
        Add_a_return_statement: DiagnosticMessage;
        Remove_braces_from_arrow_function_body: DiagnosticMessage;
        Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal: DiagnosticMessage;
        Add_all_missing_return_statement: DiagnosticMessage;
        Remove_braces_from_all_arrow_function_bodies_with_relevant_issues: DiagnosticMessage;
        Wrap_all_object_literal_with_parentheses: DiagnosticMessage;
        Move_labeled_tuple_element_modifiers_to_labels: DiagnosticMessage;
        Convert_overload_list_to_single_signature: DiagnosticMessage;
        Generate_get_and_set_accessors_for_all_overriding_properties: DiagnosticMessage;
        Wrap_in_JSX_fragment: DiagnosticMessage;
        Wrap_all_unparented_JSX_in_JSX_fragment: DiagnosticMessage;
        Convert_arrow_function_or_function_expression: DiagnosticMessage;
        Convert_to_anonymous_function: DiagnosticMessage;
        Convert_to_named_function: DiagnosticMessage;
        Convert_to_arrow_function: DiagnosticMessage;
        Remove_parentheses: DiagnosticMessage;
        Could_not_find_a_containing_arrow_function: DiagnosticMessage;
        Containing_function_is_not_an_arrow_function: DiagnosticMessage;
        Could_not_find_export_statement: DiagnosticMessage;
        This_file_already_has_a_default_export: DiagnosticMessage;
        Could_not_find_import_clause: DiagnosticMessage;
        Could_not_find_namespace_import_or_named_imports: DiagnosticMessage;
        Selection_is_not_a_valid_type_node: DiagnosticMessage;
        No_type_could_be_extracted_from_this_type_node: DiagnosticMessage;
        Could_not_find_property_for_which_to_generate_accessor: DiagnosticMessage;
        Name_is_not_valid: DiagnosticMessage;
        Can_only_convert_property_with_modifier: DiagnosticMessage;
        Switch_each_misused_0_to_1: DiagnosticMessage;
        Convert_to_optional_chain_expression: DiagnosticMessage;
        Could_not_find_convertible_access_expression: DiagnosticMessage;
        Could_not_find_matching_access_expressions: DiagnosticMessage;
        Can_only_convert_logical_AND_access_chains: DiagnosticMessage;
        Add_void_to_Promise_resolved_without_a_value: DiagnosticMessage;
        Add_void_to_all_Promises_resolved_without_a_value: DiagnosticMessage;
        Use_element_access_for_0: DiagnosticMessage;
        Use_element_access_for_all_undeclared_properties: DiagnosticMessage;
        Delete_all_unused_imports: DiagnosticMessage;
        Infer_function_return_type: DiagnosticMessage;
        Return_type_must_be_inferred_from_a_function: DiagnosticMessage;
        Could_not_determine_function_return_type: DiagnosticMessage;
        Could_not_convert_to_arrow_function: DiagnosticMessage;
        Could_not_convert_to_named_function: DiagnosticMessage;
        Could_not_convert_to_anonymous_function: DiagnosticMessage;
        Can_only_convert_string_concatenation: DiagnosticMessage;
        Selection_is_not_a_valid_statement_or_statements: DiagnosticMessage;
        Add_missing_function_declaration_0: DiagnosticMessage;
        Add_all_missing_function_declarations: DiagnosticMessage;
        Method_not_implemented: DiagnosticMessage;
        Function_not_implemented: DiagnosticMessage;
        Add_override_modifier: DiagnosticMessage;
        Remove_override_modifier: DiagnosticMessage;
        Add_all_missing_override_modifiers: DiagnosticMessage;
        Remove_all_unnecessary_override_modifiers: DiagnosticMessage;
        Can_only_convert_named_export: DiagnosticMessage;
        Add_missing_properties: DiagnosticMessage;
        Add_all_missing_properties: DiagnosticMessage;
        Add_missing_attributes: DiagnosticMessage;
        Add_all_missing_attributes: DiagnosticMessage;
        Add_undefined_to_optional_property_type: DiagnosticMessage;
        Convert_named_imports_to_default_import: DiagnosticMessage;
        Delete_unused_param_tag_0: DiagnosticMessage;
        Delete_all_unused_param_tags: DiagnosticMessage;
        Rename_param_tag_name_0_to_1: DiagnosticMessage;
        Use_0: DiagnosticMessage;
        Use_Number_isNaN_in_all_conditions: DiagnosticMessage;
        No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer: DiagnosticMessage;
        Classes_may_not_have_a_field_named_constructor: DiagnosticMessage;
        JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array: DiagnosticMessage;
        Private_identifiers_cannot_be_used_as_parameters: DiagnosticMessage;
        An_accessibility_modifier_cannot_be_used_with_a_private_identifier: DiagnosticMessage;
        The_operand_of_a_delete_operator_cannot_be_a_private_identifier: DiagnosticMessage;
        constructor_is_a_reserved_word: DiagnosticMessage;
        Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier: DiagnosticMessage;
        The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling: DiagnosticMessage;
        Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2: DiagnosticMessage;
        Private_identifiers_are_not_allowed_outside_class_bodies: DiagnosticMessage;
        The_shadowing_declaration_of_0_is_defined_here: DiagnosticMessage;
        The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here: DiagnosticMessage;
        _0_modifier_cannot_be_used_with_a_private_identifier: DiagnosticMessage;
        An_enum_member_cannot_be_named_with_a_private_identifier: DiagnosticMessage;
        can_only_be_used_at_the_start_of_a_file: DiagnosticMessage;
        Compiler_reserves_name_0_when_emitting_private_identifier_downlevel: DiagnosticMessage;
        Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher: DiagnosticMessage;
        Private_identifiers_are_not_allowed_in_variable_declarations: DiagnosticMessage;
        An_optional_chain_cannot_contain_private_identifiers: DiagnosticMessage;
        The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents: DiagnosticMessage;
        The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some: DiagnosticMessage;
        Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values: DiagnosticMessage;
        Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compiler_option_is_specified_e_g_Fragment: DiagnosticMessage;
        Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name: DiagnosticMessage;
        Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator: DiagnosticMessage;
        Await_expression_cannot_be_used_inside_a_class_static_block: DiagnosticMessage;
        For_await_loops_cannot_be_used_inside_a_class_static_block: DiagnosticMessage;
        Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block: DiagnosticMessage;
        A_return_statement_cannot_be_used_inside_a_class_static_block: DiagnosticMessage;
        _0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation: DiagnosticMessage;
        Types_cannot_appear_in_export_declarations_in_JavaScript_files: DiagnosticMessage;
        _0_is_automatically_exported_here: DiagnosticMessage;
        Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher: DiagnosticMessage;
        _0_is_of_type_unknown: DiagnosticMessage;
        _0_is_possibly_null: DiagnosticMessage;
        _0_is_possibly_undefined: DiagnosticMessage;
        _0_is_possibly_null_or_undefined: DiagnosticMessage;
        The_value_0_cannot_be_used_here: DiagnosticMessage;
        Compiler_option_0_cannot_be_given_an_empty_string: DiagnosticMessage;
    };
    /** @internal */
    function tokenIsIdentifierOrKeyword(token: SyntaxKind): boolean;
    /** @internal */
    function tokenIsIdentifierOrKeywordOrGreaterThan(token: SyntaxKind): boolean;
    /** @internal */ function isUnicodeIdentifierStart(code: number, languageVersion: ScriptTarget | undefined): boolean;
    function tokenToString(t: SyntaxKind): string | undefined;
    /** @internal */
    function stringToToken(s: string): SyntaxKind | undefined;
    /** @internal */
    function computeLineStarts(text: string): number[];
    function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;
    /** @internal */
    function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number, allowEdits?: true): number;
    /** @internal */
    function computePositionOfLineAndCharacter(lineStarts: readonly number[], line: number, character: number, debugText?: string, allowEdits?: true): number;
    /** @internal */
    function getLineStarts(sourceFile: SourceFileLike): readonly number[];
    /** @internal */
    function computeLineAndCharacterOfPosition(lineStarts: readonly number[], position: number): LineAndCharacter;
    /**
     * @internal
     * We assume the first line starts at position 0 and 'position' is non-negative.
     */
    function computeLineOfPosition(lineStarts: readonly number[], position: number, lowerBound?: number): number;
    /** @internal */
    function getLinesBetweenPositions(sourceFile: SourceFileLike, pos1: number, pos2: number): number;
    function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;
    function isWhiteSpaceLike(ch: number): boolean;
    /** Does not include line breaks. For that, see isWhiteSpaceLike. */
    function isWhiteSpaceSingleLine(ch: number): boolean;
    function isLineBreak(ch: number): boolean;
    /** @internal */
    function isOctalDigit(ch: number): boolean;
    function couldStartTrivia(text: string, pos: number): boolean;
    /** @internal */
    function skipTrivia(text: string, pos: number, stopAfterLineBreak?: boolean, stopAtComments?: boolean, inJSDoc?: boolean): number;
    /** @internal */
    function isShebangTrivia(text: string, pos: number): boolean;
    /** @internal */
    function scanShebangTrivia(text: string, pos: number): number;
    function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
    function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
    function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
    function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
    function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T, initial: U): U | undefined;
    function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T, initial: U): U | undefined;
    function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
    function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
    /** Optionally, get the shebang */
    function getShebang(text: string): string | undefined;
    function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;
    function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;
    /** @internal */
    function isIdentifierText(name: string, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;
    function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;
    /** @internal */
    function utf16EncodeAsString(codePoint: number): string;
    type ErrorCallback = (message: DiagnosticMessage, length: number) => void;
    interface Scanner {
        getStartPos(): number;
        getToken(): SyntaxKind;
        getTextPos(): number;
        getTokenPos(): number;
        getTokenText(): string;
        getTokenValue(): string;
        hasUnicodeEscape(): boolean;
        hasExtendedUnicodeEscape(): boolean;
        hasPrecedingLineBreak(): boolean;
        /** @internal */
        hasPrecedingJSDocComment(): boolean;
        isIdentifier(): boolean;
        isReservedWord(): boolean;
        isUnterminated(): boolean;
        /** @internal */
        getNumericLiteralFlags(): TokenFlags;
        /** @internal */
        getCommentDirectives(): CommentDirective[] | undefined;
        /** @internal */
        getTokenFlags(): TokenFlags;
        reScanGreaterToken(): SyntaxKind;
        reScanSlashToken(): SyntaxKind;
        reScanAsteriskEqualsToken(): SyntaxKind;
        reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind;
        reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind;
        scanJsxIdentifier(): SyntaxKind;
        scanJsxAttributeValue(): SyntaxKind;
        reScanJsxAttributeValue(): SyntaxKind;
        reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind;
        reScanLessThanToken(): SyntaxKind;
        reScanHashToken(): SyntaxKind;
        reScanQuestionToken(): SyntaxKind;
        reScanInvalidIdentifier(): SyntaxKind;
        scanJsxToken(): JsxTokenSyntaxKind;
        scanJsDocToken(): JSDocSyntaxKind;
        scan(): SyntaxKind;
        getText(): string;
        /** @internal */
        clearCommentDirectives(): void;
        setText(text: string | undefined, start?: number, length?: number): void;
        setOnError(onError: ErrorCallback | undefined): void;
        setScriptTarget(scriptTarget: ScriptTarget): void;
        setLanguageVariant(variant: LanguageVariant): void;
        setTextPos(textPos: number): void;
        /** @internal */
        setInJSDocType(inType: boolean): void;
        lookAhead<T>(callback: () => T): T;
        scanRange<T>(start: number, length: number, callback: () => T): T;
        tryScan<T>(callback: () => T): T;
    }
    /** @internal */
    const textToKeywordObj: MapLike<KeywordSyntaxKind>;
    function isExternalModuleNameRelative(moduleName: string): boolean;
    function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;
    function getDefaultLibFileName(options: CompilerOptions): string;
    function textSpanEnd(span: TextSpan): number;
    function textSpanIsEmpty(span: TextSpan): boolean;
    function textSpanContainsPosition(span: TextSpan, position: number): boolean;
    /** @internal */
    function textRangeContainsPositionInclusive(span: TextRange, position: number): boolean;
    function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;
    function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;
    function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
    function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;
    function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;
    function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;
    function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;
    function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
    function createTextSpan(start: number, length: number): TextSpan;
    function createTextSpanFromBounds(start: number, end: number): TextSpan;
    function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;
    function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;
    function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;
    /**
     * Called to merge all the changes that occurred across several versions of a script snapshot
     * into a single change.  i.e. if a user keeps making successive edits to a script we will
     * have a text change from V1 to V2, V2 to V3, ..., Vn.
     *
     * This function will then merge those changes into a single change range valid between V1 and
     * Vn.
     */
    function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;
    function getTypeParameterOwner(d: Declaration): Declaration | undefined;
    function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;
    function isEmptyBindingPattern(node: BindingName): node is BindingPattern;
    function isEmptyBindingElement(node: BindingElement | ArrayBindingElement): boolean;
    function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;
    function getCombinedModifierFlags(node: Declaration): ModifierFlags;
    /** @internal */
    function getCombinedNodeFlagsAlwaysIncludeJSDoc(node: Declaration): ModifierFlags;
    function getCombinedNodeFlags(node: Node): NodeFlags;
    /**
     * Checks to see if the locale is in the appropriate format,
     * and if it is, attempts to set the appropriate language.
     */
    function validateLocaleAndSetLanguage(locale: string, sys: {
        getExecutingFilePath(): string;
        resolvePath(path: string): string;
        fileExists(fileName: string): boolean;
        readFile(fileName: string): string | undefined;
    }, errors?: Diagnostic[]): void;
    function getOriginalNode(node: Node): Node;
    function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;
    function getOriginalNode(node: Node | undefined): Node | undefined;
    function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node) => node is T): T | undefined;
    /**
     * Iterates through the parent chain of a node and performs the callback on each parent until the callback
     * returns a truthy value, then returns that value.
     * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns "quit"
     * At that point findAncestor returns undefined.
     */
    function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined;
    function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | "quit"): Node | undefined;
    /**
     * Gets a value indicating whether a node originated in the parse tree.
     *
     * @param node The node to test.
     */
    function isParseTreeNode(node: Node): boolean;
    /**
     * Gets the original parse tree node for a node.
     *
     * @param node The original node.
     * @returns The original parse tree node if found; otherwise, undefined.
     */
    function getParseTreeNode(node: Node | undefined): Node | undefined;
    /**
     * Gets the original parse tree node for a node.
     *
     * @param node The original node.
     * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.
     * @returns The original parse tree node if found; otherwise, undefined.
     */
    function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined;
    /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */
    function escapeLeadingUnderscores(identifier: string): __String;
    /**
     * Remove extra underscore from escaped identifier text content.
     *
     * @param identifier The escaped identifier text.
     * @returns The unescaped identifier text.
     */
    function unescapeLeadingUnderscores(identifier: __String): string;
    function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;
    /**
     * If the text of an Identifier matches a keyword (including contextual and TypeScript-specific keywords), returns the
     * SyntaxKind for the matching keyword.
     */
    function identifierToKeywordKind(node: Identifier): KeywordSyntaxKind | undefined;
    function symbolName(symbol: Symbol): string;
    /** @internal */
    function nodeHasName(statement: Node, name: Identifier): boolean;
    function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;
    /** @internal */
    function isNamedDeclaration(node: Node): node is NamedDeclaration & {
        name: DeclarationName;
    };
    /** @internal */
    function getNonAssignedNameOfDeclaration(declaration: Declaration | Expression): DeclarationName | undefined;
    function getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;
    /** @internal */
    function getAssignedName(node: Node): DeclarationName | undefined;
    function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;
    function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;
    /**
     * Gets the JSDoc parameter tags for the node if present.
     *
     * @remarks Returns any JSDoc param tag whose name matches the provided
     * parameter, whether a param tag on a containing function
     * expression, or a param tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are returned first, so in the previous example, the param
     * tag on the containing function expression would be first.
     *
     * For binding patterns, parameter tags are matched by position.
     */
    function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];
    /** @internal */
    function getJSDocParameterTagsNoCache(param: ParameterDeclaration): readonly JSDocParameterTag[];
    /**
     * Gets the JSDoc type parameter tags for the node if present.
     *
     * @remarks Returns any JSDoc template tag whose names match the provided
     * parameter, whether a template tag on a containing function
     * expression, or a template tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are returned first, so in the previous example, the template
     * tag on the containing function expression would be first.
     */
    function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];
    /** @internal */
    function getJSDocTypeParameterTagsNoCache(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];
    /**
     * Return true if the node has JSDoc parameter tags.
     *
     * @remarks Includes parameter tags that are not directly on the node,
     * for example on a variable declaration whose initializer is a function expression.
     */
    function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;
    /** Gets the JSDoc augments tag for the node if present */
    function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;
    /** Gets the JSDoc implements tags for the node if present */
    function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];
    /** Gets the JSDoc class tag for the node if present */
    function getJSDocClassTag(node: Node): JSDocClassTag | undefined;
    /** Gets the JSDoc public tag for the node if present */
    function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;
    /** @internal */
    function getJSDocPublicTagNoCache(node: Node): JSDocPublicTag | undefined;
    /** Gets the JSDoc private tag for the node if present */
    function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;
    /** @internal */
    function getJSDocPrivateTagNoCache(node: Node): JSDocPrivateTag | undefined;
    /** Gets the JSDoc protected tag for the node if present */
    function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;
    /** @internal */
    function getJSDocProtectedTagNoCache(node: Node): JSDocProtectedTag | undefined;
    /** Gets the JSDoc protected tag for the node if present */
    function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;
    /** @internal */
    function getJSDocReadonlyTagNoCache(node: Node): JSDocReadonlyTag | undefined;
    function getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;
    /** Gets the JSDoc deprecated tag for the node if present */
    function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;
    /** @internal */
    function getJSDocDeprecatedTagNoCache(node: Node): JSDocDeprecatedTag | undefined;
    /** Gets the JSDoc enum tag for the node if present */
    function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;
    /** Gets the JSDoc this tag for the node if present */
    function getJSDocThisTag(node: Node): JSDocThisTag | undefined;
    /** Gets the JSDoc return tag for the node if present */
    function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;
    /** Gets the JSDoc template tag for the node if present */
    function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;
    function getJSDocSatisfiesTag(node: Node): JSDocSatisfiesTag | undefined;
    /** Gets the JSDoc type tag for the node if present and valid */
    function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;
    /**
     * Gets the type node for the node if provided via JSDoc.
     *
     * @remarks The search includes any JSDoc param tag that relates
     * to the provided parameter, for example a type tag on the
     * parameter itself, or a param tag on a containing function
     * expression, or a param tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are examined first, so in the previous example, the type
     * tag directly on the node would be returned.
     */
    function getJSDocType(node: Node): TypeNode | undefined;
    /**
     * Gets the return type node for the node if provided via JSDoc return tag or type tag.
     *
     * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function
     * gets the type from inside the braces, after the fat arrow, etc.
     */
    function getJSDocReturnType(node: Node): TypeNode | undefined;
    /** Get all JSDoc tags related to a node, including those on parent nodes. */
    function getJSDocTags(node: Node): readonly JSDocTag[];
    /** @internal */
    function getJSDocTagsNoCache(node: Node): readonly JSDocTag[];
    /** Gets all JSDoc tags that match a specified predicate */
    function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];
    /** Gets all JSDoc tags of a specified kind */
    function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];
    /** Gets the text of a jsdoc comment, flattening links to their text. */
    function getTextOfJSDocComment(comment?: string | NodeArray<JSDocComment>): string | undefined;
    /**
     * Gets the effective type parameters. If the node was parsed in a
     * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.
     *
     * This does *not* return type parameters from a jsdoc reference to a generic type, eg
     *
     * type Id = <T>(x: T) => T
     * /** @type {Id} /
     * function id(x) { return x }
     */
    function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];
    function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;
    function isMemberName(node: Node): node is MemberName;
    /** @internal */
    function isGetOrSetAccessorDeclaration(node: Node): node is AccessorDeclaration;
    function isPropertyAccessChain(node: Node): node is PropertyAccessChain;
    function isElementAccessChain(node: Node): node is ElementAccessChain;
    function isCallChain(node: Node): node is CallChain;
    function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
    /** @internal */
    function isOptionalChainRoot(node: Node): node is OptionalChainRoot;
    /**
     * Determines whether a node is the expression preceding an optional chain (i.e. `a` in `a?.b`).
     *
     * @internal
     */
    function isExpressionOfOptionalChainRoot(node: Node): node is Expression & {
        parent: OptionalChainRoot;
    };
    /**
     * Determines whether a node is the outermost `OptionalChain` in an ECMAScript `OptionalExpression`:
     *
     * 1. For `a?.b.c`, the outermost chain is `a?.b.c` (`c` is the end of the chain starting at `a?.`)
     * 2. For `a?.b!`, the outermost chain is `a?.b` (`b` is the end of the chain starting at `a?.`)
     * 3. For `(a?.b.c).d`, the outermost chain is `a?.b.c` (`c` is the end of the chain starting at `a?.` since parens end the chain)
     * 4. For `a?.b.c?.d`, both `a?.b.c` and `a?.b.c?.d` are outermost (`c` is the end of the chain starting at `a?.`, and `d` is
     *   the end of the chain starting at `c?.`)
     * 5. For `a?.(b?.c).d`, both `b?.c` and `a?.(b?.c)d` are outermost (`c` is the end of the chain starting at `b`, and `d` is
     *   the end of the chain starting at `a?.`)
     *
     * @internal
     */
    function isOutermostOptionalChain(node: OptionalChain): boolean;
    function isNullishCoalesce(node: Node): boolean;
    function isConstTypeReference(node: Node): boolean;
    function skipPartiallyEmittedExpressions(node: Expression): Expression;
    function skipPartiallyEmittedExpressions(node: Node): Node;
    function isNonNullChain(node: Node): node is NonNullChain;
    function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;
    function isNamedExportBindings(node: Node): node is NamedExportBindings;
    /** @deprecated */
    function isUnparsedTextLike(node: Node): node is UnparsedTextLike;
    /** @deprecated */
    function isUnparsedNode(node: Node): node is UnparsedNode;
    function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;
    /** @internal */
    function isNode(node: Node): boolean;
    /** @internal */
    function isNodeKind(kind: SyntaxKind): boolean;
    /**
     * True if kind is of some token syntax kind.
     * For example, this is true for an IfKeyword but not for an IfStatement.
     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
     */
    function isTokenKind(kind: SyntaxKind): boolean;
    /**
     * True if node is of some token syntax kind.
     * For example, this is true for an IfKeyword but not for an IfStatement.
     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
     */
    function isToken(n: Node): boolean;
    /** @internal */
    function isNodeArray<T extends Node>(array: readonly T[]): array is NodeArray<T>;
    /** @internal */
    function isLiteralKind(kind: SyntaxKind): kind is LiteralToken["kind"];
    function isLiteralExpression(node: Node): node is LiteralExpression;
    /** @internal */
    function isLiteralExpressionOfObject(node: Node): boolean;
    /** @internal */
    function isTemplateLiteralKind(kind: SyntaxKind): kind is TemplateLiteralToken["kind"];
    function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;
    function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;
    function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;
    function isTypeOnlyImportDeclaration(node: Node): node is TypeOnlyImportDeclaration;
    function isTypeOnlyExportDeclaration(node: Node): node is TypeOnlyExportDeclaration;
    function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;
    function isAssertionKey(node: Node): node is AssertionKey;
    function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;
    /** @internal */
    function isGeneratedIdentifier(node: Node): node is GeneratedIdentifier;
    /** @internal */
    function isGeneratedPrivateIdentifier(node: Node): node is GeneratedPrivateIdentifier;
    /** @internal */
    function isPrivateIdentifierClassElementDeclaration(node: Node): node is PrivateClassElementDeclaration;
    /** @internal */
    function isPrivateIdentifierPropertyAccessExpression(node: Node): node is PrivateIdentifierPropertyAccessExpression;
    /** @internal */
    function isModifierKind(token: SyntaxKind): token is Modifier["kind"];
    /** @internal */
    function isParameterPropertyModifier(kind: SyntaxKind): boolean;
    /** @internal */
    function isClassMemberModifier(idToken: SyntaxKind): boolean;
    function isModifier(node: Node): node is Modifier;
    function isEntityName(node: Node): node is EntityName;
    function isPropertyName(node: Node): node is PropertyName;
    function isBindingName(node: Node): node is BindingName;
    function isFunctionLike(node: Node | undefined): node is SignatureDeclaration;
    /** @internal */
    function isFunctionLikeOrClassStaticBlockDeclaration(node: Node | undefined): node is SignatureDeclaration | ClassStaticBlockDeclaration;
    /** @internal */
    function isFunctionLikeDeclaration(node: Node): node is FunctionLikeDeclaration;
    /** @internal */
    function isBooleanLiteral(node: Node): node is BooleanLiteral;
    /** @internal */
    function isFunctionLikeKind(kind: SyntaxKind): boolean;
    /** @internal */
    function isFunctionOrModuleBlock(node: Node): boolean;
    function isClassElement(node: Node): node is ClassElement;
    function isClassLike(node: Node): node is ClassLikeDeclaration;
    function isAccessor(node: Node): node is AccessorDeclaration;
    function isAutoAccessorPropertyDeclaration(node: Node): node is AutoAccessorPropertyDeclaration;
    /** @internal */
    function isMethodOrAccessor(node: Node): node is MethodDeclaration | AccessorDeclaration;
    /** @internal */
    function isNamedClassElement(node: Node): node is MethodDeclaration | AccessorDeclaration | PropertyDeclaration;
    function isModifierLike(node: Node): node is ModifierLike;
    function isTypeElement(node: Node): node is TypeElement;
    function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;
    function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;
    /**
     * Node test that determines whether a node is a valid type node.
     * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*
     * of a TypeNode.
     */
    function isTypeNode(node: Node): node is TypeNode;
    function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;
    /** @internal */
    function isBindingPattern(node: Node | undefined): node is BindingPattern;
    /** @internal */
    function isAssignmentPattern(node: Node): node is AssignmentPattern;
    function isArrayBindingElement(node: Node): node is ArrayBindingElement;
    /**
     * Determines whether the BindingOrAssignmentElement is a BindingElement-like declaration
     *
     * @internal
     */
    function isDeclarationBindingElement(bindingElement: BindingOrAssignmentElement): bindingElement is VariableDeclaration | ParameterDeclaration | BindingElement;
    /** @internal */
    function isBindingOrAssignmentElement(node: Node): node is BindingOrAssignmentElement;
    /**
     * Determines whether a node is a BindingOrAssignmentPattern
     *
     * @internal
     */
    function isBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is BindingOrAssignmentPattern;
    /**
     * Determines whether a node is an ObjectBindingOrAssignmentPattern
     *
     * @internal
     */
    function isObjectBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is ObjectBindingOrAssignmentPattern;
    /** @internal */
    function isObjectBindingOrAssignmentElement(node: Node): node is ObjectBindingOrAssignmentElement;
    /**
     * Determines whether a node is an ArrayBindingOrAssignmentPattern
     *
     * @internal
     */
    function isArrayBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is ArrayBindingOrAssignmentPattern;
    /** @internal */
    function isArrayBindingOrAssignmentElement(node: Node): node is ArrayBindingOrAssignmentElement;
    /** @internal */
    function isPropertyAccessOrQualifiedNameOrImportTypeNode(node: Node): node is PropertyAccessExpression | QualifiedName | ImportTypeNode;
    function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;
    function isCallLikeExpression(node: Node): node is CallLikeExpression;
    function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;
    function isTemplateLiteral(node: Node): node is TemplateLiteral;
    function isLeftHandSideExpression(node: Node): node is LeftHandSideExpression;
    /** @internal */
    function isUnaryExpression(node: Node): node is UnaryExpression;
    /** @internal */
    function isUnaryExpressionWithWrite(expr: Node): expr is PrefixUnaryExpression | PostfixUnaryExpression;
    function isLiteralTypeLiteral(node: Node): node is NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;
    /**
     * Determines whether a node is an expression based only on its kind.
     */
    function isExpression(node: Node): node is Expression;
    function isAssertionExpression(node: Node): node is AssertionExpression;
    /** @internal */
    function isNotEmittedOrPartiallyEmittedNode(node: Node): node is NotEmittedStatement | PartiallyEmittedExpression;
    function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;
    function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;
    /** @internal */
    function isScopeMarker(node: Node): boolean;
    /** @internal */
    function hasScopeMarker(statements: readonly Statement[]): boolean;
    /** @internal */
    function needsScopeMarker(result: Statement): boolean;
    /** @internal */
    function isExternalModuleIndicator(result: Statement): boolean;
    /** @internal */
    function isForInOrOfStatement(node: Node): node is ForInOrOfStatement;
    function isConciseBody(node: Node): node is ConciseBody;
    /** @internal */
    function isFunctionBody(node: Node): node is FunctionBody;
    function isForInitializer(node: Node): node is ForInitializer;
    function isModuleBody(node: Node): node is ModuleBody;
    /** @internal */
    function isNamespaceBody(node: Node): node is NamespaceBody;
    /** @internal */
    function isJSDocNamespaceBody(node: Node): node is JSDocNamespaceBody;
    function isNamedImportBindings(node: Node): node is NamedImportBindings;
    /** @internal */
    function isModuleOrEnumDeclaration(node: Node): node is ModuleDeclaration | EnumDeclaration;
    /** @internal */
    function canHaveSymbol(node: Node): node is Declaration;
    /** @internal */
    function canHaveLocals(node: Node): node is HasLocals;
    /** @internal */
    function isDeclaration(node: Node): node is NamedDeclaration;
    /** @internal */
    function isDeclarationStatement(node: Node): node is DeclarationStatement;
    /**
     * Determines whether the node is a statement that is not also a declaration
     *
     * @internal
     */
    function isStatementButNotDeclaration(node: Node): node is Statement;
    function isStatement(node: Node): node is Statement;
    /**
     * NOTE: This is similar to `isStatement` but does not access parent pointers.
     *
     * @internal
     */
    function isStatementOrBlock(node: Node): node is Statement | Block;
    function isModuleReference(node: Node): node is ModuleReference;
    function isJsxTagNameExpression(node: Node): node is JsxTagNameExpression;
    function isJsxChild(node: Node): node is JsxChild;
    function isJsxAttributeLike(node: Node): node is JsxAttributeLike;
    function isStringLiteralOrJsxExpression(node: Node): node is StringLiteral | JsxExpression;
    function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;
    function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;
    /**
     * True if node is of some JSDoc syntax kind.
     *
     * @internal
     */
    function isJSDocNode(node: Node): boolean;
    /** True if node is of a kind that may contain comment text. */
    function isJSDocCommentContainingNode(node: Node): boolean;
    /** @internal */
    function isJSDocTag(node: Node): node is JSDocTag;
    function isSetAccessor(node: Node): node is SetAccessorDeclaration;
    function isGetAccessor(node: Node): node is GetAccessorDeclaration;
    /**
     * True if has jsdoc nodes attached to it.
     *
     * @internal
     */
    function hasJSDocNodes(node: Node): node is HasJSDoc;
    /**
     * True if has type node attached to it.
     *
     * @internal
     */
    function hasType(node: Node): node is HasType;
    /**
     * True if has initializer node attached to it.
     *
     * @internal
     */
    function hasInitializer(node: Node): node is HasInitializer;
    /** True if has initializer node attached to it. */
    function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;
    function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;
    /** @internal */
    function isTypeReferenceType(node: Node): node is TypeReferenceType;
    /** @internal */
    function guessIndentation(lines: string[]): number | undefined;
    function isStringLiteralLike(node: Node | FileReference): node is StringLiteralLike;
    function isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;
    function hasRestParameter(s: SignatureDeclaration | JSDocSignature): boolean;
    function isRestParameter(node: ParameterDeclaration | JSDocParameterTag): boolean;
    let unchangedTextChangeRange: TextChangeRange;
    type ParameterPropertyDeclaration = ParameterDeclaration & {
        parent: ConstructorDeclaration;
        name: Identifier;
    };
    /** @internal */
    const supportedLocaleDirectories: string[];
    /** @internal */
    function getDeclarationOfKind<T extends Declaration>(symbol: Symbol, kind: T["kind"]): T | undefined;
    /** @internal */
    function getDeclarationsOfKind<T extends Declaration>(symbol: Symbol, kind: T["kind"]): T[];
    /** @internal */
    function createSymbolTable(symbols?: readonly Symbol[]): SymbolTable;
    /** @internal */
    function isTransientSymbol(symbol: Symbol): symbol is TransientSymbol;
    /** @internal */
    function changesAffectModuleResolution(oldOptions: CompilerOptions, newOptions: CompilerOptions): boolean;
    /** @internal */
    function optionsHaveModuleResolutionChanges(oldOptions: CompilerOptions, newOptions: CompilerOptions): boolean;
    /** @internal */
    function changesAffectingProgramStructure(oldOptions: CompilerOptions, newOptions: CompilerOptions): boolean;
    /** @internal */
    function optionsHaveChanges(oldOptions: CompilerOptions, newOptions: CompilerOptions, optionDeclarations: readonly CommandLineOption[]): boolean;
    /** @internal */
    function forEachAncestor<T>(node: Node, callback: (n: Node) => T | undefined | "quit"): T | undefined;
    /**
     * Calls `callback` for each entry in the map, returning the first truthy result.
     * Use `map.forEach` instead for normal iteration.
     *
     * @internal
     */
    function forEachEntry<K, V, U>(map: ReadonlyMap<K, V>, callback: (value: V, key: K) => U | undefined): U | undefined;
    /**
     * `forEachEntry` for just keys.
     *
     * @internal
     */
    function forEachKey<K, T>(map: ReadonlyCollection<K>, callback: (key: K) => T | undefined): T | undefined;
    /**
     * Copy entries from `source` to `target`.
     *
     * @internal
     */
    function copyEntries<K, V>(source: ReadonlyMap<K, V>, target: Map<K, V>): void;
    /** @internal */
    function usingSingleLineStringWriter(action: (writer: EmitTextWriter) => void): string;
    /** @internal */
    function getFullWidth(node: Node): number;
    /** @internal */
    function getResolvedModule(sourceFile: SourceFile | undefined, moduleNameText: string, mode: ResolutionMode): ResolvedModuleFull | undefined;
    /** @internal */
    function setResolvedModule(sourceFile: SourceFile, moduleNameText: string, resolvedModule: ResolvedModuleWithFailedLookupLocations, mode: ResolutionMode): void;
    /** @internal */
    function setResolvedTypeReferenceDirective(sourceFile: SourceFile, typeReferenceDirectiveName: string, resolvedTypeReferenceDirective: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, mode: ResolutionMode): void;
    /** @internal */
    function getResolvedTypeReferenceDirective(sourceFile: SourceFile | undefined, typeReferenceDirectiveName: string, mode: ResolutionMode): ResolvedTypeReferenceDirective | undefined;
    /** @internal */
    function projectReferenceIsEqualTo(oldRef: ProjectReference, newRef: ProjectReference): boolean;
    /** @internal */
    function moduleResolutionIsEqualTo(oldResolution: ResolvedModuleWithFailedLookupLocations, newResolution: ResolvedModuleWithFailedLookupLocations): boolean;
    /** @internal */
    function packageIdToPackageName({ name, subModuleName }: PackageId): string;
    /** @internal */
    function packageIdToString(packageId: PackageId): string;
    /** @internal */
    function typeDirectiveIsEqualTo(oldResolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, newResolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations): boolean;
    /** @internal */
    function hasChangesInResolutions<K, V>(names: readonly K[], newSourceFile: SourceFile, newResolutions: readonly V[], oldResolutions: ModeAwareCache<V> | undefined, comparer: (oldResolution: V, newResolution: V) => boolean, nameAndModeGetter: ResolutionNameAndModeGetter<K, SourceFile>): boolean;
    /** @internal */
    function containsParseError(node: Node): boolean;
    /** @internal */
    function getSourceFileOfNode(node: Node): SourceFile;
    /** @internal */
    function getSourceFileOfNode(node: Node | undefined): SourceFile | undefined;
    /** @internal */
    function getSourceFileOfModule(module: Symbol): SourceFile | undefined;
    /** @internal */
    function isPlainJsFile(file: SourceFile | undefined, checkJs: boolean | undefined): boolean;
    /** @internal */
    function isStatementWithLocals(node: Node): boolean;
    /** @internal */
    function getStartPositionOfLine(line: number, sourceFile: SourceFileLike): number;
    /** @internal */
    function nodePosToString(node: Node): string;
    /** @internal */
    function getEndLinePosition(line: number, sourceFile: SourceFileLike): number;
    /**
     * Returns a value indicating whether a name is unique globally or within the current file.
     * Note: This does not consider whether a name appears as a free identifier or not, so at the expression `x.y` this includes both `x` and `y`.
     *
     * @internal
     */
    function isFileLevelUniqueName(sourceFile: SourceFile, name: string, hasGlobalName?: PrintHandlers["hasGlobalName"]): boolean;
    /** @internal */
    function nodeIsMissing(node: Node | undefined): boolean;
    /** @internal */
    function nodeIsPresent(node: Node | undefined): boolean;
    /**
     * Tests whether `child` is a grammar error on `parent`.
     * @internal
     */
    function isGrammarError(parent: Node, child: Node | NodeArray<Node>): boolean;
    /**
     * Prepends statements to an array while taking care of prologue directives.
     *
     * @internal
     */
    function insertStatementsAfterStandardPrologue<T extends Statement>(to: T[], from: readonly T[] | undefined): T[];
    /** @internal */
    function insertStatementsAfterCustomPrologue<T extends Statement>(to: T[], from: readonly T[] | undefined): T[];
    /**
     * Prepends statements to an array while taking care of prologue directives.
     *
     * @internal
     */
    function insertStatementAfterStandardPrologue<T extends Statement>(to: T[], statement: T | undefined): T[];
    /** @internal */
    function insertStatementAfterCustomPrologue<T extends Statement>(to: T[], statement: T | undefined): T[];
    /**
     * Determine if the given comment is a triple-slash
     *
     * @return true if the comment is a triple-slash comment else false
     *
     * @internal
     */
    function isRecognizedTripleSlashComment(text: string, commentPos: number, commentEnd: number): boolean;
    /** @internal */
    function isPinnedComment(text: string, start: number): boolean;
    /** @internal */
    function createCommentDirectivesMap(sourceFile: SourceFile, commentDirectives: CommentDirective[]): CommentDirectivesMap;
    /** @internal */
    function getTokenPosOfNode(node: Node, sourceFile?: SourceFileLike, includeJsDoc?: boolean): number;
    /** @internal */
    function getNonDecoratorTokenPosOfNode(node: Node, sourceFile?: SourceFileLike): number;
    /** @internal */
    function getSourceTextOfNodeFromSourceFile(sourceFile: SourceFile, node: Node, includeTrivia?: boolean): string;
    /** @internal */
    function isExportNamespaceAsDefaultDeclaration(node: Node): boolean;
    /** @internal */
    function getTextOfNodeFromSourceText(sourceText: string, node: Node, includeTrivia?: boolean): string;
    /** @internal */
    function getTextOfNode(node: Node, includeTrivia?: boolean): string;
    /**
     * Note: it is expected that the `nodeArray` and the `node` are within the same file.
     * For example, searching for a `SourceFile` in a `SourceFile[]` wouldn't work.
     *
     * @internal
     */
    function indexOfNode(nodeArray: readonly Node[], node: Node): number;
    /**
     * Gets flags that control emit behavior of a node.
     *
     * @internal
     */
    function getEmitFlags(node: Node): EmitFlags;
    /**
     * Gets flags that control emit behavior of a node.
     *
     * @internal
     */
    function getInternalEmitFlags(node: Node): InternalEmitFlags;
    /** @internal */
    function getScriptTargetFeatures(): ScriptTargetFeatures;
    /** @internal */
    function getLiteralText(node: LiteralLikeNode, sourceFile: SourceFile | undefined, flags: GetLiteralTextFlags): string;
    /** @internal */
    function getTextOfConstantValue(value: string | number): string;
    /** @internal */
    function makeIdentifierFromModuleName(moduleName: string): string;
    /** @internal */
    function isBlockOrCatchScoped(declaration: Declaration): boolean;
    /** @internal */
    function isCatchClauseVariableDeclarationOrBindingElement(declaration: Declaration): boolean;
    /** @internal */
    function isAmbientModule(node: Node): node is AmbientModuleDeclaration;
    /** @internal */
    function isModuleWithStringLiteralName(node: Node): node is ModuleDeclaration;
    /** @internal */
    function isNonGlobalAmbientModule(node: Node): node is ModuleDeclaration & {
        name: StringLiteral;
    };
    /**
     * An effective module (namespace) declaration is either
     * 1. An actual declaration: namespace X { ... }
     * 2. A Javascript declaration, which is:
     *    An identifier in a nested property access expression: Y in `X.Y.Z = { ... }`
     *
     * @internal
     */
    function isEffectiveModuleDeclaration(node: Node): boolean;
    /**
     * Given a symbol for a module, checks that it is a shorthand ambient module.
     *
     * @internal
     */
    function isShorthandAmbientModuleSymbol(moduleSymbol: Symbol): boolean;
    /** @internal */
    function isBlockScopedContainerTopLevel(node: Node): boolean;
    /** @internal */
    function isGlobalScopeAugmentation(module: ModuleDeclaration): boolean;
    /** @internal */
    function isExternalModuleAugmentation(node: Node): node is AmbientModuleDeclaration;
    /** @internal */
    function isModuleAugmentationExternal(node: AmbientModuleDeclaration): boolean;
    /** @internal */
    function getNonAugmentationDeclaration(symbol: Symbol): Declaration | undefined;
    /** @internal */
    function isEffectiveExternalModule(node: SourceFile, compilerOptions: CompilerOptions): boolean;
    /**
     * Returns whether the source file will be treated as if it were in strict mode at runtime.
     *
     * @internal
     */
    function isEffectiveStrictModeSourceFile(node: SourceFile, compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function isAmbientPropertyDeclaration(node: PropertyDeclaration): boolean;
    /** @internal */
    function isBlockScope(node: Node, parentNode: Node | undefined): boolean;
    /** @internal */
    function isDeclarationWithTypeParameters(node: Node): node is DeclarationWithTypeParameters;
    /** @internal */
    function isDeclarationWithTypeParameterChildren(node: Node): node is DeclarationWithTypeParameterChildren;
    /** @internal */
    function isAnyImportSyntax(node: Node): node is AnyImportSyntax;
    /** @internal */
    function isAnyImportOrBareOrAccessedRequire(node: Node): node is AnyImportOrBareOrAccessedRequire;
    /** @internal */
    function isLateVisibilityPaintedStatement(node: Node): node is LateVisibilityPaintedStatement;
    /** @internal */
    function hasPossibleExternalModuleReference(node: Node): node is AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall;
    /** @internal */
    function isAnyImportOrReExport(node: Node): node is AnyImportOrReExport;
    /** @internal */
    function getEnclosingBlockScopeContainer(node: Node): Node;
    /** @internal */
    function forEachEnclosingBlockScopeContainer(node: Node, cb: (container: Node) => void): void;
    /** @internal */
    function declarationNameToString(name: DeclarationName | QualifiedName | undefined): string;
    /** @internal */
    function getNameFromIndexInfo(info: IndexInfo): string | undefined;
    /** @internal */
    function isComputedNonLiteralName(name: PropertyName): boolean;
    /** @internal */
    function tryGetTextOfPropertyName(name: PropertyName | NoSubstitutionTemplateLiteral): __String | undefined;
    /** @internal */
    function getTextOfPropertyName(name: PropertyName | NoSubstitutionTemplateLiteral): __String;
    /** @internal */
    function entityNameToString(name: EntityNameOrEntityNameExpression | JSDocMemberName | JsxTagNameExpression | PrivateIdentifier): string;
    /** @internal */
    function createDiagnosticForNode(node: Node, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number): DiagnosticWithLocation;
    /** @internal */
    function createDiagnosticForNodeArray(sourceFile: SourceFile, nodes: NodeArray<Node>, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number): DiagnosticWithLocation;
    /** @internal */
    function createDiagnosticForNodeInSourceFile(sourceFile: SourceFile, node: Node, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number): DiagnosticWithLocation;
    /** @internal */
    function createDiagnosticForNodeFromMessageChain(sourceFile: SourceFile, node: Node, messageChain: DiagnosticMessageChain, relatedInformation?: DiagnosticRelatedInformation[]): DiagnosticWithLocation;
    /** @internal */
    function createDiagnosticForNodeArrayFromMessageChain(sourceFile: SourceFile, nodes: NodeArray<Node>, messageChain: DiagnosticMessageChain, relatedInformation?: DiagnosticRelatedInformation[]): DiagnosticWithLocation;
    /** @internal */
    function createFileDiagnosticFromMessageChain(file: SourceFile, start: number, length: number, messageChain: DiagnosticMessageChain, relatedInformation?: DiagnosticRelatedInformation[]): DiagnosticWithLocation;
    /** @internal */
    function createDiagnosticForFileFromMessageChain(sourceFile: SourceFile, messageChain: DiagnosticMessageChain, relatedInformation?: DiagnosticRelatedInformation[]): DiagnosticWithLocation;
    /** @internal */
    function createDiagnosticMessageChainFromDiagnostic(diagnostic: DiagnosticRelatedInformation): DiagnosticMessageChain;
    /** @internal */
    function createDiagnosticForRange(sourceFile: SourceFile, range: TextRange, message: DiagnosticMessage): DiagnosticWithLocation;
    /** @internal */
    function getSpanOfTokenAtPosition(sourceFile: SourceFile, pos: number): TextSpan;
    /** @internal */
    function scanTokenAtPosition(sourceFile: SourceFile, pos: number): SyntaxKind;
    /** @internal */
    function getErrorSpanForNode(sourceFile: SourceFile, node: Node): TextSpan;
    /** @internal */
    function isExternalOrCommonJsModule(file: SourceFile): boolean;
    /** @internal */
    function isJsonSourceFile(file: SourceFile): file is JsonSourceFile;
    /** @internal */
    function isEnumConst(node: EnumDeclaration): boolean;
    /** @internal */
    function isDeclarationReadonly(declaration: Declaration): boolean;
    /** @internal */
    function isVarConst(node: VariableDeclaration | VariableDeclarationList): boolean;
    /** @internal */
    function isLet(node: Node): boolean;
    /** @internal */
    function isSuperCall(n: Node): n is SuperCall;
    /** @internal */
    function isImportCall(n: Node): n is ImportCall;
    /** @internal */
    function isImportMeta(n: Node): n is ImportMetaProperty;
    /** @internal */
    function isLiteralImportTypeNode(n: Node): n is LiteralImportTypeNode;
    /** @internal */
    function isPrologueDirective(node: Node): node is PrologueDirective;
    /** @internal */
    function isCustomPrologue(node: Statement): boolean;
    /** @internal */
    function isHoistedFunction(node: Statement): boolean;
    /** @internal */
    function isHoistedVariableStatement(node: Statement): boolean;
    /** @internal */
    function getLeadingCommentRangesOfNode(node: Node, sourceFileOfNode: SourceFile): CommentRange[] | undefined;
    /** @internal */
    function getJSDocCommentRanges(node: Node, text: string): CommentRange[] | undefined;
    /** @internal */
    function isPartOfTypeNode(node: Node): boolean;
    /** @internal */
    function isChildOfNodeWithKind(node: Node, kind: SyntaxKind): boolean;
    /** @internal */
    function forEachReturnStatement<T>(body: Block | Statement, visitor: (stmt: ReturnStatement) => T): T | undefined;
    /** @internal */
    function forEachYieldExpression(body: Block, visitor: (expr: YieldExpression) => void): void;
    /**
     * Gets the most likely element type for a TypeNode. This is not an exhaustive test
     * as it assumes a rest argument can only be an array type (either T[], or Array<T>).
     *
     * @param node The type node.
     *
     * @internal
     */
    function getRestParameterElementType(node: TypeNode | undefined): TypeNode | undefined;
    /** @internal */
    function getMembersOfDeclaration(node: Declaration): NodeArray<ClassElement | TypeElement | ObjectLiteralElement> | undefined;
    /** @internal */
    function isVariableLike(node: Node): node is VariableLikeDeclaration;
    /** @internal */
    function isVariableLikeOrAccessor(node: Node): node is AccessorDeclaration | VariableLikeDeclaration;
    /** @internal */
    function isVariableDeclarationInVariableStatement(node: VariableDeclaration): boolean;
    /** @internal */
    function isCommonJsExportedExpression(node: Node): boolean;
    /** @internal */
    function isCommonJsExportPropertyAssignment(node: Node): boolean;
    /** @internal */
    function isValidESSymbolDeclaration(node: Node): boolean;
    /** @internal */
    function introducesArgumentsExoticObject(node: Node): boolean;
    /** @internal */
    function unwrapInnermostStatementOfLabel(node: LabeledStatement, beforeUnwrapLabelCallback?: (node: LabeledStatement) => void): Statement;
    /** @internal */
    function isFunctionBlock(node: Node): boolean;
    /** @internal */
    function isObjectLiteralMethod(node: Node): node is MethodDeclaration;
    /** @internal */
    function isObjectLiteralOrClassExpressionMethodOrAccessor(node: Node): node is MethodDeclaration | AccessorDeclaration;
    /** @internal */
    function isIdentifierTypePredicate(predicate: TypePredicate): predicate is IdentifierTypePredicate;
    /** @internal */
    function isThisTypePredicate(predicate: TypePredicate): predicate is ThisTypePredicate;
    /** @internal */
    function getPropertyAssignment(objectLiteral: ObjectLiteralExpression, key: string, key2?: string): readonly PropertyAssignment[];
    /** @internal */
    function getPropertyArrayElementValue(objectLiteral: ObjectLiteralExpression, propKey: string, elementValue: string): StringLiteral | undefined;
    /** @internal */
    function getTsConfigObjectLiteralExpression(tsConfigSourceFile: TsConfigSourceFile | undefined): ObjectLiteralExpression | undefined;
    /** @internal */
    function getTsConfigPropArrayElementValue(tsConfigSourceFile: TsConfigSourceFile | undefined, propKey: string, elementValue: string): StringLiteral | undefined;
    /** @internal */
    function getTsConfigPropArray(tsConfigSourceFile: TsConfigSourceFile | undefined, propKey: string): readonly PropertyAssignment[];
    /** @internal */
    function getContainingFunction(node: Node): SignatureDeclaration | undefined;
    /** @internal */
    function getContainingFunctionDeclaration(node: Node): FunctionLikeDeclaration | undefined;
    /** @internal */
    function getContainingClass(node: Node): ClassLikeDeclaration | undefined;
    /** @internal */
    function getContainingClassStaticBlock(node: Node): Node | undefined;
    /** @internal */
    function getContainingFunctionOrClassStaticBlock(node: Node): SignatureDeclaration | ClassStaticBlockDeclaration | undefined;
    /** @internal */
    function getThisContainer(node: Node, includeArrowFunctions: false, includeClassComputedPropertyName: false): ThisContainer;
    /** @internal */
    function getThisContainer(node: Node, includeArrowFunctions: false, includeClassComputedPropertyName: boolean): ThisContainer | ComputedPropertyName;
    /** @internal */
    function getThisContainer(node: Node, includeArrowFunctions: boolean, includeClassComputedPropertyName: false): ThisContainer | ArrowFunction;
    /** @internal */
    function getThisContainer(node: Node, includeArrowFunctions: boolean, includeClassComputedPropertyName: boolean): ThisContainer | ArrowFunction | ComputedPropertyName;
    /**
     * @returns Whether the node creates a new 'this' scope for its children.
     *
     * @internal
     */
    function isThisContainerOrFunctionBlock(node: Node): boolean;
    /** @internal */
    function isInTopLevelContext(node: Node): boolean;
    /** @internal */
    function getNewTargetContainer(node: Node): FunctionExpression | FunctionDeclaration | ConstructorDeclaration | undefined;
    /**
     * Given an super call/property node, returns the closest node where
     * - a super call/property access is legal in the node and not legal in the parent node the node.
     *   i.e. super call is legal in constructor but not legal in the class body.
     * - the container is an arrow function (so caller might need to call getSuperContainer again in case it needs to climb higher)
     * - a super call/property is definitely illegal in the container (but might be legal in some subnode)
     *   i.e. super property access is illegal in function declaration but can be legal in the statement list
     *
     * @internal
     */
    function getSuperContainer(node: Node, stopOnFunctions: false): SuperContainer | undefined;
    /** @internal */
    function getSuperContainer(node: Node, stopOnFunctions: boolean): SuperContainerOrFunctions | undefined;
    /** @internal */
    function getImmediatelyInvokedFunctionExpression(func: Node): CallExpression | undefined;
    /** @internal */
    function isSuperOrSuperProperty(node: Node): node is SuperExpression | SuperProperty;
    /**
     * Determines whether a node is a property or element access expression for `super`.
     *
     * @internal
     */
    function isSuperProperty(node: Node): node is SuperProperty;
    /**
     * Determines whether a node is a property or element access expression for `this`.
     *
     * @internal
     */
    function isThisProperty(node: Node): boolean;
    /** @internal */
    function isThisInitializedDeclaration(node: Node | undefined): boolean;
    /** @internal */
    function isThisInitializedObjectBindingExpression(node: Node | undefined): boolean;
    /** @internal */
    function getEntityNameFromTypeNode(node: TypeNode): EntityNameOrEntityNameExpression | undefined;
    /** @internal */
    function getInvokedExpression(node: CallLikeExpression): Expression;
    /** @internal */
    function nodeCanBeDecorated(useLegacyDecorators: boolean, node: ClassDeclaration): true;
    /** @internal */
    function nodeCanBeDecorated(useLegacyDecorators: boolean, node: ClassExpression): boolean;
    /** @internal */
    function nodeCanBeDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: Node): boolean;
    /** @internal */
    function nodeCanBeDecorated(useLegacyDecorators: boolean, node: Node, parent: Node, grandparent: Node): boolean;
    /** @internal */
    function nodeIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean;
    /** @internal */
    function nodeIsDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: Node): boolean;
    /** @internal */
    function nodeIsDecorated(useLegacyDecorators: boolean, node: Node, parent: Node, grandparent: Node): boolean;
    /** @internal */
    function nodeOrChildIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean;
    /** @internal */
    function nodeOrChildIsDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: Node): boolean;
    /** @internal */
    function nodeOrChildIsDecorated(useLegacyDecorators: boolean, node: Node, parent: Node, grandparent: Node): boolean;
    /** @internal */
    function childIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean;
    /** @internal */
    function childIsDecorated(useLegacyDecorators: boolean, node: Node, parent: Node): boolean;
    /** @internal */
    function classOrConstructorParameterIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean;
    /** @internal */
    function classElementOrClassElementParameterIsDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: ClassDeclaration | ClassExpression): boolean;
    /** @internal */
    function isEmptyStringLiteral(node: StringLiteral): boolean;
    /** @internal */
    function isJSXTagName(node: Node): boolean;
    /** @internal */
    function isExpressionNode(node: Node): boolean;
    /** @internal */
    function isInExpressionContext(node: Node): boolean;
    /** @internal */
    function isPartOfTypeQuery(node: Node): boolean;
    /** @internal */
    function isNamespaceReexportDeclaration(node: Node): boolean;
    /** @internal */
    function isExternalModuleImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration & {
        moduleReference: ExternalModuleReference;
    };
    /** @internal */
    function getExternalModuleImportEqualsDeclarationExpression(node: Node): Expression;
    /** @internal */
    function getExternalModuleRequireArgument(node: Node): false | StringLiteral;
    /** @internal */
    function isInternalModuleImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
    /** @internal */
    function isSourceFileJS(file: SourceFile): boolean;
    /** @internal */
    function isSourceFileNotJS(file: SourceFile): boolean;
    /** @internal */
    function isInJSFile(node: Node | undefined): boolean;
    /** @internal */
    function isInJsonFile(node: Node | undefined): boolean;
    /** @internal */
    function isSourceFileNotJson(file: SourceFile): boolean;
    /** @internal */
    function isInJSDoc(node: Node | undefined): boolean;
    /** @internal */
    function isJSDocIndexSignature(node: TypeReferenceNode | ExpressionWithTypeArguments): boolean | undefined;
    /**
     * Returns true if the node is a CallExpression to the identifier 'require' with
     * exactly one argument (of the form 'require("name")').
     * This function does not test if the node is in a JavaScript file or not.
     *
     * @internal
     */
    function isRequireCall(callExpression: Node, requireStringLiteralLikeArgument: true): callExpression is RequireOrImportCall & {
        expression: Identifier;
        arguments: [
            StringLiteralLike
        ];
    };
    /** @internal */
    function isRequireCall(callExpression: Node, requireStringLiteralLikeArgument: boolean): callExpression is CallExpression;
    /**
     * Returns true if the node is a VariableDeclaration initialized to a require call (see `isRequireCall`).
     * This function does not test if the node is in a JavaScript file or not.
     *
     * @internal
     */
    function isVariableDeclarationInitializedToRequire(node: Node): node is VariableDeclarationInitializedTo<RequireOrImportCall>;
    /**
     * Like {@link isVariableDeclarationInitializedToRequire} but allows things like `require("...").foo.bar` or `require("...")["baz"]`.
     *
     * @internal
     */
    function isVariableDeclarationInitializedToBareOrAccessedRequire(node: Node): node is VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression>;
    /** @internal */
    function isBindingElementOfBareOrAccessedRequire(node: Node): node is BindingElementOfBareOrAccessedRequire;
    /** @internal */
    function isRequireVariableStatement(node: Node): node is RequireVariableStatement;
    /** @internal */
    function isSingleOrDoubleQuote(charCode: number): boolean;
    /** @internal */
    function isStringDoubleQuoted(str: StringLiteralLike, sourceFile: SourceFile): boolean;
    /** @internal */
    function isAssignmentDeclaration(decl: Declaration): boolean;
    /**
     * Get the initializer, taking into account defaulted Javascript initializers
     *
     * @internal
     */
    function getEffectiveInitializer(node: HasExpressionInitializer): Expression | undefined;
    /**
     * Get the declaration initializer when it is container-like (See getExpandoInitializer).
     *
     * @internal
     */
    function getDeclaredExpandoInitializer(node: HasExpressionInitializer): Expression | undefined;
    /**
     * Get the assignment 'initializer' -- the righthand side-- when the initializer is container-like (See getExpandoInitializer).
     * We treat the right hand side of assignments with container-like initializers as declarations.
     *
     * @internal
     */
    function getAssignedExpandoInitializer(node: Node | undefined): Expression | undefined;
    /**
     * Recognized expando initializers are:
     * 1. (function() {})() -- IIFEs
     * 2. function() { } -- Function expressions
     * 3. class { } -- Class expressions
     * 4. {} -- Empty object literals
     * 5. { ... } -- Non-empty object literals, when used to initialize a prototype, like `C.prototype = { m() { } }`
     *
     * This function returns the provided initializer, or undefined if it is not valid.
     *
     * @internal
     */
    function getExpandoInitializer(initializer: Node, isPrototypeAssignment: boolean): Expression | undefined;
    /** @internal */
    function isDefaultedExpandoInitializer(node: BinaryExpression): boolean | undefined;
    /**
     * Given an expando initializer, return its declaration name, or the left-hand side of the assignment if it's part of an assignment declaration.
     *
     * @internal
     */
    function getNameOfExpando(node: Declaration): DeclarationName | undefined;
    /**
     * Is the 'declared' name the same as the one in the initializer?
     * @return true for identical entity names, as well as ones where the initializer is prefixed with
     * 'window', 'self' or 'global'. For example:
     *
     * var my = my || {}
     * var min = window.min || {}
     * my.app = self.my.app || class { }
     *
     * @internal
     */
    function isSameEntityName(name: Expression, initializer: Expression): boolean;
    /** @internal */
    function getRightMostAssignedExpression(node: Expression): Expression;
    /** @internal */
    function isExportsIdentifier(node: Node): boolean;
    /** @internal */
    function isModuleIdentifier(node: Node): boolean;
    /** @internal */
    function isModuleExportsAccessExpression(node: Node): node is LiteralLikeElementAccessExpression & {
        expression: Identifier;
    };
    /** @internal */
    function getAssignmentDeclarationKind(expr: BinaryExpression | CallExpression): AssignmentDeclarationKind;
    /** @internal */
    function isBindableObjectDefinePropertyCall(expr: CallExpression): expr is BindableObjectDefinePropertyCall;
    /**
     * x.y OR x[0]
     *
     * @internal
     */
    function isLiteralLikeAccess(node: Node): node is LiteralLikeElementAccessExpression | PropertyAccessExpression;
    /**
     * x[0] OR x['a'] OR x[Symbol.y]
     *
     * @internal
     */
    function isLiteralLikeElementAccess(node: Node): node is LiteralLikeElementAccessExpression;
    /**
     * Any series of property and element accesses.
     *
     * @internal
     */
    function isBindableStaticAccessExpression(node: Node, excludeThisKeyword?: boolean): node is BindableStaticAccessExpression;
    /**
     * Any series of property and element accesses, ending in a literal element access
     *
     * @internal
     */
    function isBindableStaticElementAccessExpression(node: Node, excludeThisKeyword?: boolean): node is BindableStaticElementAccessExpression;
    /** @internal */
    function isBindableStaticNameExpression(node: Node, excludeThisKeyword?: boolean): node is BindableStaticNameExpression;
    /** @internal */
    function getNameOrArgument(expr: PropertyAccessExpression | LiteralLikeElementAccessExpression): MemberName | (Expression & (StringLiteralLike | NumericLiteral));
    /**
     * Does not handle signed numeric names like `a[+0]` - handling those would require handling prefix unary expressions
     * throughout late binding handling as well, which is awkward (but ultimately probably doable if there is demand)
     *
     * @internal
     */
    function getElementOrPropertyAccessArgumentExpressionOrName(node: AccessExpression): Identifier | PrivateIdentifier | StringLiteralLike | NumericLiteral | ElementAccessExpression | undefined;
    /** @internal */
    function getElementOrPropertyAccessName(node: LiteralLikeElementAccessExpression | PropertyAccessExpression): __String;
    /** @internal */
    function getElementOrPropertyAccessName(node: AccessExpression): __String | undefined;
    /** @internal */
    function getAssignmentDeclarationPropertyAccessKind(lhs: AccessExpression): AssignmentDeclarationKind;
    /** @internal */
    function getInitializerOfBinaryExpression(expr: BinaryExpression): Expression;
    /** @internal */
    function isPrototypePropertyAssignment(node: Node): node is PrototypePropertyAssignment;
    /** @internal */
    function isSpecialPropertyDeclaration(expr: PropertyAccessExpression | ElementAccessExpression): expr is PropertyAccessExpression | LiteralLikeElementAccessExpression;
    /** @internal */
    function setValueDeclaration(symbol: Symbol, node: Declaration): void;
    /** @internal */
    function isFunctionSymbol(symbol: Symbol | undefined): boolean | undefined;
    /** @internal */
    function tryGetModuleSpecifierFromDeclaration(node: AnyImportOrBareOrAccessedRequire | AliasDeclarationNode): StringLiteralLike | undefined;
    /** @internal */
    function importFromModuleSpecifier(node: StringLiteralLike): AnyValidImportOrReExport;
    /** @internal */
    function tryGetImportFromModuleSpecifier(node: StringLiteralLike): AnyValidImportOrReExport | undefined;
    /** @internal */
    function getExternalModuleName(node: AnyImportOrReExport | ImportTypeNode | ImportCall | ModuleDeclaration): Expression | undefined;
    /** @internal */
    function getNamespaceDeclarationNode(node: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration): ImportEqualsDeclaration | NamespaceImport | NamespaceExport | undefined;
    /** @internal */
    function isDefaultImport(node: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration): boolean;
    /** @internal */
    function forEachImportClauseDeclaration<T>(node: ImportClause, action: (declaration: ImportClause | NamespaceImport | ImportSpecifier) => T | undefined): T | undefined;
    /** @internal */
    function hasQuestionToken(node: Node): boolean;
    /** @internal */
    function isJSDocConstructSignature(node: Node): boolean;
    /** @internal */
    function isJSDocTypeAlias(node: Node): node is JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag;
    /** @internal */
    function isTypeAlias(node: Node): node is JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag | TypeAliasDeclaration;
    /** @internal */
    function getSingleInitializerOfVariableStatementOrPropertyDeclaration(node: Node): Expression | undefined;
    /** @internal */
    function getSingleVariableOfVariableStatement(node: Node): VariableDeclaration | undefined;
    /** @internal */
    function canHaveFlowNode(node: Node): node is HasFlowNode;
    /** @internal */
    function canHaveJSDoc(node: Node): node is HasJSDoc;
    /** @internal */
    function getJSDocCommentsAndTags(hostNode: Node, noCache?: boolean): readonly (JSDoc | JSDocTag)[];
    /** @internal */
    function getNextJSDocCommentLocation(node: Node): Node | undefined;
    /**
     * Does the opposite of `getJSDocParameterTags`: given a JSDoc parameter, finds the parameter corresponding to it.
     *
     * @internal
     */
    function getParameterSymbolFromJSDoc(node: JSDocParameterTag): Symbol | undefined;
    /** @internal */
    function getEffectiveContainerForJSDocTemplateTag(node: JSDocTemplateTag): SignatureDeclaration | JSDocCallbackTag | JSDocEnumTag | JSDocTypedefTag | undefined;
    /** @internal */
    function getHostSignatureFromJSDoc(node: Node): SignatureDeclaration | undefined;
    /** @internal */
    function getEffectiveJSDocHost(node: Node): Node | undefined;
    /**
     * Use getEffectiveJSDocHost if you additionally need to look for jsdoc on parent nodes, like assignments.
     *
     * @internal
     */
    function getJSDocHost(node: Node): HasJSDoc | undefined;
    /** @internal */
    function getJSDocRoot(node: Node): JSDoc | undefined;
    /** @internal */
    function getTypeParameterFromJsDoc(node: TypeParameterDeclaration & {
        parent: JSDocTemplateTag;
    }): TypeParameterDeclaration | undefined;
    /** @internal */
    function hasTypeArguments(node: Node): node is HasTypeArguments;
    /** @internal */
    function getAssignmentTargetKind(node: Node): AssignmentKind;
    /** @internal */
    function isAssignmentTarget(node: Node): boolean;
    /**
     * Indicates whether a node could contain a `var` VariableDeclarationList that contributes to
     * the same `var` declaration scope as the node's parent.
     *
     * @internal
     */
    function isNodeWithPossibleHoistedDeclaration(node: Node): node is NodeWithPossibleHoistedDeclaration;
    /** @internal */
    function isValueSignatureDeclaration(node: Node): node is ValueSignatureDeclaration;
    /** @internal */
    function walkUpParenthesizedTypes(node: Node): Node;
    /** @internal */
    function walkUpParenthesizedExpressions(node: Node): Node;
    /**
     * Walks up parenthesized types.
     * It returns both the outermost parenthesized type and its parent.
     * If given node is not a parenthesiezd type, undefined is return as the former.
     *
     * @internal
     */
    function walkUpParenthesizedTypesAndGetParentAndChild(node: Node): [
        ParenthesizedTypeNode | undefined,
        Node
    ];
    /** @internal */
    function skipTypeParentheses(node: TypeNode): TypeNode;
    /** @internal */
    function skipParentheses(node: Expression, excludeJSDocTypeAssertions?: boolean): Expression;
    /** @internal */
    function skipParentheses(node: Node, excludeJSDocTypeAssertions?: boolean): Node;
    /** @internal */
    function isDeleteTarget(node: Node): boolean;
    /** @internal */
    function isNodeDescendantOf(node: Node, ancestor: Node | undefined): boolean;
    /** @internal */
    function isDeclarationName(name: Node): boolean;
    /** @internal */
    function getDeclarationFromName(name: Node): Declaration | undefined;
    /** @internal */
    function isLiteralComputedPropertyDeclarationName(node: Node): boolean;
    /** @internal */
    function isIdentifierName(node: Identifier): boolean;
    /** @internal */
    function isAliasSymbolDeclaration(node: Node): boolean;
    /** @internal */
    function getAliasDeclarationFromName(node: EntityName): Declaration | undefined;
    /** @internal */
    function isAliasableExpression(e: Expression): boolean;
    /** @internal */
    function exportAssignmentIsAlias(node: ExportAssignment | BinaryExpression): boolean;
    /** @internal */
    function getExportAssignmentExpression(node: ExportAssignment | BinaryExpression): Expression;
    /** @internal */
    function getPropertyAssignmentAliasLikeExpression(node: PropertyAssignment | ShorthandPropertyAssignment | PropertyAccessExpression): Expression;
    /** @internal */
    function getEffectiveBaseTypeNode(node: ClassLikeDeclaration | InterfaceDeclaration): ExpressionWithTypeArguments | undefined;
    /** @internal */
    function getClassExtendsHeritageElement(node: ClassLikeDeclaration | InterfaceDeclaration): ExpressionWithTypeArguments | undefined;
    /** @internal */
    function getEffectiveImplementsTypeNodes(node: ClassLikeDeclaration): undefined | readonly ExpressionWithTypeArguments[];
    /**
     * Returns the node in an `extends` or `implements` clause of a class or interface.
     *
     * @internal
     */
    function getAllSuperTypeNodes(node: Node): readonly TypeNode[];
    /** @internal */
    function getInterfaceBaseTypeNodes(node: InterfaceDeclaration): NodeArray<ExpressionWithTypeArguments> | undefined;
    /** @internal */
    function getHeritageClause(clauses: NodeArray<HeritageClause> | undefined, kind: SyntaxKind): HeritageClause | undefined;
    /** @internal */
    function getAncestor(node: Node | undefined, kind: SyntaxKind): Node | undefined;
    /** @internal */
    function isKeyword(token: SyntaxKind): token is KeywordSyntaxKind;
    /** @internal */
    function isContextualKeyword(token: SyntaxKind): boolean;
    /** @internal */
    function isNonContextualKeyword(token: SyntaxKind): boolean;
    /** @internal */
    function isFutureReservedKeyword(token: SyntaxKind): boolean;
    /** @internal */
    function isStringANonContextualKeyword(name: string): boolean;
    /** @internal */
    function isStringAKeyword(name: string): boolean;
    /** @internal */
    function isIdentifierANonContextualKeyword(node: Identifier): boolean;
    /** @internal */
    function isTrivia(token: SyntaxKind): token is TriviaSyntaxKind;
    /** @internal */
    function getFunctionFlags(node: SignatureDeclaration | undefined): FunctionFlags;
    /** @internal */
    function isAsyncFunction(node: Node): boolean;
    /** @internal */
    function isStringOrNumericLiteralLike(node: Node): node is StringLiteralLike | NumericLiteral;
    /** @internal */
    function isSignedNumericLiteral(node: Node): node is PrefixUnaryExpression & {
        operand: NumericLiteral;
    };
    /**
     * A declaration has a dynamic name if all of the following are true:
     *   1. The declaration has a computed property name.
     *   2. The computed name is *not* expressed as a StringLiteral.
     *   3. The computed name is *not* expressed as a NumericLiteral.
     *   4. The computed name is *not* expressed as a PlusToken or MinusToken
     *      immediately followed by a NumericLiteral.
     *
     * @internal
     */
    function hasDynamicName(declaration: Declaration): declaration is DynamicNamedDeclaration | DynamicNamedBinaryExpression;
    /** @internal */
    function isDynamicName(name: DeclarationName): boolean;
    /** @internal */
    function getPropertyNameForPropertyNameNode(name: PropertyName): __String | undefined;
    /** @internal */
    function isPropertyNameLiteral(node: Node): node is PropertyNameLiteral;
    /** @internal */
    function getTextOfIdentifierOrLiteral(node: PropertyNameLiteral | PrivateIdentifier): string;
    /** @internal */
    function getEscapedTextOfIdentifierOrLiteral(node: PropertyNameLiteral): __String;
    /** @internal */
    function getPropertyNameForUniqueESSymbol(symbol: Symbol): __String;
    /** @internal */
    function getSymbolNameForPrivateIdentifier(containingClassSymbol: Symbol, description: __String): __String;
    /** @internal */
    function isKnownSymbol(symbol: Symbol): boolean;
    /** @internal */
    function isPrivateIdentifierSymbol(symbol: Symbol): boolean;
    /**
     * Includes the word "Symbol" with unicode escapes
     *
     * @internal
     */
    function isESSymbolIdentifier(node: Node): boolean;
    /**
     * Indicates whether a property name is the special `__proto__` property.
     * Per the ECMA-262 spec, this only matters for property assignments whose name is
     * the Identifier `__proto__`, or the string literal `"__proto__"`, but not for
     * computed property names.
     *
     * @internal
     */
    function isProtoSetter(node: PropertyName): boolean;
    /**
     * Indicates whether an expression is an anonymous function definition.
     *
     * @see https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition
     * @internal
     */
    function isAnonymousFunctionDefinition(node: Expression, cb?: (node: AnonymousFunctionDefinition) => boolean): node is WrappedExpression<AnonymousFunctionDefinition>;
    /**
     * Indicates whether a node is a potential source of an assigned name for a class, function, or arrow function.
     *
     * @internal
     */
    function isNamedEvaluationSource(node: Node): node is NamedEvaluationSource;
    /** @internal */
    function isNamedEvaluation(node: Node, cb?: (node: AnonymousFunctionDefinition) => boolean): node is NamedEvaluation;
    /** @internal */
    function isPushOrUnshiftIdentifier(node: Identifier): boolean;
    /**
     * This function returns true if the this node's root declaration is a parameter.
     * For example, passing a `ParameterDeclaration` will return true, as will passing a
     * binding element that is a child of a `ParameterDeclaration`.
     *
     * If you are looking to test that a `Node` is a `ParameterDeclaration`, use `isParameter`.
     *
     * @internal
     */
    function isParameterDeclaration(node: Declaration): boolean;
    /** @internal */
    function getRootDeclaration(node: Node): Node;
    /** @internal */
    function nodeStartsNewLexicalEnvironment(node: Node): boolean;
    /** @internal */
    function nodeIsSynthesized(range: TextRange): boolean;
    /** @internal */
    function getOriginalSourceFile(sourceFile: SourceFile): SourceFile;
    /** @internal */
    function getExpressionAssociativity(expression: Expression): Associativity;
    /** @internal */
    function getOperatorAssociativity(kind: SyntaxKind, operator: SyntaxKind, hasArguments?: boolean): Associativity;
    /** @internal */
    function getExpressionPrecedence(expression: Expression): OperatorPrecedence;
    /** @internal */
    function getOperator(expression: Expression): SyntaxKind;
    /** @internal */
    function getOperatorPrecedence(nodeKind: SyntaxKind, operatorKind: SyntaxKind, hasArguments?: boolean): OperatorPrecedence;
    /** @internal */
    function getBinaryOperatorPrecedence(kind: SyntaxKind): OperatorPrecedence;
    /** @internal */
    function getSemanticJsxChildren(children: readonly JsxChild[]): readonly JsxChild[];
    /** @internal */
    function createDiagnosticCollection(): DiagnosticCollection;
    /** @internal */
    function hasInvalidEscape(template: TemplateLiteral): boolean;
    /**
     * Based heavily on the abstract 'Quote'/'QuoteJSONString' operation from ECMA-262 (24.3.2.2),
     * but augmented for a few select characters (e.g. lineSeparator, paragraphSeparator, nextLine)
     * Note that this doesn't actually wrap the input in double quotes.
     *
     * @internal
     */
    function escapeString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick): string;
    /** @internal */
    function escapeNonAsciiString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick): string;
    /** @internal */
    function escapeJsxAttributeString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote): string;
    /**
     * Strip off existed surrounding single quotes, double quotes, or backticks from a given string
     *
     * @return non-quoted string
     *
     * @internal
     */
    function stripQuotes(name: string): string;
    /** @internal */
    function isIntrinsicJsxName(name: __String | string): boolean;
    /** @internal */
    function getIndentString(level: number): string;
    /** @internal */
    function getIndentSize(): number;
    /** @internal */
    function isNightly(): boolean;
    /** @internal */
    function createTextWriter(newLine: string): EmitTextWriter;
    /** @internal */
    function getTrailingSemicolonDeferringWriter(writer: EmitTextWriter): EmitTextWriter;
    /** @internal */
    function hostUsesCaseSensitiveFileNames(host: {
        useCaseSensitiveFileNames?(): boolean;
    }): boolean;
    /** @internal */
    function hostGetCanonicalFileName(host: {
        useCaseSensitiveFileNames?(): boolean;
    }): GetCanonicalFileName;
    /** @internal */
    function getResolvedExternalModuleName(host: ResolveModuleNameResolutionHost, file: SourceFile, referenceFile?: SourceFile): string;
    /** @internal */
    function getExternalModuleNameFromDeclaration(host: ResolveModuleNameResolutionHost, resolver: EmitResolver, declaration: ImportEqualsDeclaration | ImportDeclaration | ExportDeclaration | ModuleDeclaration | ImportTypeNode): string | undefined;
    /**
     * Resolves a local path to a path which is absolute to the base of the emit
     *
     * @internal
     */
    function getExternalModuleNameFromPath(host: ResolveModuleNameResolutionHost, fileName: string, referencePath?: string): string;
    /** @internal */
    function getOwnEmitOutputFilePath(fileName: string, host: EmitHost, extension: string): string;
    /** @internal */
    function getDeclarationEmitOutputFilePath(fileName: string, host: EmitHost): string;
    /** @internal */
    function getDeclarationEmitOutputFilePathWorker(fileName: string, options: CompilerOptions, currentDirectory: string, commonSourceDirectory: string, getCanonicalFileName: GetCanonicalFileName): string;
    /** @internal */
    function getDeclarationEmitExtensionForPath(path: string): Extension.Dts | Extension.Dmts | Extension.Dcts | ".d.json.ts";
    /**
     * This function is an inverse of `getDeclarationEmitExtensionForPath`.
     *
     * @internal
     */
    function getPossibleOriginalInputExtensionForExtension(path: string): Extension[];
    /** @internal */
    function outFile(options: CompilerOptions): string | undefined;
    /**
     * Returns 'undefined' if and only if 'options.paths' is undefined.
     *
     * @internal
     */
    function getPathsBasePath(options: CompilerOptions, host: {
        getCurrentDirectory?(): string;
    }): string | undefined;
    /**
     * Gets the source files that are expected to have an emit output.
     *
     * Originally part of `forEachExpectedEmitFile`, this functionality was extracted to support
     * transformations.
     *
     * @param host An EmitHost.
     * @param targetSourceFile An optional target source file to emit.
     *
     * @internal
     */
    function getSourceFilesToEmit(host: EmitHost, targetSourceFile?: SourceFile, forceDtsEmit?: boolean): readonly SourceFile[];
    /**
     * Don't call this for `--outFile`, just for `--outDir` or plain emit. `--outFile` needs additional checks.
     *
     * @internal
     */
    function sourceFileMayBeEmitted(sourceFile: SourceFile, host: SourceFileMayBeEmittedHost, forceDtsEmit?: boolean): boolean;
    /** @internal */
    function getSourceFilePathInNewDir(fileName: string, host: EmitHost, newDirPath: string): string;
    /** @internal */
    function getSourceFilePathInNewDirWorker(fileName: string, newDirPath: string, currentDirectory: string, commonSourceDirectory: string, getCanonicalFileName: GetCanonicalFileName): string;
    /** @internal */
    function writeFile(host: {
        writeFile: WriteFileCallback;
    }, diagnostics: DiagnosticCollection, fileName: string, text: string, writeByteOrderMark: boolean, sourceFiles?: readonly SourceFile[], data?: WriteFileCallbackData): void;
    /** @internal */
    function writeFileEnsuringDirectories(path: string, data: string, writeByteOrderMark: boolean, writeFile: (path: string, data: string, writeByteOrderMark: boolean) => void, createDirectory: (path: string) => void, directoryExists: (path: string) => boolean): void;
    /** @internal */
    function getLineOfLocalPosition(sourceFile: SourceFile, pos: number): number;
    /** @internal */
    function getLineOfLocalPositionFromLineMap(lineMap: readonly number[], pos: number): number;
    /** @internal */
    function getFirstConstructorWithBody(node: ClassLikeDeclaration): ConstructorDeclaration & {
        body: FunctionBody;
    } | undefined;
    /** @internal */
    function getSetAccessorValueParameter(accessor: SetAccessorDeclaration): ParameterDeclaration | undefined;
    /**
     * Get the type annotation for the value parameter.
     *
     * @internal
     */
    function getSetAccessorTypeAnnotationNode(accessor: SetAccessorDeclaration): TypeNode | undefined;
    /** @internal */
    function getThisParameter(signature: SignatureDeclaration | JSDocSignature): ParameterDeclaration | undefined;
    /** @internal */
    function parameterIsThisKeyword(parameter: ParameterDeclaration): boolean;
    /** @internal */
    function isThisIdentifier(node: Node | undefined): boolean;
    /** @internal */
    function isThisInTypeQuery(node: Node): boolean;
    /** @internal */
    function identifierIsThisKeyword(id: Identifier): boolean;
    /** @internal */
    function getAllAccessorDeclarations(declarations: readonly Declaration[], accessor: AccessorDeclaration): AllAccessorDeclarations;
    /**
     * Gets the effective type annotation of a variable, parameter, or property. If the node was
     * parsed in a JavaScript file, gets the type annotation from JSDoc.  Also gets the type of
     * functions only the JSDoc case.
     *
     * @internal
     */
    function getEffectiveTypeAnnotationNode(node: Node): TypeNode | undefined;
    /** @internal */
    function getTypeAnnotationNode(node: Node): TypeNode | undefined;
    /**
     * Gets the effective return type annotation of a signature. If the node was parsed in a
     * JavaScript file, gets the return type annotation from JSDoc.
     *
     * @internal
     */
    function getEffectiveReturnTypeNode(node: SignatureDeclaration | JSDocSignature): TypeNode | undefined;
    /** @internal */
    function getJSDocTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];
    /**
     * Gets the effective type annotation of the value parameter of a set accessor. If the node
     * was parsed in a JavaScript file, gets the type annotation from JSDoc.
     *
     * @internal
     */
    function getEffectiveSetAccessorTypeAnnotationNode(node: SetAccessorDeclaration): TypeNode | undefined;
    /** @internal */
    function emitNewLineBeforeLeadingComments(lineMap: readonly number[], writer: EmitTextWriter, node: TextRange, leadingComments: readonly CommentRange[] | undefined): void;
    /** @internal */
    function emitNewLineBeforeLeadingCommentsOfPosition(lineMap: readonly number[], writer: EmitTextWriter, pos: number, leadingComments: readonly CommentRange[] | undefined): void;
    /** @internal */
    function emitNewLineBeforeLeadingCommentOfPosition(lineMap: readonly number[], writer: EmitTextWriter, pos: number, commentPos: number): void;
    /** @internal */
    function emitComments(text: string, lineMap: readonly number[], writer: EmitTextWriter, comments: readonly CommentRange[] | undefined, leadingSeparator: boolean, trailingSeparator: boolean, newLine: string, writeComment: (text: string, lineMap: readonly number[], writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string) => void): void;
    /**
     * Detached comment is a comment at the top of file or function body that is separated from
     * the next statement by space.
     *
     * @internal
     */
    function emitDetachedComments(text: string, lineMap: readonly number[], writer: EmitTextWriter, writeComment: (text: string, lineMap: readonly number[], writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string) => void, node: TextRange, newLine: string, removeComments: boolean): {
        nodePos: number;
        detachedCommentEndPos: number;
    } | undefined;
    /** @internal */
    function writeCommentRange(text: string, lineMap: readonly number[], writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string): void;
    /** @internal */
    function hasEffectiveModifiers(node: Node): boolean;
    /** @internal */
    function hasSyntacticModifiers(node: Node): boolean;
    /** @internal */
    function hasEffectiveModifier(node: Node, flags: ModifierFlags): boolean;
    /** @internal */
    function hasSyntacticModifier(node: Node, flags: ModifierFlags): boolean;
    /** @internal */
    function isStatic(node: Node): boolean;
    /** @internal */
    function hasStaticModifier(node: Node): boolean;
    /** @internal */
    function hasOverrideModifier(node: Node): boolean;
    /** @internal */
    function hasAbstractModifier(node: Node): boolean;
    /** @internal */
    function hasAmbientModifier(node: Node): boolean;
    /** @internal */
    function hasAccessorModifier(node: Node): boolean;
    /** @internal */
    function hasEffectiveReadonlyModifier(node: Node): boolean;
    /** @internal */
    function hasDecorators(node: Node): boolean;
    /** @internal */
    function getSelectedEffectiveModifierFlags(node: Node, flags: ModifierFlags): ModifierFlags;
    /** @internal */
    function getSelectedSyntacticModifierFlags(node: Node, flags: ModifierFlags): ModifierFlags;
    /**
     * Gets the effective ModifierFlags for the provided node, including JSDoc modifiers. The modifiers will be cached on the node to improve performance.
     *
     * NOTE: This function may use `parent` pointers.
     *
     * @internal
     */
    function getEffectiveModifierFlags(node: Node): ModifierFlags;
    /** @internal */
    function getEffectiveModifierFlagsAlwaysIncludeJSDoc(node: Node): ModifierFlags;
    /**
     * Gets the ModifierFlags for syntactic modifiers on the provided node. The modifiers will be cached on the node to improve performance.
     *
     * NOTE: This function does not use `parent` pointers and will not include modifiers from JSDoc.
     *
     * @internal
     */
    function getSyntacticModifierFlags(node: Node): ModifierFlags;
    /**
     * Gets the effective ModifierFlags for the provided node, including JSDoc modifiers. The modifier flags cache on the node is ignored.
     *
     * NOTE: This function may use `parent` pointers.
     *
     * @internal
     */
    function getEffectiveModifierFlagsNoCache(node: Node): ModifierFlags;
    /**
     * Gets the ModifierFlags for syntactic modifiers on the provided node. The modifier flags cache on the node is ignored.
     *
     * NOTE: This function does not use `parent` pointers and will not include modifiers from JSDoc.
     *
     * @internal
     */
    function getSyntacticModifierFlagsNoCache(node: Node): ModifierFlags;
    /** @internal */
    function modifiersToFlags(modifiers: readonly ModifierLike[] | undefined): ModifierFlags;
    /** @internal */
    function modifierToFlag(token: SyntaxKind): ModifierFlags;
    /** @internal */
    function isLogicalOperator(token: SyntaxKind): boolean;
    /** @internal */
    function isLogicalOrCoalescingAssignmentOperator(token: SyntaxKind): token is LogicalOrCoalescingAssignmentOperator;
    /** @internal */
    function isLogicalOrCoalescingAssignmentExpression(expr: Node): expr is AssignmentExpression<Token<LogicalOrCoalescingAssignmentOperator>>;
    /** @internal */
    function isLogicalOrCoalescingBinaryOperator(token: SyntaxKind): token is LogicalOperator | SyntaxKind.QuestionQuestionToken;
    /** @internal */
    function isLogicalOrCoalescingBinaryExpression(expr: Node): expr is BinaryExpression;
    /** @internal */
    function isAssignmentOperator(token: SyntaxKind): boolean;
    /**
     * Get `C` given `N` if `N` is in the position `class C extends N` where `N` is an ExpressionWithTypeArguments.
     *
     * @internal
     */
    function tryGetClassExtendingExpressionWithTypeArguments(node: Node): ClassLikeDeclaration | undefined;
    /** @internal */
    function tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node: Node): ClassImplementingOrExtendingExpressionWithTypeArguments | undefined;
    /** @internal */
    function isAssignmentExpression(node: Node, excludeCompoundAssignment: true): node is AssignmentExpression<EqualsToken>;
    /** @internal */
    function isAssignmentExpression(node: Node, excludeCompoundAssignment?: false): node is AssignmentExpression<AssignmentOperatorToken>;
    /** @internal */
    function isLeftHandSideOfAssignment(node: Node): boolean;
    /** @internal */
    function isDestructuringAssignment(node: Node): node is DestructuringAssignment;
    /** @internal */
    function isExpressionWithTypeArgumentsInClassExtendsClause(node: Node): node is ExpressionWithTypeArguments;
    /** @internal */
    function isEntityNameExpression(node: Node): node is EntityNameExpression;
    /** @internal */
    function getFirstIdentifier(node: EntityNameOrEntityNameExpression): Identifier;
    /** @internal */
    function isDottedName(node: Expression): boolean;
    /** @internal */
    function isPropertyAccessEntityNameExpression(node: Node): node is PropertyAccessEntityNameExpression;
    /** @internal */
    function tryGetPropertyAccessOrIdentifierToString(expr: Expression): string | undefined;
    /** @internal */
    function isPrototypeAccess(node: Node): node is BindableStaticAccessExpression;
    /** @internal */
    function isRightSideOfQualifiedNameOrPropertyAccess(node: Node): boolean;
    /** @internal */
    function isRightSideOfAccessExpression(node: Node): boolean;
    /** @internal */
    function isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(node: Node): boolean;
    /** @internal */
    function isEmptyObjectLiteral(expression: Node): boolean;
    /** @internal */
    function isEmptyArrayLiteral(expression: Node): boolean;
    /** @internal */
    function getLocalSymbolForExportDefault(symbol: Symbol): Symbol | undefined;
    /**
     * Return ".ts", ".d.ts", or ".tsx", if that is the extension.
     *
     * @internal
     */
    function tryExtractTSExtension(fileName: string): string | undefined;
    /**
     * Converts a string to a base-64 encoded ASCII string.
     *
     * @internal
     */
    function convertToBase64(input: string): string;
    /** @internal */
    function base64encode(host: {
        base64encode?(input: string): string;
    } | undefined, input: string): string;
    /** @internal */
    function base64decode(host: {
        base64decode?(input: string): string;
    } | undefined, input: string): string;
    /** @internal */
    function readJsonOrUndefined(path: string, hostOrText: {
        readFile(fileName: string): string | undefined;
    } | string): object | undefined;
    /** @internal */
    function readJson(path: string, host: {
        readFile(fileName: string): string | undefined;
    }): object;
    /** @internal */
    function directoryProbablyExists(directoryName: string, host: {
        directoryExists?: (directoryName: string) => boolean;
    }): boolean;
    /** @internal */
    function getNewLineCharacter(options: CompilerOptions | PrinterOptions): string;
    /**
     * Creates a new TextRange from the provided pos and end.
     *
     * @param pos The start position.
     * @param end The end position.
     *
     * @internal
     */
    function createRange(pos: number, end?: number): TextRange;
    /**
     * Creates a new TextRange from a provided range with a new end position.
     *
     * @param range A TextRange.
     * @param end The new end position.
     *
     * @internal
     */
    function moveRangeEnd(range: TextRange, end: number): TextRange;
    /**
     * Creates a new TextRange from a provided range with a new start position.
     *
     * @param range A TextRange.
     * @param pos The new Start position.
     *
     * @internal
     */
    function moveRangePos(range: TextRange, pos: number): TextRange;
    /**
     * Moves the start position of a range past any decorators.
     *
     * @internal
     */
    function moveRangePastDecorators(node: Node): TextRange;
    /**
     * Moves the start position of a range past any decorators or modifiers.
     *
     * @internal
     */
    function moveRangePastModifiers(node: Node): TextRange;
    /**
     * Determines whether a TextRange has the same start and end positions.
     *
     * @param range A TextRange.
     *
     * @internal
     */
    function isCollapsedRange(range: TextRange): boolean;
    /**
     * Creates a new TextRange for a token at the provides start position.
     *
     * @param pos The start position.
     * @param token The token.
     *
     * @internal
     */
    function createTokenRange(pos: number, token: SyntaxKind): TextRange;
    /** @internal */
    function rangeIsOnSingleLine(range: TextRange, sourceFile: SourceFile): boolean;
    /** @internal */
    function rangeStartPositionsAreOnSameLine(range1: TextRange, range2: TextRange, sourceFile: SourceFile): boolean;
    /** @internal */
    function rangeEndPositionsAreOnSameLine(range1: TextRange, range2: TextRange, sourceFile: SourceFile): boolean;
    /** @internal */
    function rangeStartIsOnSameLineAsRangeEnd(range1: TextRange, range2: TextRange, sourceFile: SourceFile): boolean;
    /** @internal */
    function rangeEndIsOnSameLineAsRangeStart(range1: TextRange, range2: TextRange, sourceFile: SourceFile): boolean;
    /** @internal */
    function getLinesBetweenRangeEndAndRangeStart(range1: TextRange, range2: TextRange, sourceFile: SourceFile, includeSecondRangeComments: boolean): number;
    /** @internal */
    function getLinesBetweenRangeEndPositions(range1: TextRange, range2: TextRange, sourceFile: SourceFile): number;
    /** @internal */
    function isNodeArrayMultiLine(list: NodeArray<Node>, sourceFile: SourceFile): boolean;
    /** @internal */
    function positionsAreOnSameLine(pos1: number, pos2: number, sourceFile: SourceFile): boolean;
    /** @internal */
    function getStartPositionOfRange(range: TextRange, sourceFile: SourceFile, includeComments: boolean): number;
    /** @internal */
    function getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter(pos: number, stopPos: number, sourceFile: SourceFile, includeComments?: boolean): number;
    /** @internal */
    function getLinesBetweenPositionAndNextNonWhitespaceCharacter(pos: number, stopPos: number, sourceFile: SourceFile, includeComments?: boolean): number;
    /**
     * Determines whether a name was originally the declaration name of an enum or namespace
     * declaration.
     *
     * @internal
     */
    function isDeclarationNameOfEnumOrNamespace(node: Identifier): boolean;
    /** @internal */
    function getInitializedVariables(node: VariableDeclarationList): readonly InitializedVariableDeclaration[];
    /** @internal */
    function isInitializedVariable(node: Node): node is InitializedVariableDeclaration;
    /** @internal */
    function isWatchSet(options: CompilerOptions): boolean | undefined;
    /** @internal */
    function closeFileWatcher(watcher: FileWatcher): void;
    /** @internal */
    function getCheckFlags(symbol: Symbol): CheckFlags;
    /** @internal */
    function getDeclarationModifierFlagsFromSymbol(s: Symbol, isWrite?: boolean): ModifierFlags;
    /** @internal */
    function skipAlias(symbol: Symbol, checker: TypeChecker): Symbol;
    /**
     * See comment on `declareModuleMember` in `binder.ts`.
     *
     * @internal
     */
    function getCombinedLocalAndExportSymbolFlags(symbol: Symbol): SymbolFlags;
    /** @internal */
    function isWriteOnlyAccess(node: Node): boolean;
    /** @internal */
    function isWriteAccess(node: Node): boolean;
    /** @internal */
    function compareDataObjects(dst: any, src: any): boolean;
    /**
     * clears already present map by calling onDeleteExistingValue callback before deleting that key/value
     *
     * @internal
     */
    function clearMap<K, T>(map: {
        forEach: Map<K, T>["forEach"];
        clear: Map<K, T>["clear"];
    }, onDeleteValue: (valueInMap: T, key: K) => void): void;
    /**
     * Mutates the map with newMap such that keys in map will be same as newMap.
     *
     * @internal
     */
    function mutateMapSkippingNewValues<K, T, U>(map: Map<K, T>, newMap: ReadonlyMap<K, U>, options: MutateMapSkippingNewValuesOptions<K, T, U>): void;
    /**
     * Mutates the map with newMap such that keys in map will be same as newMap.
     *
     * @internal
     */
    function mutateMap<K, T, U>(map: Map<K, T>, newMap: ReadonlyMap<K, U>, options: MutateMapOptions<K, T, U>): void;
    /** @internal */
    function isAbstractConstructorSymbol(symbol: Symbol): boolean;
    /** @internal */
    function getClassLikeDeclarationOfSymbol(symbol: Symbol): ClassLikeDeclaration | undefined;
    /** @internal */
    function getObjectFlags(type: Type): ObjectFlags;
    /** @internal */
    function forSomeAncestorDirectory(directory: string, callback: (directory: string) => boolean): boolean;
    /** @internal */
    function isUMDExportSymbol(symbol: Symbol | undefined): boolean;
    /** @internal */
    function showModuleSpecifier({ moduleSpecifier }: ImportDeclaration): string;
    /** @internal */
    function getLastChild(node: Node): Node | undefined;
    /**
     * Add a value to a set, and return true if it wasn't already present.
     *
     * @internal
     */
    function addToSeen<K>(seen: Map<K, true>, key: K): boolean;
    /** @internal */
    function addToSeen<K, T>(seen: Map<K, T>, key: K, value: T): boolean;
    /** @internal */
    function isObjectTypeDeclaration(node: Node): node is ObjectTypeDeclaration;
    /** @internal */
    function isTypeNodeKind(kind: SyntaxKind): kind is TypeNodeSyntaxKind;
    /** @internal */
    function isAccessExpression(node: Node): node is AccessExpression;
    /** @internal */
    function getNameOfAccessExpression(node: AccessExpression): Expression;
    /** @deprecated @internal */
    function isBundleFileTextLike(section: BundleFileSection): section is BundleFileTextLike;
    /** @internal */
    function isNamedImportsOrExports(node: Node): node is NamedImportsOrExports;
    /** @internal */
    function getLeftmostAccessExpression(expr: Expression): Expression;
    /** @internal */
    function forEachNameInAccessChainWalkingLeft<T>(name: MemberName | StringLiteralLike, action: (name: MemberName | StringLiteralLike) => T | undefined): T | undefined;
    /** @internal */
    function getLeftmostExpression(node: Expression, stopAtCallExpressions: boolean): Expression;
    /**
     * Used by `deprecatedCompat` to patch the object allocator to apply deprecations.
     * @internal
     */
    function addObjectAllocatorPatcher(fn: (objectAllocator: ObjectAllocator) => void): void;
    /** @internal */
    function setObjectAllocator(alloc: ObjectAllocator): void;
    /** @internal */
    function formatStringFromArgs(text: string, args: ArrayLike<string | number>, baseIndex?: number): string;
    /** @internal */
    function setLocalizedDiagnosticMessages(messages: MapLike<string> | undefined): void;
    /** @internal */
    function maybeSetLocalizedDiagnosticMessages(getMessages: undefined | (() => MapLike<string> | undefined)): void;
    /** @internal */
    function getLocaleSpecificMessage(message: DiagnosticMessage): string;
    /** @internal */
    function createDetachedDiagnostic(fileName: string, start: number, length: number, message: DiagnosticMessage, ...args: (string | number | undefined)[]): DiagnosticWithDetachedLocation;
    /** @internal */
    function attachFileToDiagnostics(diagnostics: DiagnosticWithDetachedLocation[], file: SourceFile): DiagnosticWithLocation[];
    /** @internal */
    function createFileDiagnostic(file: SourceFile, start: number, length: number, message: DiagnosticMessage, ...args: (string | number | undefined)[]): DiagnosticWithLocation;
    /** @internal */
    function formatMessage(_dummy: any, message: DiagnosticMessage, ...args: (string | number | undefined)[]): string;
    /** @internal */
    function createCompilerDiagnostic(message: DiagnosticMessage, ...args: (string | number | undefined)[]): Diagnostic;
    /** @internal */
    function createCompilerDiagnosticFromMessageChain(chain: DiagnosticMessageChain, relatedInformation?: DiagnosticRelatedInformation[]): Diagnostic;
    /** @internal */
    function chainDiagnosticMessages(details: DiagnosticMessageChain | DiagnosticMessageChain[] | undefined, message: DiagnosticMessage, ...args: (string | number | undefined)[]): DiagnosticMessageChain;
    /** @internal */
    function concatenateDiagnosticMessageChains(headChain: DiagnosticMessageChain, tailChain: DiagnosticMessageChain): void;
    /** @internal */
    function compareDiagnostics(d1: Diagnostic, d2: Diagnostic): Comparison;
    /** @internal */
    function compareDiagnosticsSkipRelatedInformation(d1: Diagnostic, d2: Diagnostic): Comparison;
    /** @internal */
    function getLanguageVariant(scriptKind: ScriptKind): LanguageVariant;
    /** @internal */
    function getSetExternalModuleIndicator(options: CompilerOptions): (file: SourceFile) => void;
    /** @internal */
    function getEmitScriptTarget(compilerOptions: {
        module?: CompilerOptions["module"];
        target?: CompilerOptions["target"];
    }): ScriptTarget;
    /** @internal */
    function getEmitModuleKind(compilerOptions: {
        module?: CompilerOptions["module"];
        target?: CompilerOptions["target"];
    }): ModuleKind;
    /** @internal */
    function emitModuleKindIsNonNodeESM(moduleKind: ModuleKind): boolean;
    /** @internal */
    function getEmitModuleResolutionKind(compilerOptions: CompilerOptions): ModuleResolutionKind;
    /** @internal */
    function getEmitModuleDetectionKind(options: CompilerOptions): ModuleDetectionKind;
    /** @internal */
    function hasJsonModuleEmitEnabled(options: CompilerOptions): boolean;
    /** @internal */
    function getIsolatedModules(options: CompilerOptions): boolean;
    /** @internal */
    function importNameElisionDisabled(options: CompilerOptions): boolean | undefined;
    /** @internal */
    function unreachableCodeIsError(options: CompilerOptions): boolean;
    /** @internal */
    function unusedLabelIsError(options: CompilerOptions): boolean;
    /** @internal */
    function getAreDeclarationMapsEnabled(options: CompilerOptions): boolean;
    /** @internal */
    function getESModuleInterop(compilerOptions: CompilerOptions): boolean | undefined;
    /** @internal */
    function getAllowSyntheticDefaultImports(compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function moduleResolutionSupportsPackageJsonExportsAndImports(moduleResolution: ModuleResolutionKind): boolean;
    /** @internal */
    function shouldResolveJsRequire(compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function getResolvePackageJsonExports(compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function getResolvePackageJsonImports(compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function getResolveJsonModule(compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function getEmitDeclarations(compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function shouldPreserveConstEnums(compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function isIncrementalCompilation(options: CompilerOptions): boolean;
    /** @internal */
    function getStrictOptionValue(compilerOptions: CompilerOptions, flag: StrictOptionName): boolean;
    /** @internal */
    function getAllowJSCompilerOption(compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function getUseDefineForClassFields(compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function compilerOptionsAffectSemanticDiagnostics(newOptions: CompilerOptions, oldOptions: CompilerOptions): boolean;
    /** @internal */
    function compilerOptionsAffectEmit(newOptions: CompilerOptions, oldOptions: CompilerOptions): boolean;
    /** @internal */
    function compilerOptionsAffectDeclarationPath(newOptions: CompilerOptions, oldOptions: CompilerOptions): boolean;
    /** @internal */
    function getCompilerOptionValue(options: CompilerOptions, option: CommandLineOption): unknown;
    /** @internal */
    function getJSXTransformEnabled(options: CompilerOptions): boolean;
    /** @internal */
    function getJSXImplicitImportBase(compilerOptions: CompilerOptions, file?: SourceFile): string | undefined;
    /** @internal */
    function getJSXRuntimeImport(base: string | undefined, options: CompilerOptions): string | undefined;
    /** @internal */
    function hasZeroOrOneAsteriskCharacter(str: string): boolean;
    /** @internal */
    function createSymlinkCache(cwd: string, getCanonicalFileName: GetCanonicalFileName): SymlinkCache;
    /** @internal */
    function tryRemoveDirectoryPrefix(path: string, dirPath: string, getCanonicalFileName: GetCanonicalFileName): string | undefined;
    /** @internal */
    function regExpEscape(text: string): string;
    /** @internal */
    function getRegularExpressionForWildcard(specs: readonly string[] | undefined, basePath: string, usage: "files" | "directories" | "exclude"): string | undefined;
    /** @internal */
    function getRegularExpressionsForWildcards(specs: readonly string[] | undefined, basePath: string, usage: "files" | "directories" | "exclude"): readonly string[] | undefined;
    /**
     * An "includes" path "foo" is implicitly a glob "foo/** /*" (without the space) if its last component has no extension,
     * and does not contain any glob characters itself.
     *
     * @internal
     */
    function isImplicitGlob(lastPathComponent: string): boolean;
    /** @internal */
    function getPatternFromSpec(spec: string, basePath: string, usage: "files" | "directories" | "exclude"): string | undefined;
    /**
     * @param path directory of the tsconfig.json
     *
     * @internal
     */
    function getFileMatcherPatterns(path: string, excludes: readonly string[] | undefined, includes: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string): FileMatcherPatterns;
    /** @internal */
    function getRegexFromPattern(pattern: string, useCaseSensitiveFileNames: boolean): RegExp;
    /**
     * @param path directory of the tsconfig.json
     *
     * @internal
     */
    function matchFiles(path: string, extensions: readonly string[] | undefined, excludes: readonly string[] | undefined, includes: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string, depth: number | undefined, getFileSystemEntries: (path: string) => FileSystemEntries, realpath: (path: string) => string): string[];
    /** @internal */
    function ensureScriptKind(fileName: string, scriptKind: ScriptKind | undefined): ScriptKind;
    /** @internal */
    function getScriptKindFromFileName(fileName: string): ScriptKind;
    /** @internal */
    function getSupportedExtensions(options?: CompilerOptions): readonly Extension[][];
    /** @internal */
    function getSupportedExtensions(options?: CompilerOptions, extraFileExtensions?: readonly FileExtensionInfo[]): readonly string[][];
    /** @internal */
    function getSupportedExtensionsWithJsonIfResolveJsonModule(options: CompilerOptions | undefined, supportedExtensions: readonly Extension[][]): readonly Extension[][];
    /** @internal */
    function getSupportedExtensionsWithJsonIfResolveJsonModule(options: CompilerOptions | undefined, supportedExtensions: readonly string[][]): readonly string[][];
    /** @internal */
    function hasJSFileExtension(fileName: string): boolean;
    /** @internal */
    function hasTSFileExtension(fileName: string): boolean;
    /** @internal */
    function usesExtensionsOnImports({ imports }: SourceFile, hasExtension?: (text: string) => boolean): boolean;
    /** @internal */
    function getModuleSpecifierEndingPreference(preference: UserPreferences["importModuleSpecifierEnding"], resolutionMode: ResolutionMode, compilerOptions: CompilerOptions, sourceFile: SourceFile): ModuleSpecifierEnding;
    /** @internal */
    function isSupportedSourceFileName(fileName: string, compilerOptions?: CompilerOptions, extraFileExtensions?: readonly FileExtensionInfo[]): boolean;
    /** @internal */
    function compareNumberOfDirectorySeparators(path1: string, path2: string): Comparison;
    /** @internal */
    function removeFileExtension(path: string): string;
    /** @internal */
    function tryRemoveExtension(path: string, extension: string): string | undefined;
    /** @internal */
    function removeExtension(path: string, extension: string): string;
    /** @internal */
    function changeExtension<T extends string | Path>(path: T, newExtension: string): T;
    /**
     * Returns the input if there are no stars, a pattern if there is exactly one,
     * and undefined if there are more.
     *
     * @internal
     */
    function tryParsePattern(pattern: string): string | Pattern | undefined;
    /** @internal */
    function tryParsePatterns(paths: MapLike<string[]>): (string | Pattern)[];
    /** @internal */
    function positionIsSynthesized(pos: number): boolean;
    /**
     * True if an extension is one of the supported TypeScript extensions.
     *
     * @internal
     */
    function extensionIsTS(ext: string): boolean;
    /** @internal */
    function resolutionExtensionIsTSOrJson(ext: string): boolean;
    /**
     * Gets the extension from a path.
     * Path must have a valid extension.
     *
     * @internal
     */
    function extensionFromPath(path: string): Extension;
    /** @internal */
    function isAnySupportedFileExtension(path: string): boolean;
    /** @internal */
    function tryGetExtensionFromPath(path: string): Extension | undefined;
    /** @internal */
    function isCheckJsEnabledForFile(sourceFile: SourceFile, compilerOptions: CompilerOptions): boolean | undefined;
    /**
     * patternOrStrings contains both patterns (containing "*") and regular strings.
     * Return an exact match if possible, or a pattern match, or undefined.
     * (These are verified by verifyCompilerOptions to have 0 or 1 "*" characters.)
     *
     * @internal
     */
    function matchPatternOrExact(patternOrStrings: readonly (string | Pattern)[], candidate: string): string | Pattern | undefined;
    /** @internal */
    function sliceAfter<T>(arr: readonly T[], value: T): readonly T[];
    /** @internal */
    function addRelatedInfo<T extends Diagnostic>(diagnostic: T, ...relatedInformation: DiagnosticRelatedInformation[]): T;
    /** @internal */
    function minAndMax<T>(arr: readonly T[], getValue: (value: T) => number): {
        readonly min: number;
        readonly max: number;
    };
    /** @internal */
    function rangeOfNode(node: Node): TextRange;
    /** @internal */
    function rangeOfTypeParameters(sourceFile: SourceFile, typeParameters: NodeArray<TypeParameterDeclaration>): TextRange;
    /** @internal */
    function skipTypeChecking(sourceFile: SourceFile, options: CompilerOptions, host: HostWithIsSourceOfProjectReferenceRedirect): boolean;
    /** @internal */
    function isJsonEqual(a: unknown, b: unknown): boolean;
    /**
     * Converts a bigint literal string, e.g. `0x1234n`,
     * to its decimal string representation, e.g. `4660`.
     *
     * @internal
     */
    function parsePseudoBigInt(stringValue: string): string;
    /** @internal */
    function pseudoBigIntToString({ negative, base10Value }: PseudoBigInt): string;
    /** @internal */
    function parseBigInt(text: string): PseudoBigInt | undefined;
    /**
     * @internal
     * @param text a valid bigint string excluding a trailing `n`, but including a possible prefix `-`. Use `isValidBigIntString(text, roundTripOnly)` before calling this function.
     */
    function parseValidBigInt(text: string): PseudoBigInt;
    /**
     * @internal
     * Tests whether the provided string can be parsed as a bigint.
     * @param s The string to test.
     * @param roundTripOnly Indicates the resulting bigint matches the input when converted back to a string.
     */
    function isValidBigIntString(s: string, roundTripOnly: boolean): boolean;
    /** @internal */
    function isValidTypeOnlyAliasUseSite(useSite: Node): boolean;
    /** @internal */
    function isIdentifierTypeReference(node: Node): node is TypeReferenceNode & {
        typeName: Identifier;
    };
    /** @internal */
    function arrayIsHomogeneous<T>(array: readonly T[], comparer?: EqualityComparer<T>): boolean;
    /**
     * Bypasses immutability and directly sets the `pos` property of a `TextRange` or `Node`.
     *
     * @internal
     */
    function setTextRangePos<T extends ReadonlyTextRange>(range: T, pos: number): T;
    /**
     * Bypasses immutability and directly sets the `end` property of a `TextRange` or `Node`.
     *
     * @internal
     */
    function setTextRangeEnd<T extends ReadonlyTextRange>(range: T, end: number): T;
    /**
     * Bypasses immutability and directly sets the `pos` and `end` properties of a `TextRange` or `Node`.
     *
     * @internal
     */
    function setTextRangePosEnd<T extends ReadonlyTextRange>(range: T, pos: number, end: number): T;
    /**
     * Bypasses immutability and directly sets the `pos` and `end` properties of a `TextRange` or `Node` from the
     * provided position and width.
     *
     * @internal
     */
    function setTextRangePosWidth<T extends ReadonlyTextRange>(range: T, pos: number, width: number): T;
    /**
     * Bypasses immutability and directly sets the `flags` property of a `Node`.
     *
     * @internal
     */
    function setNodeFlags<T extends Node>(node: T, newFlags: NodeFlags): T;
    /** @internal */
    function setNodeFlags<T extends Node>(node: T | undefined, newFlags: NodeFlags): T | undefined;
    /**
     * Bypasses immutability and directly sets the `parent` property of a `Node`.
     *
     * @internal
     */
    function setParent<T extends Node>(child: T, parent: T["parent"] | undefined): T;
    /** @internal */
    function setParent<T extends Node>(child: T | undefined, parent: T["parent"] | undefined): T | undefined;
    /**
     * Bypasses immutability and directly sets the `parent` property of each `Node` in an array of nodes, if is not already set.
     *
     * @internal
     */
    function setEachParent<T extends readonly Node[]>(children: T, parent: T[number]["parent"]): T;
    /** @internal */
    function setEachParent<T extends readonly Node[]>(children: T | undefined, parent: T[number]["parent"]): T | undefined;
    /**
     * Bypasses immutability and directly sets the `parent` property of each `Node` recursively.
     * @param rootNode The root node from which to start the recursion.
     * @param incremental When `true`, only recursively descends through nodes whose `parent` pointers are incorrect.
     * This allows us to quickly bail out of setting `parent` for subtrees during incremental parsing.
     *
     * @internal
     */
    function setParentRecursive<T extends Node>(rootNode: T, incremental: boolean): T;
    /** @internal */
    function setParentRecursive<T extends Node>(rootNode: T | undefined, incremental: boolean): T | undefined;
    /**
     * Determines whether the provided node is an ArrayLiteralExpression that contains no missing elements.
     *
     * @internal
     */
    function isPackedArrayLiteral(node: Expression): boolean;
    /**
     * Indicates whether the result of an `Expression` will be unused.
     *
     * NOTE: This requires a node with a valid `parent` pointer.
     *
     * @internal
     */
    function expressionResultIsUnused(node: Expression): boolean;
    /** @internal */
    function containsIgnoredPath(path: string): boolean;
    /** @internal */
    function getContainingNodeArray(node: Node): NodeArray<Node> | undefined;
    /** @internal */
    function hasContextSensitiveParameters(node: FunctionLikeDeclaration): boolean;
    /** @internal */
    function isInfinityOrNaNString(name: string | __String): boolean;
    /** @internal */
    function isCatchClauseVariableDeclaration(node: Node): boolean;
    /** @internal */
    function isParameterOrCatchClauseVariable(symbol: Symbol): boolean;
    /** @internal */
    function isFunctionExpressionOrArrowFunction(node: Node): node is FunctionExpression | ArrowFunction;
    /** @internal */
    function escapeSnippetText(text: string): string;
    /** @internal */
    function isNumericLiteralName(name: string | __String): boolean;
    /** @internal */
    function createPropertyNameNodeForIdentifierOrLiteral(name: string, target: ScriptTarget, singleQuote?: boolean, stringNamed?: boolean): Identifier | StringLiteral | NumericLiteral;
    /** @internal */
    function isThisTypeParameter(type: Type): boolean;
    /** @internal */
    function getNodeModulePathParts(fullPath: string): NodeModulePathParts | undefined;
    /** @internal */
    function getParameterTypeNode(parameter: ParameterDeclaration | JSDocParameterTag): TypeNode | undefined;
    /** @internal */
    function isTypeDeclaration(node: Node): node is TypeParameterDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag | EnumDeclaration | ImportClause | ImportSpecifier | ExportSpecifier;
    /** @internal */
    function canHaveExportModifier(node: Node): node is Extract<HasModifiers, Statement>;
    /** @internal */
    function isOptionalJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;
    /** @internal */
    function canUsePropertyAccess(name: string, languageVersion: ScriptTarget): boolean;
    /** @internal */
    function hasTabstop(node: Node): boolean;
    /** @internal */
    function isJSDocOptionalParameter(node: ParameterDeclaration): boolean;
    /** @internal */
    function isOptionalDeclaration(declaration: Declaration): boolean;
    /** @internal */
    function isNonNullAccess(node: Node): node is AccessExpression;
    /** @internal */
    function isJSDocSatisfiesExpression(node: Node): node is JSDocSatisfiesExpression;
    /** @internal */
    function getJSDocSatisfiesExpressionType(node: JSDocSatisfiesExpression): TypeNode;
    /** @internal */
    function tryGetJSDocSatisfiesTypeNode(node: Node): TypeNode | undefined;
    /** @internal */
    const resolvingEmptyArray: never[];
    /** @internal */
    const externalHelpersModuleNameText = "tslib";
    /** @internal */
    const defaultMaximumTruncationLength = 160;
    /** @internal */
    const noTruncationMaximumTruncationLength = 1000000;
    /** @internal */
    type ScriptTargetFeatures = ReadonlyMap<string, ReadonlyMap<string, string[]>>;
    /** @internal */
    enum GetLiteralTextFlags {
        None = 0,
        NeverAsciiEscape = 1,
        JsxAttributeEscape = 2,
        TerminateUnterminatedLiterals = 4,
        AllowNumericSeparator = 8
    }
    /** @internal */
    const fullTripleSlashReferencePathRegEx: RegExp;
    /** @internal */
    const fullTripleSlashAMDReferencePathRegEx: RegExp;
    /** @internal */
    type ThisContainer = FunctionDeclaration | FunctionExpression | ModuleDeclaration | ClassStaticBlockDeclaration | PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | CallSignatureDeclaration | ConstructSignatureDeclaration | IndexSignatureDeclaration | EnumDeclaration | SourceFile;
    /** @internal */
    type SuperContainer = PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassStaticBlockDeclaration;
    /** @internal */
    type SuperContainerOrFunctions = SuperContainer | FunctionDeclaration | FunctionExpression | ArrowFunction;
    /** @internal */
    interface PrototypePropertyAssignment extends AssignmentExpression<EqualsToken> {
        _prototypePropertyAssignmentBrand: any;
        readonly left: AccessExpression;
    }
    /** @internal */
    enum AssignmentKind {
        None = 0,
        Definite = 1,
        Compound = 2
    }
    /** @internal */
    type NodeWithPossibleHoistedDeclaration = Block | VariableStatement | WithStatement | IfStatement | SwitchStatement | CaseBlock | CaseClause | DefaultClause | LabeledStatement | ForStatement | ForInStatement | ForOfStatement | DoStatement | WhileStatement | TryStatement | CatchClause;
    /** @internal */
    type ValueSignatureDeclaration = FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction;
    /** @internal */
    enum FunctionFlags {
        Normal = 0,
        Generator = 1,
        Async = 2,
        Invalid = 4,
        AsyncGenerator = 3
    }
    /** @internal */
    type AnonymousFunctionDefinition = ClassExpression & {
        readonly name?: undefined;
    } | FunctionExpression & {
        readonly name?: undefined;
    } | ArrowFunction;
    /** @internal */
    type NamedEvaluationSource = PropertyAssignment & {
        readonly name: Identifier;
    } | ShorthandPropertyAssignment & {
        readonly objectAssignmentInitializer: Expression;
    } | VariableDeclaration & {
        readonly name: Identifier;
        readonly initializer: Expression;
    } | ParameterDeclaration & {
        readonly name: Identifier;
        readonly initializer: Expression;
        readonly dotDotDotToken: undefined;
    } | BindingElement & {
        readonly name: Identifier;
        readonly initializer: Expression;
        readonly dotDotDotToken: undefined;
    } | PropertyDeclaration & {
        readonly initializer: Expression;
    } | AssignmentExpression<EqualsToken | AmpersandAmpersandEqualsToken | BarBarEqualsToken | QuestionQuestionEqualsToken> & {
        readonly left: Identifier;
    } | ExportAssignment;
    /** @internal */
    type NamedEvaluation = PropertyAssignment & {
        readonly name: Identifier;
        readonly initializer: WrappedExpression<AnonymousFunctionDefinition>;
    } | ShorthandPropertyAssignment & {
        readonly objectAssignmentInitializer: WrappedExpression<AnonymousFunctionDefinition>;
    } | VariableDeclaration & {
        readonly name: Identifier;
        readonly initializer: WrappedExpression<AnonymousFunctionDefinition>;
    } | ParameterDeclaration & {
        readonly name: Identifier;
        readonly dotDotDotToken: undefined;
        readonly initializer: WrappedExpression<AnonymousFunctionDefinition>;
    } | BindingElement & {
        readonly name: Identifier;
        readonly dotDotDotToken: undefined;
        readonly initializer: WrappedExpression<AnonymousFunctionDefinition>;
    } | PropertyDeclaration & {
        readonly initializer: WrappedExpression<AnonymousFunctionDefinition>;
    } | AssignmentExpression<EqualsToken | AmpersandAmpersandEqualsToken | BarBarEqualsToken | QuestionQuestionEqualsToken> & {
        readonly left: Identifier;
        readonly right: WrappedExpression<AnonymousFunctionDefinition>;
    } | ExportAssignment & {
        readonly expression: WrappedExpression<AnonymousFunctionDefinition>;
    };
    /** @internal */
    enum Associativity {
        Left = 0,
        Right = 1
    }
    /** @internal */
    enum OperatorPrecedence {
        Comma = 0,
        Spread = 1,
        Yield = 2,
        Assignment = 3,
        Conditional = 4,
        Coalesce = 4,
        LogicalOR = 5,
        LogicalAND = 6,
        BitwiseOR = 7,
        BitwiseXOR = 8,
        BitwiseAND = 9,
        Equality = 10,
        Relational = 11,
        Shift = 12,
        Additive = 13,
        Multiplicative = 14,
        Exponentiation = 15,
        Unary = 16,
        Update = 17,
        LeftHandSide = 18,
        Member = 19,
        Primary = 20,
        Highest = 20,
        Lowest = 0,
        Invalid = -1
    }
    /** @internal */
    interface ResolveModuleNameResolutionHost {
        getCanonicalFileName(p: string): string;
        getCommonSourceDirectory(): string;
        getCurrentDirectory(): string;
    }
    /** @internal */
    interface EmitFileNames {
        jsFilePath?: string | undefined;
        sourceMapFilePath?: string | undefined;
        declarationFilePath?: string | undefined;
        declarationMapPath?: string | undefined;
        buildInfoPath?: string | undefined;
    }
    /** @internal */
    interface ClassImplementingOrExtendingExpressionWithTypeArguments {
        readonly class: ClassLikeDeclaration;
        readonly isImplements: boolean;
    }
    /** @internal */
    interface MutateMapSkippingNewValuesOptions<K, T, U> {
        onDeleteValue(existingValue: T, key: K): void;
        /**
         * If present this is called with the key when there is value for that key both in new map as well as existing map provided
         * Caller can then decide to update or remove this key.
         * If the key is removed, caller will get callback of createNewValue for that key.
         * If this callback is not provided, the value of such keys is not updated.
         */
        onExistingValue?(existingValue: T, valueInNewMap: U, key: K): void;
    }
    /** @internal */
    interface MutateMapOptions<K, T, U> extends MutateMapSkippingNewValuesOptions<K, T, U> {
        createNewValue(key: K, valueInNewMap: U): T;
    }
    /** @internal */
    interface ObjectAllocator {
        getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node;
        getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>;
        getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier;
        getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier;
        getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile;
        getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol;
        getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type;
        getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature;
        getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource;
    }
    /** @internal */
    const objectAllocator: ObjectAllocator;
    /** @internal */
    type StrictOptionName = "noImplicitAny" | "noImplicitThis" | "strictNullChecks" | "strictFunctionTypes" | "strictBindCallApply" | "strictPropertyInitialization" | "alwaysStrict" | "useUnknownInCatchVariables";
    /** @internal */
    interface SymlinkedDirectory {
        /** Matches the casing returned by `realpath`.  Used to compute the `realpath` of children. */
        real: string;
        /** toPath(real).  Stored to avoid repeated recomputation. */
        realPath: Path;
    }
    /** @internal */
    interface SymlinkCache {
        /** Gets a map from symlink to realpath. Keys have trailing directory separators. */
        getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined;
        /** Gets a map from realpath to symlinks. Keys have trailing directory separators. */
        getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined;
        /** Gets a map from symlink to realpath */
        getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined;
        setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void;
        setSymlinkedFile(symlinkPath: Path, real: string): void;
        /**
         * @internal
         * Uses resolvedTypeReferenceDirectives from program instead of from files, since files
         * don't include automatic type reference directives. Must be called only when
         * `hasProcessedResolutions` returns false (once per cache instance).
         */
        setSymlinksFromResolutions(files: readonly SourceFile[], typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>): void;
        /**
         * @internal
         * Whether `setSymlinksFromResolutions` has already been called.
         */
        hasProcessedResolutions(): boolean;
    }
    /** @internal */
    const commonPackageFolders: readonly string[];
    /** @internal */
    interface FileSystemEntries {
        readonly files: readonly string[];
        readonly directories: readonly string[];
    }
    /** @internal */
    interface FileMatcherPatterns {
        /** One pattern for each "include" spec. */
        includeFilePatterns: readonly string[] | undefined;
        /** One pattern matching one of any of the "include" specs. */
        includeFilePattern: string | undefined;
        includeDirectoryPattern: string | undefined;
        excludePattern: string | undefined;
        basePaths: readonly string[];
    }
    /**
     *  Groups of supported extensions in order of file resolution precedence. (eg, TS > TSX > DTS and seperately, CTS > DCTS)
     *
     * @internal
     */
    const supportedTSExtensions: readonly Extension[][];
    /** @internal */
    const supportedTSExtensionsFlat: readonly Extension[];
    /** @internal */
    const supportedJSExtensions: readonly Extension[][];
    /** @internal */
    const supportedJSExtensionsFlat: readonly Extension[];
    /** @internal */
    const supportedDeclarationExtensions: readonly Extension[];
    /** @internal */
    const supportedTSImplementationExtensions: readonly Extension[];
    /**
     * @internal
     * Corresponds to UserPreferences#importPathEnding
     */
    enum ModuleSpecifierEnding {
        Minimal = 0,
        Index = 1,
        JsExtension = 2,
        TsExtension = 3
    }
    /** @internal */
    const emptyFileSystemEntries: FileSystemEntries;
    /** @internal */
    type Mutable<T extends object> = {
        -readonly [K in keyof T]: T[K];
    };
    /** @internal */
    interface HostWithIsSourceOfProjectReferenceRedirect {
        isSourceOfProjectReferenceRedirect(fileName: string): boolean;
    }
    /** @internal */
    interface NodeModulePathParts {
        readonly topLevelNodeModulesIndex: number;
        readonly topLevelPackageNameIndex: number;
        readonly packageRootIndex: number;
        readonly fileNameIndex: number;
    }
    /**
     * Creates a `BaseNodeFactory` which can be used to create `Node` instances from the constructors provided by the object allocator.
     *
     * @internal
     */
    function createBaseNodeFactory(): BaseNodeFactory;
    /**
     * A `BaseNodeFactory` is an abstraction over an `ObjectAllocator` that handles caching `Node` constructors
     * and allocating `Node` instances based on a set of predefined types.
     *
     * @internal
     */
    interface BaseNodeFactory {
        createBaseSourceFileNode(kind: SyntaxKind.SourceFile): Node;
        createBaseIdentifierNode(kind: SyntaxKind.Identifier): Node;
        createBasePrivateIdentifierNode(kind: SyntaxKind.PrivateIdentifier): Node;
        createBaseTokenNode(kind: SyntaxKind): Node;
        createBaseNode(kind: SyntaxKind): Node;
    }
    /** @internal */
    function createParenthesizerRules(factory: NodeFactory): ParenthesizerRules;
    /** @internal */
    const nullParenthesizerRules: ParenthesizerRules;
    /** @internal */
    function createNodeConverters(factory: NodeFactory): NodeConverters;
    /** @internal */
    const nullNodeConverters: NodeConverters;
    /** @internal */
    function addNodeFactoryPatcher(fn: (factory: NodeFactory) => void): void;
    /**
     * Creates a `NodeFactory` that can be used to create and update a syntax tree.
     * @param flags Flags that control factory behavior.
     * @param baseFactory A `BaseNodeFactory` used to create the base `Node` objects.
     *
     * @internal
     */
    function createNodeFactory(flags: NodeFactoryFlags, baseFactory: BaseNodeFactory): NodeFactory;
    /**
     * Gets the transform flags to exclude when unioning the transform flags of a subtree.
     *
     * @internal
     */
    function getTransformFlagsSubtreeExclusions(kind: SyntaxKind): TransformFlags.HasComputedFlags | TransformFlags.ArrowFunctionExcludes | TransformFlags.FunctionExcludes | TransformFlags.ConstructorExcludes | TransformFlags.MethodOrAccessorExcludes | TransformFlags.PropertyExcludes | TransformFlags.ClassExcludes | TransformFlags.ModuleExcludes | TransformFlags.TypeExcludes | TransformFlags.ObjectLiteralExcludes | TransformFlags.ArrayLiteralOrCallOrNewExcludes | TransformFlags.VariableDeclarationListExcludes | TransformFlags.CatchClauseExcludes;
    /** @deprecated */
    function createUnparsedSourceFile(text: string): UnparsedSource;
    /** @deprecated */
    function createUnparsedSourceFile(inputFile: InputFiles, type: "js" | "dts", stripInternal?: boolean): UnparsedSource;
    /** @deprecated */
    function createUnparsedSourceFile(text: string, mapPath: string | undefined, map: string | undefined): UnparsedSource;
    /** @deprecated */
    function createInputFiles(javascriptText: string, declarationText: string): InputFiles;
    /** @deprecated */
    function createInputFiles(javascriptText: string, declarationText: string, javascriptMapPath: string | undefined, javascriptMapText: string | undefined, declarationMapPath: string | undefined, declarationMapText: string | undefined): InputFiles;
    /** @deprecated */
    function createInputFiles(readFileText: (path: string) => string | undefined, javascriptPath: string, javascriptMapPath: string | undefined, declarationPath: string, declarationMapPath: string | undefined, buildInfoPath: string | undefined): InputFiles;
    /** @deprecated @internal */
    function createInputFilesWithFilePaths(readFileText: (path: string) => string | undefined, javascriptPath: string, javascriptMapPath: string | undefined, declarationPath: string, declarationMapPath: string | undefined, buildInfoPath: string | undefined, host?: CompilerHost, options?: CompilerOptions): InputFiles;
    /** @deprecated @internal */
    function createInputFilesWithFileTexts(javascriptPath: string | undefined, javascriptText: string, javascriptMapPath: string | undefined, javascriptMapText: string | undefined, declarationPath: string | undefined, declarationText: string, declarationMapPath: string | undefined, declarationMapText: string | undefined, buildInfoPath?: string, buildInfo?: BuildInfo, oldFileOfCurrentEmit?: boolean): InputFiles;
    /**
     * Create an external source map source file reference
     */
    function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;
    function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;
    /** @internal */
    enum NodeFactoryFlags {
        None = 0,
        NoParenthesizerRules = 1,
        NoNodeConverters = 2,
        NoIndentationOnFreshPropertyAccess = 4,
        NoOriginalNode = 8
    }
    const factory: NodeFactory;
    /**
     * Associates a node with the current transformation, initializing
     * various transient transformation properties.
     * @internal
     */
    function getOrCreateEmitNode(node: Node): EmitNode;
    /**
     * Clears any `EmitNode` entries from parse-tree nodes.
     * @param sourceFile A source file.
     */
    function disposeEmitNodes(sourceFile: SourceFile | undefined): void;
    /**
     * Sets `EmitFlags.NoComments` on a node and removes any leading and trailing synthetic comments.
     * @internal
     */
    function removeAllComments<T extends Node>(node: T): T;
    /**
     * Sets flags that control emit behavior of a node.
     */
    function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;
    /**
     * Sets flags that control emit behavior of a node.
     *
     * @internal
     */
    function addEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;
    /**
     * Sets flags that control emit behavior of a node.
     *
     * @internal
     */
    function setInternalEmitFlags<T extends Node>(node: T, emitFlags: InternalEmitFlags): T;
    /**
     * Sets flags that control emit behavior of a node.
     *
     * @internal
     */
    function addInternalEmitFlags<T extends Node>(node: T, emitFlags: InternalEmitFlags): T;
    /**
     * Gets a custom text range to use when emitting source maps.
     */
    function getSourceMapRange(node: Node): SourceMapRange;
    /**
     * Sets a custom text range to use when emitting source maps.
     */
    function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;
    /**
     * Gets the TextRange to use for source maps for a token of a node.
     */
    function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;
    /**
     * Sets the TextRange to use for source maps for a token of a node.
     */
    function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;
    /**
     * Gets a custom text range to use when emitting comments.
     *
     * @internal
     */
    function getStartsOnNewLine(node: Node): boolean | undefined;
    /**
     * Sets a custom text range to use when emitting comments.
     *
     * @internal
     */
    function setStartsOnNewLine<T extends Node>(node: T, newLine: boolean): T;
    /**
     * Gets a custom text range to use when emitting comments.
     */
    function getCommentRange(node: Node): TextRange;
    /**
     * Sets a custom text range to use when emitting comments.
     */
    function setCommentRange<T extends Node>(node: T, range: TextRange): T;
    function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;
    function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
    function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
    function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;
    function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
    function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
    function moveSyntheticComments<T extends Node>(node: T, original: Node): T;
    /**
     * Gets the constant value to emit for an expression representing an enum.
     */
    function getConstantValue(node: AccessExpression): string | number | undefined;
    /**
     * Sets the constant value to emit for an expression.
     */
    function setConstantValue(node: AccessExpression, value: string | number): AccessExpression;
    /**
     * Adds an EmitHelper to a node.
     */
    function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;
    /**
     * Add EmitHelpers to a node.
     */
    function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;
    /**
     * Removes an EmitHelper from a node.
     */
    function removeEmitHelper(node: Node, helper: EmitHelper): boolean;
    /**
     * Gets the EmitHelpers of a node.
     */
    function getEmitHelpers(node: Node): EmitHelper[] | undefined;
    /**
     * Moves matching emit helpers from a source node to a target node.
     */
    function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;
    /**
     * Gets the SnippetElement of a node.
     *
     * @internal
     */
    function getSnippetElement(node: Node): SnippetElement | undefined;
    /**
     * Sets the SnippetElement of a node.
     *
     * @internal
     */
    function setSnippetElement<T extends Node>(node: T, snippet: SnippetElement): T;
    /** @internal */
    function ignoreSourceNewlines<T extends Node>(node: T): T;
    /** @internal */
    function setTypeNode<T extends Node>(node: T, type: TypeNode): T;
    /** @internal */
    function getTypeNode<T extends Node>(node: T): TypeNode | undefined;
    /** @internal */
    function setIdentifierTypeArguments<T extends Identifier>(node: T, typeArguments: NodeArray<TypeNode | TypeParameterDeclaration> | undefined): T;
    /** @internal */
    function getIdentifierTypeArguments(node: Identifier): NodeArray<TypeNode | TypeParameterDeclaration> | undefined;
    /** @internal */
    function setIdentifierAutoGenerate<T extends Identifier | PrivateIdentifier>(node: T, autoGenerate: AutoGenerateInfo | undefined): T;
    /** @internal */
    function getIdentifierAutoGenerate(node: Identifier | PrivateIdentifier): AutoGenerateInfo | undefined;
    /** @internal */
    function setIdentifierGeneratedImportReference<T extends Identifier | PrivateIdentifier>(node: T, value: ImportSpecifier | undefined): T;
    /** @internal */
    function getIdentifierGeneratedImportReference(node: Identifier | PrivateIdentifier): ImportSpecifier | undefined;
    /** @internal */
    function createEmitHelperFactory(context: TransformationContext): EmitHelperFactory;
    /** @internal */
    function compareEmitHelpers(x: EmitHelper, y: EmitHelper): Comparison;
    /**
     * @param input Template string input strings
     * @param args Names which need to be made file-level unique
     *
     * @internal
     */
    function helperString(input: TemplateStringsArray, ...args: string[]): (uniqueName: EmitHelperUniqueNameCallback) => string;
    /** @internal */
    function getAllUnscopedEmitHelpers(): ReadonlyMap<string, UnscopedEmitHelper>;
    /** @internal */
    function isCallToHelper(firstSegment: Expression, helperName: __String): boolean;
    /** @internal */
    enum PrivateIdentifierKind {
        Field = "f",
        Method = "m",
        Accessor = "a"
    }
    /**
     * Describes the decorator context object passed to a native ECMAScript decorator for a class.
     *
     * @internal
     */
    interface ESDecorateClassContext {
        /**
         * The kind of the decorated element.
         */
        kind: "class";
        /**
         * The name of the decorated element.
         */
        name: Expression;
    }
    /**
     * Describes the decorator context object passed to a native ECMAScript decorator for a class element.
     *
     * @internal
     */
    interface ESDecorateClassElementContext {
        /**
         * The kind of the decorated element.
         */
        kind: "method" | "getter" | "setter" | "accessor" | "field";
        name: ESDecorateName;
        static: boolean;
        private: boolean;
        access: ESDecorateClassElementAccess;
    }
    /** @internal */
    interface ESDecorateClassElementAccess {
        get?: boolean;
        set?: boolean;
    }
    /** @internal */
    type ESDecorateName = {
        computed: true;
        name: Expression;
    } | {
        computed: false;
        name: Identifier | PrivateIdentifier;
    };
    /** @internal */
    type ESDecorateContext = ESDecorateClassContext | ESDecorateClassElementContext;
    /** @internal */
    interface EmitHelperFactory {
        getUnscopedHelperName(name: string): Identifier;
        createDecorateHelper(decoratorExpressions: readonly Expression[], target: Expression, memberName?: Expression, descriptor?: Expression): Expression;
        createMetadataHelper(metadataKey: string, metadataValue: Expression): Expression;
        createParamHelper(expression: Expression, parameterOffset: number): Expression;
        createESDecorateHelper(ctor: Expression, descriptorIn: Expression, decorators: Expression, contextIn: ESDecorateContext, initializers: Expression, extraInitializers: Expression): Expression;
        createRunInitializersHelper(thisArg: Expression, initializers: Expression, value?: Expression): Expression;
        createAssignHelper(attributesSegments: readonly Expression[]): Expression;
        createAwaitHelper(expression: Expression): Expression;
        createAsyncGeneratorHelper(generatorFunc: FunctionExpression, hasLexicalThis: boolean): Expression;
        createAsyncDelegatorHelper(expression: Expression): Expression;
        createAsyncValuesHelper(expression: Expression): Expression;
        createRestHelper(value: Expression, elements: readonly BindingOrAssignmentElement[], computedTempVariables: readonly Expression[] | undefined, location: TextRange): Expression;
        createAwaiterHelper(hasLexicalThis: boolean, hasLexicalArguments: boolean, promiseConstructor: EntityName | Expression | undefined, body: Block): Expression;
        createExtendsHelper(name: Identifier): Expression;
        createTemplateObjectHelper(cooked: ArrayLiteralExpression, raw: ArrayLiteralExpression): Expression;
        createSpreadArrayHelper(to: Expression, from: Expression, packFrom: boolean): Expression;
        createPropKeyHelper(expr: Expression): Expression;
        createSetFunctionNameHelper(f: Expression, name: Expression, prefix?: string): Expression;
        createValuesHelper(expression: Expression): Expression;
        createReadHelper(iteratorRecord: Expression, count: number | undefined): Expression;
        createGeneratorHelper(body: FunctionExpression): Expression;
        createCreateBindingHelper(module: Expression, inputName: Expression, outputName: Expression | undefined): Expression;
        createImportStarHelper(expression: Expression): Expression;
        createImportStarCallbackHelper(): Expression;
        createImportDefaultHelper(expression: Expression): Expression;
        createExportStarHelper(moduleExpression: Expression, exportsExpression?: Expression): Expression;
        createClassPrivateFieldGetHelper(receiver: Expression, state: Identifier, kind: PrivateIdentifierKind, f: Identifier | undefined): Expression;
        createClassPrivateFieldSetHelper(receiver: Expression, state: Identifier, value: Expression, kind: PrivateIdentifierKind, f: Identifier | undefined): Expression;
        createClassPrivateFieldInHelper(state: Identifier, receiver: Expression): Expression;
    }
    /** @internal */
    const decorateHelper: UnscopedEmitHelper;
    /** @internal */
    const metadataHelper: UnscopedEmitHelper;
    /** @internal */
    const paramHelper: UnscopedEmitHelper;
    /** @internal */
    const esDecorateHelper: UnscopedEmitHelper;
    /** @internal */
    const runInitializersHelper: UnscopedEmitHelper;
    /** @internal */
    const assignHelper: UnscopedEmitHelper;
    /** @internal */
    const awaitHelper: UnscopedEmitHelper;
    /** @internal */
    const asyncGeneratorHelper: UnscopedEmitHelper;
    /** @internal */
    const asyncDelegator: UnscopedEmitHelper;
    /** @internal */
    const asyncValues: UnscopedEmitHelper;
    /** @internal */
    const restHelper: UnscopedEmitHelper;
    /** @internal */
    const awaiterHelper: UnscopedEmitHelper;
    /** @internal */
    const extendsHelper: UnscopedEmitHelper;
    /** @internal */
    const templateObjectHelper: UnscopedEmitHelper;
    /** @internal */
    const readHelper: UnscopedEmitHelper;
    /** @internal */
    const spreadArrayHelper: UnscopedEmitHelper;
    /** @internal */
    const propKeyHelper: UnscopedEmitHelper;
    /** @internal */
    const setFunctionNameHelper: UnscopedEmitHelper;
    /** @internal */
    const valuesHelper: UnscopedEmitHelper;
    /** @internal */
    const generatorHelper: UnscopedEmitHelper;
    /** @internal */
    const createBindingHelper: UnscopedEmitHelper;
    /** @internal */
    const setModuleDefaultHelper: UnscopedEmitHelper;
    /** @internal */
    const importStarHelper: UnscopedEmitHelper;
    /** @internal */
    const importDefaultHelper: UnscopedEmitHelper;
    /** @internal */
    const exportStarHelper: UnscopedEmitHelper;
    /**
     * Parameters:
     *  @param receiver — The object from which the private member will be read.
     *  @param state — One of the following:
     *      - A WeakMap used to read a private instance field.
     *      - A WeakSet used as an instance brand for private instance methods and accessors.
     *      - A function value that should be the undecorated class constructor used to brand check private static fields, methods, and accessors.
     *  @param kind — (optional pre TS 4.3, required for TS 4.3+) One of the following values:
     *      - undefined — Indicates a private instance field (pre TS 4.3).
     *      - "f" — Indicates a private field (instance or static).
     *      - "m" — Indicates a private method (instance or static).
     *      - "a" — Indicates a private accessor (instance or static).
     *  @param f — (optional pre TS 4.3) Depends on the arguments for state and kind:
     *      - If kind is "m", this should be the function corresponding to the static or instance method.
     *      - If kind is "a", this should be the function corresponding to the getter method, or undefined if the getter was not defined.
     *      - If kind is "f" and state is a function, this should be an object holding the value of a static field, or undefined if the static field declaration has not yet been evaluated.
     * Usage:
     * This helper will only ever be used by the compiler in the following ways:
     *
     * Reading from a private instance field (pre TS 4.3):
     *      __classPrivateFieldGet(<any>, <WeakMap>)
     *
     * Reading from a private instance field (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakMap>, "f")
     *
     * Reading from a private instance get accessor (when defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "a", <function>)
     *
     * Reading from a private instance get accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Reading from a private instance method (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "m", <function>)
     *
     * Reading from a private static field (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "f", <{ value: any }>)
     *
     * Reading from a private static get accessor (when defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "a", <function>)
     *
     * Reading from a private static get accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Reading from a private static method (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "m", <function>)
     *
     * @internal
     */
    const classPrivateFieldGetHelper: UnscopedEmitHelper;
    /**
     * Parameters:
     *  @param receiver — The object on which the private member will be set.
     *  @param state — One of the following:
     *      - A WeakMap used to store a private instance field.
     *      - A WeakSet used as an instance brand for private instance methods and accessors.
     *      - A function value that should be the undecorated class constructor used to brand check private static fields, methods, and accessors.
     *  @param value — The value to set.
     *  @param kind — (optional pre TS 4.3, required for TS 4.3+) One of the following values:
     *       - undefined — Indicates a private instance field (pre TS 4.3).
     *       - "f" — Indicates a private field (instance or static).
     *       - "m" — Indicates a private method (instance or static).
     *       - "a" — Indicates a private accessor (instance or static).
     *   @param f — (optional pre TS 4.3) Depends on the arguments for state and kind:
     *       - If kind is "m", this should be the function corresponding to the static or instance method.
     *       - If kind is "a", this should be the function corresponding to the setter method, or undefined if the setter was not defined.
     *       - If kind is "f" and state is a function, this should be an object holding the value of a static field, or undefined if the static field declaration has not yet been evaluated.
     * Usage:
     * This helper will only ever be used by the compiler in the following ways:
     *
     * Writing to a private instance field (pre TS 4.3):
     *      __classPrivateFieldSet(<any>, <WeakMap>, <any>)
     *
     * Writing to a private instance field (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakMap>, <any>, "f")
     *
     * Writing to a private instance set accessor (when defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "a", <function>)
     *
     * Writing to a private instance set accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private instance method (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "m", <function>)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private static field (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "f", <{ value: any }>)
     *
     * Writing to a private static set accessor (when defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "a", <function>)
     *
     * Writing to a private static set accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private static method (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "m", <function>)
     *      NOTE: This always results in a runtime error.
     *
     * @internal
     */
    const classPrivateFieldSetHelper: UnscopedEmitHelper;
    /**
     * Parameters:
     *  @param state — One of the following:
     *      - A WeakMap when the member is a private instance field.
     *      - A WeakSet when the member is a private instance method or accessor.
     *      - A function value that should be the undecorated class constructor when the member is a private static field, method, or accessor.
     *  @param receiver — The object being checked if it has the private member.
     *
     * Usage:
     * This helper is used to transform `#field in expression` to
     *      `__classPrivateFieldIn(<weakMap/weakSet/constructor>, expression)`
     *
     * @internal
     */
    const classPrivateFieldInHelper: UnscopedEmitHelper;
    /** @internal */
    const asyncSuperHelper: EmitHelper;
    /** @internal */
    const advancedAsyncSuperHelper: EmitHelper;
    function isNumericLiteral(node: Node): node is NumericLiteral;
    function isBigIntLiteral(node: Node): node is BigIntLiteral;
    function isStringLiteral(node: Node): node is StringLiteral;
    function isJsxText(node: Node): node is JsxText;
    function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;
    function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;
    function isTemplateHead(node: Node): node is TemplateHead;
    function isTemplateMiddle(node: Node): node is TemplateMiddle;
    function isTemplateTail(node: Node): node is TemplateTail;
    function isDotDotDotToken(node: Node): node is DotDotDotToken;
    /** @internal */
    function isCommaToken(node: Node): node is Token<SyntaxKind.CommaToken>;
    function isPlusToken(node: Node): node is PlusToken;
    function isMinusToken(node: Node): node is MinusToken;
    function isAsteriskToken(node: Node): node is AsteriskToken;
    function isExclamationToken(node: Node): node is ExclamationToken;
    function isQuestionToken(node: Node): node is QuestionToken;
    function isColonToken(node: Node): node is ColonToken;
    function isQuestionDotToken(node: Node): node is QuestionDotToken;
    function isEqualsGreaterThanToken(node: Node): node is EqualsGreaterThanToken;
    function isIdentifier(node: Node): node is Identifier;
    function isPrivateIdentifier(node: Node): node is PrivateIdentifier;
    /** @internal */
    function isExportModifier(node: Node): node is ExportKeyword;
    /** @internal */
    function isDefaultModifier(node: Node): node is DefaultKeyword;
    /** @internal */
    function isAsyncModifier(node: Node): node is AsyncKeyword;
    function isAssertsKeyword(node: Node): node is AssertsKeyword;
    function isAwaitKeyword(node: Node): node is AwaitKeyword;
    /** @internal */
    function isReadonlyKeyword(node: Node): node is ReadonlyKeyword;
    /** @internal */
    function isStaticModifier(node: Node): node is StaticKeyword;
    /** @internal */
    function isAbstractModifier(node: Node): node is AbstractKeyword;
    /** @internal */
    function isOverrideModifier(node: Node): node is OverrideKeyword;
    /** @internal */
    function isAccessorModifier(node: Node): node is AccessorKeyword;
    /** @internal */
    function isSuperKeyword(node: Node): node is SuperExpression;
    /** @internal */
    function isImportKeyword(node: Node): node is ImportExpression;
    /** @internal */
    function isCaseKeyword(node: Node): node is CaseKeyword;
    function isQualifiedName(node: Node): node is QualifiedName;
    function isComputedPropertyName(node: Node): node is ComputedPropertyName;
    function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;
    function isParameter(node: Node): node is ParameterDeclaration;
    function isDecorator(node: Node): node is Decorator;
    function isPropertySignature(node: Node): node is PropertySignature;
    function isPropertyDeclaration(node: Node): node is PropertyDeclaration;
    function isMethodSignature(node: Node): node is MethodSignature;
    function isMethodDeclaration(node: Node): node is MethodDeclaration;
    function isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;
    function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;
    function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;
    function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;
    function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;
    function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;
    function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;
    function isTypePredicateNode(node: Node): node is TypePredicateNode;
    function isTypeReferenceNode(node: Node): node is TypeReferenceNode;
    function isFunctionTypeNode(node: Node): node is FunctionTypeNode;
    function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;
    function isTypeQueryNode(node: Node): node is TypeQueryNode;
    function isTypeLiteralNode(node: Node): node is TypeLiteralNode;
    function isArrayTypeNode(node: Node): node is ArrayTypeNode;
    function isTupleTypeNode(node: Node): node is TupleTypeNode;
    function isNamedTupleMember(node: Node): node is NamedTupleMember;
    function isOptionalTypeNode(node: Node): node is OptionalTypeNode;
    function isRestTypeNode(node: Node): node is RestTypeNode;
    function isUnionTypeNode(node: Node): node is UnionTypeNode;
    function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;
    function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;
    function isInferTypeNode(node: Node): node is InferTypeNode;
    function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;
    function isThisTypeNode(node: Node): node is ThisTypeNode;
    function isTypeOperatorNode(node: Node): node is TypeOperatorNode;
    function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;
    function isMappedTypeNode(node: Node): node is MappedTypeNode;
    function isLiteralTypeNode(node: Node): node is LiteralTypeNode;
    function isImportTypeNode(node: Node): node is ImportTypeNode;
    function isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;
    function isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;
    function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;
    function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;
    function isBindingElement(node: Node): node is BindingElement;
    function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;
    function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;
    function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;
    function isElementAccessExpression(node: Node): node is ElementAccessExpression;
    function isCallExpression(node: Node): node is CallExpression;
    function isNewExpression(node: Node): node is NewExpression;
    function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;
    function isTypeAssertionExpression(node: Node): node is TypeAssertion;
    function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;
    function isFunctionExpression(node: Node): node is FunctionExpression;
    function isArrowFunction(node: Node): node is ArrowFunction;
    function isDeleteExpression(node: Node): node is DeleteExpression;
    function isTypeOfExpression(node: Node): node is TypeOfExpression;
    function isVoidExpression(node: Node): node is VoidExpression;
    function isAwaitExpression(node: Node): node is AwaitExpression;
    function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;
    function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;
    function isBinaryExpression(node: Node): node is BinaryExpression;
    function isConditionalExpression(node: Node): node is ConditionalExpression;
    function isTemplateExpression(node: Node): node is TemplateExpression;
    function isYieldExpression(node: Node): node is YieldExpression;
    function isSpreadElement(node: Node): node is SpreadElement;
    function isClassExpression(node: Node): node is ClassExpression;
    function isOmittedExpression(node: Node): node is OmittedExpression;
    function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;
    function isAsExpression(node: Node): node is AsExpression;
    function isSatisfiesExpression(node: Node): node is SatisfiesExpression;
    function isNonNullExpression(node: Node): node is NonNullExpression;
    function isMetaProperty(node: Node): node is MetaProperty;
    function isSyntheticExpression(node: Node): node is SyntheticExpression;
    function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;
    function isCommaListExpression(node: Node): node is CommaListExpression;
    function isTemplateSpan(node: Node): node is TemplateSpan;
    function isSemicolonClassElement(node: Node): node is SemicolonClassElement;
    function isBlock(node: Node): node is Block;
    function isVariableStatement(node: Node): node is VariableStatement;
    function isEmptyStatement(node: Node): node is EmptyStatement;
    function isExpressionStatement(node: Node): node is ExpressionStatement;
    function isIfStatement(node: Node): node is IfStatement;
    function isDoStatement(node: Node): node is DoStatement;
    function isWhileStatement(node: Node): node is WhileStatement;
    function isForStatement(node: Node): node is ForStatement;
    function isForInStatement(node: Node): node is ForInStatement;
    function isForOfStatement(node: Node): node is ForOfStatement;
    function isContinueStatement(node: Node): node is ContinueStatement;
    function isBreakStatement(node: Node): node is BreakStatement;
    function isReturnStatement(node: Node): node is ReturnStatement;
    function isWithStatement(node: Node): node is WithStatement;
    function isSwitchStatement(node: Node): node is SwitchStatement;
    function isLabeledStatement(node: Node): node is LabeledStatement;
    function isThrowStatement(node: Node): node is ThrowStatement;
    function isTryStatement(node: Node): node is TryStatement;
    function isDebuggerStatement(node: Node): node is DebuggerStatement;
    function isVariableDeclaration(node: Node): node is VariableDeclaration;
    function isVariableDeclarationList(node: Node): node is VariableDeclarationList;
    function isFunctionDeclaration(node: Node): node is FunctionDeclaration;
    function isClassDeclaration(node: Node): node is ClassDeclaration;
    function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;
    function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;
    function isEnumDeclaration(node: Node): node is EnumDeclaration;
    function isModuleDeclaration(node: Node): node is ModuleDeclaration;
    function isModuleBlock(node: Node): node is ModuleBlock;
    function isCaseBlock(node: Node): node is CaseBlock;
    function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;
    function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
    function isImportDeclaration(node: Node): node is ImportDeclaration;
    function isImportClause(node: Node): node is ImportClause;
    function isImportTypeAssertionContainer(node: Node): node is ImportTypeAssertionContainer;
    function isAssertClause(node: Node): node is AssertClause;
    function isAssertEntry(node: Node): node is AssertEntry;
    function isNamespaceImport(node: Node): node is NamespaceImport;
    function isNamespaceExport(node: Node): node is NamespaceExport;
    function isNamedImports(node: Node): node is NamedImports;
    function isImportSpecifier(node: Node): node is ImportSpecifier;
    function isExportAssignment(node: Node): node is ExportAssignment;
    function isExportDeclaration(node: Node): node is ExportDeclaration;
    function isNamedExports(node: Node): node is NamedExports;
    function isExportSpecifier(node: Node): node is ExportSpecifier;
    function isMissingDeclaration(node: Node): node is MissingDeclaration;
    function isNotEmittedStatement(node: Node): node is NotEmittedStatement;
    /** @internal */
    function isSyntheticReference(node: Node): node is SyntheticReferenceExpression;
    /** @internal */
    function isMergeDeclarationMarker(node: Node): node is MergeDeclarationMarker;
    /** @internal */
    function isEndOfDeclarationMarker(node: Node): node is EndOfDeclarationMarker;
    function isExternalModuleReference(node: Node): node is ExternalModuleReference;
    function isJsxElement(node: Node): node is JsxElement;
    function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;
    function isJsxOpeningElement(node: Node): node is JsxOpeningElement;
    function isJsxClosingElement(node: Node): node is JsxClosingElement;
    function isJsxFragment(node: Node): node is JsxFragment;
    function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;
    function isJsxClosingFragment(node: Node): node is JsxClosingFragment;
    function isJsxAttribute(node: Node): node is JsxAttribute;
    function isJsxAttributes(node: Node): node is JsxAttributes;
    function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;
    function isJsxExpression(node: Node): node is JsxExpression;
    function isCaseClause(node: Node): node is CaseClause;
    function isDefaultClause(node: Node): node is DefaultClause;
    function isHeritageClause(node: Node): node is HeritageClause;
    function isCatchClause(node: Node): node is CatchClause;
    function isPropertyAssignment(node: Node): node is PropertyAssignment;
    function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;
    function isSpreadAssignment(node: Node): node is SpreadAssignment;
    function isEnumMember(node: Node): node is EnumMember;
    /** @deprecated */
    function isUnparsedPrepend(node: Node): node is UnparsedPrepend;
    function isSourceFile(node: Node): node is SourceFile;
    function isBundle(node: Node): node is Bundle;
    /** @deprecated */
    function isUnparsedSource(node: Node): node is UnparsedSource;
    function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;
    function isJSDocNameReference(node: Node): node is JSDocNameReference;
    function isJSDocMemberName(node: Node): node is JSDocMemberName;
    function isJSDocLink(node: Node): node is JSDocLink;
    function isJSDocLinkCode(node: Node): node is JSDocLinkCode;
    function isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;
    function isJSDocAllType(node: Node): node is JSDocAllType;
    function isJSDocUnknownType(node: Node): node is JSDocUnknownType;
    function isJSDocNullableType(node: Node): node is JSDocNullableType;
    function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;
    function isJSDocOptionalType(node: Node): node is JSDocOptionalType;
    function isJSDocFunctionType(node: Node): node is JSDocFunctionType;
    function isJSDocVariadicType(node: Node): node is JSDocVariadicType;
    function isJSDocNamepathType(node: Node): node is JSDocNamepathType;
    function isJSDoc(node: Node): node is JSDoc;
    function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;
    function isJSDocSignature(node: Node): node is JSDocSignature;
    function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;
    function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;
    function isJSDocClassTag(node: Node): node is JSDocClassTag;
    function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;
    function isJSDocPublicTag(node: Node): node is JSDocPublicTag;
    function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;
    function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;
    function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;
    function isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;
    function isJSDocOverloadTag(node: Node): node is JSDocOverloadTag;
    function isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;
    function isJSDocSeeTag(node: Node): node is JSDocSeeTag;
    function isJSDocEnumTag(node: Node): node is JSDocEnumTag;
    function isJSDocParameterTag(node: Node): node is JSDocParameterTag;
    function isJSDocReturnTag(node: Node): node is JSDocReturnTag;
    function isJSDocThisTag(node: Node): node is JSDocThisTag;
    function isJSDocTypeTag(node: Node): node is JSDocTypeTag;
    function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;
    function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;
    function isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;
    function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;
    function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;
    function isJSDocSatisfiesTag(node: Node): node is JSDocSatisfiesTag;
    function isJSDocThrowsTag(node: Node): node is JSDocThrowsTag;
    /** @internal */
    function isSyntaxList(n: Node): n is SyntaxList;
    /** @internal */
    function createEmptyExports(factory: NodeFactory): ExportDeclaration;
    /** @internal */
    function createMemberAccessForPropertyName(factory: NodeFactory, target: Expression, memberName: PropertyName, location?: TextRange): MemberExpression;
    /** @internal */
    function createJsxFactoryExpression(factory: NodeFactory, jsxFactoryEntity: EntityName | undefined, reactNamespace: string, parent: JsxOpeningLikeElement | JsxOpeningFragment): Expression;
    /** @internal */
    function createExpressionForJsxElement(factory: NodeFactory, callee: Expression, tagName: Expression, props: Expression | undefined, children: readonly Expression[] | undefined, location: TextRange): LeftHandSideExpression;
    /** @internal */
    function createExpressionForJsxFragment(factory: NodeFactory, jsxFactoryEntity: EntityName | undefined, jsxFragmentFactoryEntity: EntityName | undefined, reactNamespace: string, children: readonly Expression[], parentElement: JsxOpeningFragment, location: TextRange): LeftHandSideExpression;
    /** @internal */
    function createForOfBindingStatement(factory: NodeFactory, node: ForInitializer, boundValue: Expression): Statement;
    /** @internal */
    function insertLeadingStatement(factory: NodeFactory, dest: Statement, source: Statement): Block;
    /** @internal */
    function createExpressionFromEntityName(factory: NodeFactory, node: EntityName | Expression): Expression;
    /** @internal */
    function createExpressionForPropertyName(factory: NodeFactory, memberName: Exclude<PropertyName, PrivateIdentifier>): Expression;
    /** @internal */
    function createExpressionForObjectLiteralElementLike(factory: NodeFactory, node: ObjectLiteralExpression, property: ObjectLiteralElementLike, receiver: Expression): Expression | undefined;
    /**
     * Expand the read and increment/decrement operations a pre- or post-increment or pre- or post-decrement expression.
     *
     * ```ts
     * // input
     * <expression>++
     * // output (if result is not discarded)
     * var <temp>;
     * (<temp> = <expression>, <resultVariable> = <temp>++, <temp>)
     * // output (if result is discarded)
     * var <temp>;
     * (<temp> = <expression>, <temp>++, <temp>)
     *
     * // input
     * ++<expression>
     * // output (if result is not discarded)
     * var <temp>;
     * (<temp> = <expression>, <resultVariable> = ++<temp>)
     * // output (if result is discarded)
     * var <temp>;
     * (<temp> = <expression>, ++<temp>)
     * ```
     *
     * It is up to the caller to supply a temporary variable for `<resultVariable>` if one is needed.
     * The temporary variable `<temp>` is injected so that `++` and `--` work uniformly with `number` and `bigint`.
     * The result of the expression is always the final result of incrementing or decrementing the expression, so that it can be used for storage.
     *
     * @param factory {@link NodeFactory} used to create the expanded representation.
     * @param node The original prefix or postfix unary node.
     * @param expression The expression to use as the value to increment or decrement
     * @param resultVariable A temporary variable in which to store the result. Pass `undefined` if the result is discarded, or if the value of `<temp>` is the expected result.
     *
     * @internal
     */
    function expandPreOrPostfixIncrementOrDecrementExpression(factory: NodeFactory, node: PrefixUnaryExpression | PostfixUnaryExpression, expression: Expression, recordTempVariable: (node: Identifier) => void, resultVariable: Identifier | undefined): Expression;
    /**
     * Gets whether an identifier should only be referred to by its internal name.
     *
     * @internal
     */
    function isInternalName(node: Identifier): boolean;
    /**
     * Gets whether an identifier should only be referred to by its local name.
     *
     * @internal
     */
    function isLocalName(node: Identifier): boolean;
    /**
     * Gets whether an identifier should only be referred to by its export representation if the
     * name points to an exported symbol.
     *
     * @internal
     */
    function isExportName(node: Identifier): boolean;
    /** @internal */
    function findUseStrictPrologue(statements: readonly Statement[]): Statement | undefined;
    /** @internal */
    function startsWithUseStrict(statements: readonly Statement[]): boolean;
    /** @internal */
    function isCommaExpression(node: Expression): node is BinaryExpression & {
        operatorToken: Token<SyntaxKind.CommaToken>;
    };
    /** @internal */
    function isCommaSequence(node: Expression): node is BinaryExpression & {
        operatorToken: Token<SyntaxKind.CommaToken>;
    } | CommaListExpression;
    /** @internal */
    function isJSDocTypeAssertion(node: Node): node is JSDocTypeAssertion;
    /** @internal */
    function getJSDocTypeAssertionType(node: JSDocTypeAssertion): TypeNode;
    /** @internal */
    function isOuterExpression(node: Node, kinds?: OuterExpressionKinds): node is OuterExpression;
    /** @internal */
    function skipOuterExpressions(node: Expression, kinds?: OuterExpressionKinds): Expression;
    /** @internal */
    function skipOuterExpressions(node: Node, kinds?: OuterExpressionKinds): Node;
    /** @internal */
    function walkUpOuterExpressions(node: Expression, kinds?: OuterExpressionKinds): Node;
    /** @internal */
    function skipAssertions(node: Expression): Expression;
    /** @internal */
    function skipAssertions(node: Node): Node;
    /** @internal */
    function startOnNewLine<T extends Node>(node: T): T;
    /** @internal */
    function getExternalHelpersModuleName(node: SourceFile): Identifier | undefined;
    /** @internal */
    function hasRecordedExternalHelpers(sourceFile: SourceFile): boolean;
    /** @internal */
    function createExternalHelpersImportDeclarationIfNeeded(nodeFactory: NodeFactory, helperFactory: EmitHelperFactory, sourceFile: SourceFile, compilerOptions: CompilerOptions, hasExportStarsToExportValues?: boolean, hasImportStar?: boolean, hasImportDefault?: boolean): ImportDeclaration | undefined;
    /** @internal */
    function getOrCreateExternalHelpersModuleNameIfNeeded(factory: NodeFactory, node: SourceFile, compilerOptions: CompilerOptions, hasExportStarsToExportValues?: boolean, hasImportStarOrImportDefault?: boolean): Identifier | undefined;
    /**
     * Get the name of that target module from an import or export declaration
     *
     * @internal
     */
    function getLocalNameForExternalImport(factory: NodeFactory, node: ImportDeclaration | ExportDeclaration | ImportEqualsDeclaration, sourceFile: SourceFile): Identifier | undefined;
    /**
     * Get the name of a target module from an import/export declaration as should be written in the emitted output.
     * The emitted output name can be different from the input if:
     *  1. The module has a /// <amd-module name="<new name>" />
     *  2. --out or --outFile is used, making the name relative to the rootDir
     *  3- The containing SourceFile has an entry in renamedDependencies for the import as requested by some module loaders (e.g. System).
     * Otherwise, a new StringLiteral node representing the module name will be returned.
     *
     * @internal
     */
    function getExternalModuleNameLiteral(factory: NodeFactory, importNode: ImportDeclaration | ExportDeclaration | ImportEqualsDeclaration | ImportCall, sourceFile: SourceFile, host: EmitHost, resolver: EmitResolver, compilerOptions: CompilerOptions): StringLiteral | undefined;
    /**
     * Get the name of a module as should be written in the emitted output.
     * The emitted output name can be different from the input if:
     *  1. The module has a /// <amd-module name="<new name>" />
     *  2. --out or --outFile is used, making the name relative to the rootDir
     * Otherwise, a new StringLiteral node representing the module name will be returned.
     *
     * @internal
     */
    function tryGetModuleNameFromFile(factory: NodeFactory, file: SourceFile | undefined, host: EmitHost, options: CompilerOptions): StringLiteral | undefined;
    /**
     * Gets the initializer of an BindingOrAssignmentElement.
     *
     * @internal
     */
    function getInitializerOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): Expression | undefined;
    /**
     * Gets the name of an BindingOrAssignmentElement.
     *
     * @internal
     */
    function getTargetOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): BindingOrAssignmentElementTarget | undefined;
    /**
     * Determines whether an BindingOrAssignmentElement is a rest element.
     *
     * @internal
     */
    function getRestIndicatorOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): BindingOrAssignmentElementRestIndicator | undefined;
    /**
     * Gets the property name of a BindingOrAssignmentElement
     *
     * @internal
     */
    function getPropertyNameOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): Exclude<PropertyName, PrivateIdentifier> | undefined;
    /** @internal */
    function tryGetPropertyNameOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): Exclude<PropertyName, PrivateIdentifier> | undefined;
    /**
     * Gets the elements of a BindingOrAssignmentPattern
     *
     * @internal
     */
    function getElementsOfBindingOrAssignmentPattern(name: BindingOrAssignmentPattern): readonly BindingOrAssignmentElement[];
    /** @internal */
    function getJSDocTypeAliasName(fullName: JSDocNamespaceBody | undefined): Identifier | undefined;
    /** @internal */
    function canHaveIllegalType(node: Node): node is HasIllegalType;
    /** @internal */
    function canHaveIllegalTypeParameters(node: Node): node is HasIllegalTypeParameters;
    /** @internal */
    function canHaveIllegalDecorators(node: Node): node is HasIllegalDecorators;
    /** @internal */
    function canHaveIllegalModifiers(node: Node): node is HasIllegalModifiers;
    function isQuestionOrExclamationToken(node: Node): node is QuestionToken | ExclamationToken;
    function isIdentifierOrThisTypeNode(node: Node): node is Identifier | ThisTypeNode;
    function isReadonlyKeywordOrPlusOrMinusToken(node: Node): node is ReadonlyKeyword | PlusToken | MinusToken;
    function isQuestionOrPlusOrMinusToken(node: Node): node is QuestionToken | PlusToken | MinusToken;
    function isModuleName(node: Node): node is ModuleName;
    /** @internal */
    function isLiteralTypeLikeExpression(node: Node): node is NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;
    function isBinaryOperatorToken(node: Node): node is BinaryOperatorToken;
    /**
     * Creates a state machine that walks a `BinaryExpression` using the heap to reduce call-stack depth on a large tree.
     * @param onEnter Callback evaluated when entering a `BinaryExpression`. Returns new user-defined state to associate with the node while walking.
     * @param onLeft Callback evaluated when walking the left side of a `BinaryExpression`. Return a `BinaryExpression` to continue walking, or `void` to advance to the right side.
     * @param onRight Callback evaluated when walking the right side of a `BinaryExpression`. Return a `BinaryExpression` to continue walking, or `void` to advance to the end of the node.
     * @param onExit Callback evaluated when exiting a `BinaryExpression`. The result returned will either be folded into the parent's state, or returned from the walker if at the top frame.
     * @param foldState Callback evaluated when the result from a nested `onExit` should be folded into the state of that node's parent.
     * @returns A function that walks a `BinaryExpression` node using the above callbacks, returning the result of the call to `onExit` from the outermost `BinaryExpression` node.
     *
     * @internal
     */
    function createBinaryExpressionTrampoline<TState, TResult>(onEnter: (node: BinaryExpression, prev: TState | undefined) => TState, onLeft: ((left: Expression, userState: TState, node: BinaryExpression) => BinaryExpression | void) | undefined, onOperator: ((operatorToken: BinaryOperatorToken, userState: TState, node: BinaryExpression) => void) | undefined, onRight: ((right: Expression, userState: TState, node: BinaryExpression) => BinaryExpression | void) | undefined, onExit: (node: BinaryExpression, userState: TState) => TResult, foldState: ((userState: TState, result: TResult, side: "left" | "right") => TState) | undefined): (node: BinaryExpression) => TResult;
    /**
     * Creates a state machine that walks a `BinaryExpression` using the heap to reduce call-stack depth on a large tree.
     * @param onEnter Callback evaluated when entering a `BinaryExpression`. Returns new user-defined state to associate with the node while walking.
     * @param onLeft Callback evaluated when walking the left side of a `BinaryExpression`. Return a `BinaryExpression` to continue walking, or `void` to advance to the right side.
     * @param onRight Callback evaluated when walking the right side of a `BinaryExpression`. Return a `BinaryExpression` to continue walking, or `void` to advance to the end of the node.
     * @param onExit Callback evaluated when exiting a `BinaryExpression`. The result returned will either be folded into the parent's state, or returned from the walker if at the top frame.
     * @param foldState Callback evaluated when the result from a nested `onExit` should be folded into the state of that node's parent.
     * @returns A function that walks a `BinaryExpression` node using the above callbacks, returning the result of the call to `onExit` from the outermost `BinaryExpression` node.
     *
     * @internal
     */
    function createBinaryExpressionTrampoline<TOuterState, TState, TResult>(onEnter: (node: BinaryExpression, prev: TState | undefined, outerState: TOuterState) => TState, onLeft: ((left: Expression, userState: TState, node: BinaryExpression) => BinaryExpression | void) | undefined, onOperator: ((operatorToken: BinaryOperatorToken, userState: TState, node: BinaryExpression) => void) | undefined, onRight: ((right: Expression, userState: TState, node: BinaryExpression) => BinaryExpression | void) | undefined, onExit: (node: BinaryExpression, userState: TState) => TResult, foldState: ((userState: TState, result: TResult, side: "left" | "right") => TState) | undefined): (node: BinaryExpression, outerState: TOuterState) => TResult;
    /** @internal */
    function isExportOrDefaultModifier(node: Node): node is ExportKeyword | DefaultKeyword;
    /** @internal */
    function isNonExportDefaultModifier(node: Node): node is Exclude<Modifier, ExportKeyword | DefaultKeyword>;
    /**
     * If `nodes` is not undefined, creates an empty `NodeArray` that preserves the `pos` and `end` of `nodes`.
     * @internal
     */
    function elideNodes<T extends Node>(factory: NodeFactory, nodes: NodeArray<T>): NodeArray<T>;
    /** @internal */
    function elideNodes<T extends Node>(factory: NodeFactory, nodes: NodeArray<T> | undefined): NodeArray<T> | undefined;
    /**
     * Gets the node from which a name should be generated.
     *
     * @internal
     */
    function getNodeForGeneratedName(name: GeneratedIdentifier | GeneratedPrivateIdentifier): Node | GeneratedIdentifier | GeneratedPrivateIdentifier;
    /**
     * Formats a prefix or suffix of a generated name.
     *
     * @internal
     */
    function formatGeneratedNamePart(part: string | undefined): string;
    /**
     * Formats a prefix or suffix of a generated name. If the part is a {@link GeneratedNamePart}, calls {@link generateName} to format the source node.
     *
     * @internal
     */
    function formatGeneratedNamePart(part: string | GeneratedNamePart | undefined, generateName: (name: GeneratedIdentifier | GeneratedPrivateIdentifier) => string): string;
    /**
     * Formats a generated name.
     * @param privateName When `true`, inserts a `#` character at the start of the result.
     * @param prefix The prefix (if any) to include before the base name.
     * @param baseName The base name for the generated name.
     * @param suffix The suffix (if any) to include after the base name.
     *
     * @internal
     */
    function formatGeneratedName(privateName: boolean, prefix: string | undefined, baseName: string, suffix: string | undefined): string;
    /**
     * Formats a generated name.
     * @param privateName When `true`, inserts a `#` character at the start of the result.
     * @param prefix The prefix (if any) to include before the base name.
     * @param baseName The base name for the generated name.
     * @param suffix The suffix (if any) to include after the base name.
     * @param generateName Called to format the source node of {@link prefix} when it is a {@link GeneratedNamePart}.
     *
     * @internal
     */
    function formatGeneratedName(privateName: boolean, prefix: string | GeneratedNamePart | undefined, baseName: string | Identifier | PrivateIdentifier, suffix: string | GeneratedNamePart | undefined, generateName: (name: GeneratedIdentifier | GeneratedPrivateIdentifier) => string): string;
    /**
     * Creates a private backing field for an `accessor` {@link PropertyDeclaration}.
     *
     * @internal
     */
    function createAccessorPropertyBackingField(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, initializer: Expression | undefined): PropertyDeclaration;
    /**
     * Creates a {@link GetAccessorDeclaration} that reads from a private backing field.
     *
     * @internal
     */
    function createAccessorPropertyGetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName): GetAccessorDeclaration;
    /**
     * Creates a {@link SetAccessorDeclaration} that writes to a private backing field.
     *
     * @internal
     */
    function createAccessorPropertySetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName): SetAccessorDeclaration;
    /** @internal */
    function findComputedPropertyNameCacheAssignment(name: ComputedPropertyName): (AssignmentExpression<EqualsToken> & {
        readonly left: GeneratedIdentifier;
    }) | undefined;
    /**
     * Flatten a CommaExpression or CommaListExpression into an array of one or more expressions, unwrapping any nested
     * comma expressions and synthetic parens.
     *
     * @internal
     */
    function flattenCommaList(node: Expression): Expression[];
    /**
     * Walk an AssignmentPattern to determine if it contains object rest (`...`) syntax. We cannot rely on
     * propagation of `TransformFlags.ContainsObjectRestOrSpread` since it isn't propagated by default in
     * ObjectLiteralExpression and ArrayLiteralExpression since we do not know whether they belong to an
     * AssignmentPattern at the time the nodes are parsed.
     *
     * @internal
     */
    function containsObjectRestOrSpread(node: AssignmentPattern): boolean;
    function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;
    function canHaveModifiers(node: Node): node is HasModifiers;
    function canHaveDecorators(node: Node): node is HasDecorators;
    /** @internal */
    function isJSDocLikeText(text: string, start: number): boolean;
    /** @internal */
    function isFileProbablyExternalModule(sourceFile: SourceFile): ts.Node | undefined;
    /**
     * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
     * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
     * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
     *
     * @param node a given node to visit its children
     * @param cbNode a callback to be invoked for all child nodes
     * @param cbNodes a callback to be invoked for embedded array
     *
     * @remarks `forEachChild` must visit the children of a node in the order
     * that they appear in the source code. The language service depends on this property to locate nodes by position.
     */
    function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
    /**
     * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; additionally,
     * unlike `forEachChild`, embedded arrays are flattened and the 'cbNode' callback is invoked for each element.
     *  If a callback returns a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
     *
     * @param node a given node to visit its children
     * @param cbNode a callback to be invoked for all child nodes
     * @param cbNodes a callback to be invoked for embedded array
     *
     * @remarks Unlike `forEachChild`, `forEachChildRecursively` handles recursively invoking the traversal on each child node found,
     * and while doing so, handles traversing the structure without relying on the callstack to encode the tree structure.
     *
     * @internal
     */
    function forEachChildRecursively<T>(rootNode: Node, cbNode: (node: Node, parent: Node) => T | "skip" | undefined, cbNodes?: (nodes: NodeArray<Node>, parent: Node) => T | "skip" | undefined): T | undefined;
    function createSourceFile(fileName: string, sourceText: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;
    function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;
    /**
     * Parse json text into SyntaxTree and return node and parse errors if any
     * @param fileName
     * @param sourceText
     */
    function parseJsonText(fileName: string, sourceText: string): JsonSourceFile;
    function isExternalModule(file: SourceFile): boolean;
    function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
    /** @internal */
    function parseIsolatedJSDocComment(content: string, start?: number, length?: number): {
        jsDoc: ts.JSDoc;
        diagnostics: ts.Diagnostic[];
    } | undefined;
    /** @internal */
    function parseJSDocTypeExpressionForTests(content: string, start?: number, length?: number): {
        jsDocTypeExpression: ts.JSDocTypeExpression;
        diagnostics: ts.Diagnostic[];
    } | undefined;
    /** @internal */
    function isDeclarationFileName(fileName: string): boolean;
    /** @internal */
    function processCommentPragmas(context: PragmaContext, sourceText: string): void;
    /** @internal */
    function processPragmasIntoFields(context: PragmaContext, reportDiagnostic: PragmaDiagnosticReporter): void;
    /** @internal */
    function tagNamesAreEquivalent(lhs: JsxTagNameExpression, rhs: JsxTagNameExpression): boolean;
    /**
     * NOTE: You should not use this, it is only exported to support `createNode` in `~/src/deprecatedCompat/deprecations.ts`.
     *
     * @internal
     */
    const parseBaseNodeFactory: BaseNodeFactory;
    /** @internal */
    const parseNodeFactory: ts.NodeFactory;
    interface CreateSourceFileOptions {
        languageVersion: ScriptTarget;
        /**
         * Controls the format the file is detected as - this can be derived from only the path
         * and files on disk, but needs to be done with a module resolution cache in scope to be performant.
         * This is usually `undefined` for compilations that do not have `moduleResolution` values of `node16` or `nodenext`.
         */
        impliedNodeFormat?: ResolutionMode;
        /**
         * Controls how module-y-ness is set for the given file. Usually the result of calling
         * `getSetExternalModuleIndicator` on a valid `CompilerOptions` object. If not present, the default
         * check specified by `isFileProbablyExternalModule` will be used to set the field.
         */
        setExternalModuleIndicator?: (file: SourceFile) => void;
        /** @internal */ packageJsonLocations?: readonly string[];
        /** @internal */ packageJsonScope?: PackageJsonInfo;
    }
    /** @internal */
    type PragmaDiagnosticReporter = (pos: number, length: number, message: DiagnosticMessage) => void;
    /** @internal */
    function createOptionNameMap(optionDeclarations: readonly CommandLineOption[]): OptionsNameMap;
    /** @internal */
    function getOptionsNameMap(): OptionsNameMap;
    /** @internal */
    function createCompilerDiagnosticForInvalidCustomType(opt: CommandLineOptionOfCustomType): Diagnostic;
    /** @internal */
    function parseCustomTypeOption(opt: CommandLineOptionOfCustomType, value: string, errors: Push<Diagnostic>): string | number | undefined;
    /** @internal */
    function parseListTypeOption(opt: CommandLineOptionOfListType, value: string | undefined, errors: Push<Diagnostic>): string | (string | number)[] | undefined;
    /** @internal */
    function parseCommandLineWorker(diagnostics: ParseCommandLineWorkerDiagnostics, commandLine: readonly string[], readFile?: (path: string) => string | undefined): {
        options: OptionsBase;
        watchOptions: WatchOptions | undefined;
        fileNames: string[];
        errors: Diagnostic[];
    };
    function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;
    /** @internal */
    function getOptionFromName(optionName: string, allowShort?: boolean): CommandLineOption | undefined;
    /** @internal */
    function parseBuildCommand(args: readonly string[]): ParsedBuildCommand;
    /** @internal */
    function getDiagnosticText(_message: DiagnosticMessage, ..._args: any[]): string;
    /**
     * Reads the config file, reports errors if any and exits if the config file cannot be found
     */
    function getParsedCommandLineOfConfigFile(configFileName: string, optionsToExtend: CompilerOptions | undefined, host: ParseConfigFileHost, extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): ParsedCommandLine | undefined;
    /**
     * Read tsconfig.json file
     * @param fileName The path to the config file
     */
    function readConfigFile(fileName: string, readFile: (path: string) => string | undefined): {
        config?: any;
        error?: Diagnostic;
    };
    /**
     * Parse the text of the tsconfig.json file
     * @param fileName The path to the config file
     * @param jsonText The text of the config file
     */
    function parseConfigFileTextToJson(fileName: string, jsonText: string): {
        config?: any;
        error?: Diagnostic;
    };
    /**
     * Read tsconfig.json file
     * @param fileName The path to the config file
     */
    function readJsonConfigFile(fileName: string, readFile: (path: string) => string | undefined): TsConfigSourceFile;
    /** @internal */
    function tryReadFile(fileName: string, readFile: (path: string) => string | undefined): string | Diagnostic;
    /**
     * Convert the json syntax tree into the json value
     */
    function convertToObject(sourceFile: JsonSourceFile, errors: Diagnostic[]): any;
    /**
     * Convert the json syntax tree into the json value and report errors
     * This returns the json value (apart from checking errors) only if returnValue provided is true.
     * Otherwise it just checks the errors and returns undefined
     *
     * @internal
     */
    function convertToObjectWorker(sourceFile: JsonSourceFile, rootExpression: Expression | undefined, errors: Push<Diagnostic>, returnValue: boolean, knownRootOptions: CommandLineOption | undefined, jsonConversionNotifier: JsonConversionNotifier | undefined): any;
    /**
     * Generate an uncommented, complete tsconfig for use with "--showConfig"
     * @param configParseResult options to be generated into tsconfig.json
     * @param configFileName name of the parsed config file - output paths will be generated relative to this
     * @param host provides current directory and case sensitivity services
     *
     * @internal
     */
    function convertToTSConfig(configParseResult: ParsedCommandLine, configFileName: string, host: ConvertToTSConfigHost): TSConfig;
    /** @internal */
    function optionMapToObject(optionMap: Map<string, CompilerOptionsValue>): object;
    /** @internal */
    function getNameOfCompilerOptionValue(value: CompilerOptionsValue, customTypeMap: Map<string, string | number>): string | undefined;
    /** @internal */
    function serializeCompilerOptions(options: CompilerOptions, pathOptions?: {
        configFilePath: string;
        useCaseSensitiveFileNames: boolean;
    }): Map<string, CompilerOptionsValue>;
    /**
     * Generate a list of the compiler options whose value is not the default.
     * @param options compilerOptions to be evaluated.
    /** @internal */
    function getCompilerOptionsDiffValue(options: CompilerOptions, newLine: string): string;
    /**
     * Generate tsconfig configuration when running command line "--init"
     * @param options commandlineOptions to be generated into tsconfig.json
     * @param fileNames array of filenames to be generated into tsconfig.json
     *
     * @internal
     */
    function generateTSConfig(options: CompilerOptions, fileNames: readonly string[], newLine: string): string;
    /** @internal */
    function convertToOptionsWithAbsolutePaths(options: CompilerOptions, toAbsolutePath: (path: string) => string): CompilerOptions;
    /**
     * Parse the contents of a config file (tsconfig.json).
     * @param json The contents of the config file to parse
     * @param host Instance of ParseConfigHost used to enumerate files in folder.
     * @param basePath A root directory to resolve relative path entries in the config
     *    file to. e.g. outDir
     */
    function parseJsonConfigFileContent(json: any, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;
    /**
     * Parse the contents of a config file (tsconfig.json).
     * @param jsonNode The contents of the config file to parse
     * @param host Instance of ParseConfigHost used to enumerate files in folder.
     * @param basePath A root directory to resolve relative path entries in the config
     *    file to. e.g. outDir
     */
    function parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;
    /** @internal */
    function setConfigFileInOptions(options: CompilerOptions, configFile: TsConfigSourceFile | undefined): void;
    /** @internal */
    function canJsonReportNoInputFiles(raw: any): boolean;
    /** @internal */
    function updateErrorForNoInputFiles(fileNames: string[], configFileName: string, configFileSpecs: ConfigFileSpecs, configParseDiagnostics: Diagnostic[], canJsonReportNoInutFiles: boolean): boolean;
    function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
        options: CompilerOptions;
        errors: Diagnostic[];
    };
    function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
        options: TypeAcquisition;
        errors: Diagnostic[];
    };
    /** @internal */
    function convertJsonOption(opt: CommandLineOption, value: any, basePath: string, errors: Push<Diagnostic>): CompilerOptionsValue;
    /**
     * Gets the file names from the provided config file specs that contain, files, include, exclude and
     * other properties needed to resolve the file names
     * @param configFileSpecs The config file specs extracted with file names to include, wildcards to include/exclude and other details
     * @param basePath The base path for any relative file specifications.
     * @param options Compiler options.
     * @param host The host used to resolve files and directories.
     * @param extraFileExtensions optionaly file extra file extension information from host
     *
     * @internal
     */
    function getFileNamesFromConfigSpecs(configFileSpecs: ConfigFileSpecs, basePath: string, options: CompilerOptions, host: ParseConfigHost, extraFileExtensions?: readonly FileExtensionInfo[]): string[];
    /** @internal */
    function isExcludedFile(pathToCheck: string, spec: ConfigFileSpecs, basePath: string, useCaseSensitiveFileNames: boolean, currentDirectory: string): boolean;
    /** @internal */
    function matchesExclude(pathToCheck: string, excludeSpecs: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string): boolean;
    /**
     * Produces a cleaned version of compiler options with personally identifying info (aka, paths) removed.
     * Also converts enum values back to strings.
     *
     * @internal
     */
    function convertCompilerOptionsForTelemetry(opts: CompilerOptions): CompilerOptions;
    /** @internal */
    const compileOnSaveCommandLineOption: CommandLineOption;
    /** @internal */
    const inverseJsxOptionMap: Map<string, string>;
    /**
     * An array of supported "lib" reference file names used to determine the order for inclusion
     * when referenced, as well as for spelling suggestions. This ensures the correct ordering for
     * overload resolution when a type declared in one lib is extended by another.
     *
     * @internal
     */
    const libs: string[];
    /**
     * A map of lib names to lib files. This map is used both for parsing the "lib" command line
     * option as well as for resolving lib reference directives.
     *
     * @internal
     */
    const libMap: Map<string, string>;
    /** @internal */
    const optionsForWatch: CommandLineOption[];
    /** @internal */
    const commonOptionsWithBuild: CommandLineOption[];
    /** @internal */
    const targetOptionDeclaration: CommandLineOptionOfCustomType;
    /** @internal */
    const moduleOptionDeclaration: CommandLineOptionOfCustomType;
    /** @internal */
    const optionDeclarations: CommandLineOption[];
    /** @internal */
    const semanticDiagnosticsOptionDeclarations: readonly CommandLineOption[];
    /** @internal */
    const affectsEmitOptionDeclarations: readonly CommandLineOption[];
    /** @internal */
    const affectsDeclarationPathOptionDeclarations: readonly CommandLineOption[];
    /** @internal */
    const moduleResolutionOptionDeclarations: readonly CommandLineOption[];
    /** @internal */
    const sourceFileAffectingCompilerOptions: readonly CommandLineOption[];
    /** @internal */
    const optionsAffectingProgramStructure: readonly CommandLineOption[];
    /** @internal */
    const transpileOptionValueCompilerOptions: readonly CommandLineOption[];
    /** @internal */
    const optionsForBuild: CommandLineOption[];
    /** @internal */
    const buildOpts: CommandLineOption[];
    /** @internal */
    const typeAcquisitionDeclarations: CommandLineOption[];
    /** @internal */
    interface OptionsNameMap {
        optionsNameMap: Map<string, CommandLineOption>;
        shortOptionNames: Map<string, string>;
    }
    /** @internal */
    const defaultInitCompilerOptions: CompilerOptions;
    /** @internal */
    interface OptionsBase {
        [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;
    }
    /** @internal */
    interface ParseCommandLineWorkerDiagnostics extends DidYouMeanOptionsDiagnostics {
        getOptionsNameMap: () => OptionsNameMap;
        optionTypeMismatchDiagnostic: DiagnosticMessage;
    }
    /** @internal */
    const compilerOptionsDidYouMeanDiagnostics: ParseCommandLineWorkerDiagnostics;
    /** @internal */
    interface ParsedBuildCommand {
        buildOptions: BuildOptions;
        watchOptions: WatchOptions | undefined;
        projects: string[];
        errors: Diagnostic[];
    }
    type DiagnosticReporter = (diagnostic: Diagnostic) => void;
    /**
     * Reports config file diagnostics
     */
    interface ConfigFileDiagnosticsReporter {
        /**
         * Reports unrecoverable error when parsing config file
         */
        onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;
    }
    /**
     * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors
     */
    interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {
        getCurrentDirectory(): string;
    }
    /** @internal */
    interface JsonConversionNotifier {
        /**
         * Notifies parent option object is being set with the optionKey and a valid optionValue
         * Currently it notifies only if there is element with type object (parentOption) and
         * has element's option declarations map associated with it
         * @param parentOption parent option name in which the option and value are being set
         * @param option option declaration which is being set with the value
         * @param value value of the option
         */
        onSetValidOptionKeyValueInParent(parentOption: string, option: CommandLineOption, value: CompilerOptionsValue): void;
        /**
         * Notify when valid root key value option is being set
         * @param key option key
         * @param keyNode node corresponding to node in the source file
         * @param value computed value of the key
         * @param ValueNode node corresponding to value in the source file
         */
        onSetValidOptionKeyValueInRoot(key: string, keyNode: PropertyName, value: CompilerOptionsValue, valueNode: Expression): void;
        /**
         * Notify when unknown root key value option is being set
         * @param key option key
         * @param keyNode node corresponding to node in the source file
         * @param value computed value of the key
         * @param ValueNode node corresponding to value in the source file
         */
        onSetUnknownOptionKeyValueInRoot(key: string, keyNode: PropertyName, value: CompilerOptionsValue, valueNode: Expression): void;
    }
    /** @internal */
    interface TSConfig {
        compilerOptions: CompilerOptions;
        compileOnSave: boolean | undefined;
        exclude?: readonly string[];
        files: readonly string[] | undefined;
        include?: readonly string[];
        references: readonly ProjectReference[] | undefined;
    }
    /** @internal */
    interface ConvertToTSConfigHost {
        getCurrentDirectory(): string;
        useCaseSensitiveFileNames: boolean;
    }
    /** @internal */
    const defaultIncludeSpec = "**/*";
    interface ParsedTsconfig {
        raw: any;
        options?: CompilerOptions;
        watchOptions?: WatchOptions;
        typeAcquisition?: TypeAcquisition;
        /**
         * Note that the case of the config path has not yet been normalized, as no files have been imported into the project yet
         */
        extendedConfigPath?: string | string[];
    }
    interface ExtendedConfigCacheEntry {
        extendedResult: TsConfigSourceFile;
        extendedConfig: ParsedTsconfig | undefined;
    }
    /** @internal */
    function trace(host: ModuleResolutionHost, message: DiagnosticMessage, ...args: any[]): void;
    /** @internal */
    function isTraceEnabled(compilerOptions: CompilerOptions, host: ModuleResolutionHost): boolean;
    /** @internal */
    function updateResolutionField<T>(to: T[] | undefined, value: T[] | undefined): T[] | undefined;
    /** @internal */
    function getPackageJsonTypesVersionsPaths(typesVersions: MapLike<MapLike<string[]>>): {
        version: string;
        paths: MapLike<string[]>;
    } | undefined;
    function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined;
    /**
     * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
     * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups
     * is assumed to be the same as root directory of the project.
     */
    function resolveTypeReferenceDirective(typeReferenceDirectiveName: string, containingFile: string | undefined, options: CompilerOptions, host: ModuleResolutionHost, redirectedReference?: ResolvedProjectReference, cache?: TypeReferenceDirectiveResolutionCache, resolutionMode?: ResolutionMode): ResolvedTypeReferenceDirectiveWithFailedLookupLocations;
    /** @internal */
    function getConditions(options: CompilerOptions, esmMode?: boolean): string[];
    /**
     * @internal
     * Does not try `@types/${packageName}` - use a second pass if needed.
     */
    function resolvePackageNameToPackageJson(packageName: string, containingDirectory: string, options: CompilerOptions, host: ModuleResolutionHost, cache: ModuleResolutionCache | undefined): PackageJsonInfo | undefined;
    /**
     * Given a set of options, returns the set of type directive names
     *   that should be included for this program automatically.
     * This list could either come from the config file,
     *   or from enumerating the types root + initial secondary types lookup location.
     * More type directives might appear in the program later as a result of loading actual source files;
     *   this list is only the set of defaults that are implicitly included.
     */
    function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[];
    /** @internal */
    function getKeyForCompilerOptions(options: CompilerOptions, affectingOptionDeclarations: readonly CommandLineOption[]): string;
    /** @internal */
    function createCacheWithRedirects<K, V>(ownOptions: CompilerOptions | undefined): CacheWithRedirects<K, V>;
    /** @internal */
    function createModeAwareCacheKey(specifier: string, mode: ResolutionMode): ModeAwareCacheKey;
    /** @internal */
    function createModeAwareCache<T>(): ModeAwareCache<T>;
    /** @internal */
    function zipToModeAwareCache<K, V>(file: SourceFile, keys: readonly K[], values: readonly V[], nameAndModeGetter: ResolutionNameAndModeGetter<K, SourceFile>): ModeAwareCache<V>;
    function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions): ModuleResolutionCache;
    function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;
    function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;
    function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations;
    /**
     * Expose resolution logic to allow us to use Node module resolution logic from arbitrary locations.
     * No way to do this with `require()`: https://github.com/nodejs/node/issues/5963
     * Throws an error if the module can't be resolved.
     *
     * @internal
     */
    function resolveJSModule(moduleName: string, initialDir: string, host: ModuleResolutionHost): string;
    function bundlerModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
    function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
    /** @internal */ function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, lookupConfig?: boolean): ResolvedModuleWithFailedLookupLocations;
    /** @internal */
    function nodeNextJsonConfigResolver(moduleName: string, containingFile: string, host: ModuleResolutionHost): ResolvedModuleWithFailedLookupLocations;
    /** @internal */
    function pathContainsNodeModules(path: string): boolean;
    /**
     * This will be called on the successfully resolved path from `loadModuleFromFile`.
     * (Not needed for `loadModuleFromNodeModules` as that looks up the `package.json` as part of resolution.)
     *
     * packageDirectory is the directory of the package itself.
     *   For `blah/node_modules/foo/index.d.ts` this is packageDirectory: "foo"
     *   For `/node_modules/foo/bar.d.ts` this is packageDirectory: "foo"
     *   For `/node_modules/@types/foo/bar/index.d.ts` this is packageDirectory: "@types/foo"
     *   For `/node_modules/foo/bar/index.d.ts` this is packageDirectory: "foo"
     *
     * @internal
     */
    function parseNodeModuleFromPath(resolved: string): string | undefined;
    /** @internal */
    function getEntrypointsFromPackageJsonInfo(packageJsonInfo: PackageJsonInfo, options: CompilerOptions, host: ModuleResolutionHost, cache: ModuleResolutionCache | undefined, resolveJs?: boolean): string[] | false;
    /** @internal */
    function getTemporaryModuleResolutionState(packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ModuleResolutionState;
    /**
     * A function for locating the package.json scope for a given path
     *
     * @internal
     */
    function getPackageScopeForPath(fileName: string, state: ModuleResolutionState): PackageJsonInfo | undefined;
    /** @internal */
    function getPackageJsonInfo(packageDirectory: string, onlyRecordFailures: boolean, state: ModuleResolutionState): PackageJsonInfo | undefined;
    /** @internal */
    function parsePackageName(moduleName: string): {
        packageName: string;
        rest: string;
    };
    /** @internal */
    function allKeysStartWithDot(obj: MapLike<unknown>): boolean;
    /**
     * @internal
     * From https://github.com/nodejs/node/blob/8f39f51cbbd3b2de14b9ee896e26421cc5b20121/lib/internal/modules/esm/resolve.js#L722 -
     * "longest" has some nuance as to what "longest" means in the presence of pattern trailers
     */
    function comparePatternKeys(a: string, b: string): 1 | -1 | 0;
    /** @internal */
    function isApplicableVersionedTypesKey(conditions: readonly string[], key: string): boolean;
    /** @internal */
    function getTypesPackageName(packageName: string): string;
    /** @internal */
    function mangleScopedPackageName(packageName: string): string;
    /** @internal */
    function getPackageNameFromTypesPackageName(mangledName: string): string;
    /** @internal */
    function unmangleScopedPackageName(typesPackageName: string): string;
    function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
    /** @internal */
    function shouldAllowImportingTsExtension(compilerOptions: CompilerOptions, fromFileName?: string): boolean | "" | undefined;
    /**
     * A host may load a module from a global cache of typings.
     * This is the minumum code needed to expose that functionality; the rest is in the host.
     *
     * @internal
     */
    function loadModuleFromGlobalCache(moduleName: string, projectName: string | undefined, compilerOptions: CompilerOptions, host: ModuleResolutionHost, globalCache: string, packageJsonInfoCache: PackageJsonInfoCache): ResolvedModuleWithFailedLookupLocations;
    /** @internal */
    interface ModuleResolutionState {
        host: ModuleResolutionHost;
        compilerOptions: CompilerOptions;
        traceEnabled: boolean;
        failedLookupLocations: Push<string>;
        affectingLocations: Push<string>;
        resultFromCache?: ResolvedModuleWithFailedLookupLocations;
        packageJsonInfoCache: PackageJsonInfoCache | undefined;
        features: NodeResolutionFeatures;
        conditions: readonly string[];
        requestContainingDirectory: string | undefined;
        reportDiagnostic: DiagnosticReporter;
        isConfigLookup: boolean;
        candidateIsFromPackageJsonField: boolean;
    }
    /** Just the fields that we use for module resolution.
     *
     * @internal
     */
    interface PackageJsonPathFields {
        typings?: string;
        types?: string;
        typesVersions?: MapLike<MapLike<string[]>>;
        main?: string;
        tsconfig?: string;
        type?: string;
        imports?: object;
        exports?: object;
        name?: string;
    }
    /** @internal */
    interface VersionPaths {
        version: string;
        paths: MapLike<string[]>;
    }
    interface TypeReferenceDirectiveResolutionCache extends PerDirectoryResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, NonRelativeNameResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, PackageJsonInfoCache {
        /** @internal */ clearAllExceptPackageJsonInfoCache(): void;
    }
    interface ModeAwareCache<T> {
        get(key: string, mode: ResolutionMode): T | undefined;
        set(key: string, mode: ResolutionMode, value: T): this;
        delete(key: string, mode: ResolutionMode): this;
        has(key: string, mode: ResolutionMode): boolean;
        forEach(cb: (elem: T, key: string, mode: ResolutionMode) => void): void;
        size(): number;
    }
    /**
     * Cached resolutions per containing directory.
     * This assumes that any module id will have the same resolution for sibling files located in the same folder.
     */
    interface PerDirectoryResolutionCache<T> {
        getFromDirectoryCache(name: string, mode: ResolutionMode, directoryName: string, redirectedReference: ResolvedProjectReference | undefined): T | undefined;
        getOrCreateCacheForDirectory(directoryName: string, redirectedReference?: ResolvedProjectReference): ModeAwareCache<T>;
        clear(): void;
        /**
         *  Updates with the current compilerOptions the cache will operate with.
         *  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects
         */
        update(options: CompilerOptions): void;
    }
    interface NonRelativeNameResolutionCache<T> {
        getFromNonRelativeNameCache(nonRelativeName: string, mode: ResolutionMode, directoryName: string, redirectedReference: ResolvedProjectReference | undefined): T | undefined;
        getOrCreateCacheForNonRelativeName(nonRelativeName: string, mode: ResolutionMode, redirectedReference?: ResolvedProjectReference): PerNonRelativeNameCache<T>;
        clear(): void;
        /**
         *  Updates with the current compilerOptions the cache will operate with.
         *  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects
         */
        update(options: CompilerOptions): void;
    }
    interface PerNonRelativeNameCache<T> {
        get(directory: string): T | undefined;
        set(directory: string, result: T): void;
    }
    interface ModuleResolutionCache extends PerDirectoryResolutionCache<ResolvedModuleWithFailedLookupLocations>, NonRelativeModuleNameResolutionCache, PackageJsonInfoCache {
        getPackageJsonInfoCache(): PackageJsonInfoCache;
        /** @internal */ clearAllExceptPackageJsonInfoCache(): void;
    }
    /**
     * Stored map from non-relative module name to a table: directory -> result of module lookup in this directory
     * We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.
     */
    interface NonRelativeModuleNameResolutionCache extends NonRelativeNameResolutionCache<ResolvedModuleWithFailedLookupLocations>, PackageJsonInfoCache {
        /** @deprecated Use getOrCreateCacheForNonRelativeName */
        getOrCreateCacheForModuleName(nonRelativeModuleName: string, mode: ResolutionMode, redirectedReference?: ResolvedProjectReference): PerModuleNameCache;
    }
    interface PackageJsonInfoCache {
        /** @internal */ getPackageJsonInfo(packageJsonPath: string): PackageJsonInfo | boolean | undefined;
        /** @internal */ setPackageJsonInfo(packageJsonPath: string, info: PackageJsonInfo | boolean): void;
        /** @internal */ entries(): [
            Path,
            PackageJsonInfo | boolean
        ][];
        /** @internal */ getInternalMap(): Map<Path, PackageJsonInfo | boolean> | undefined;
        clear(): void;
    }
    type PerModuleNameCache = PerNonRelativeNameCache<ResolvedModuleWithFailedLookupLocations>;
    /** @internal */
    interface CacheWithRedirects<K, V> {
        getMapOfCacheRedirects(redirectedReference: ResolvedProjectReference | undefined): Map<K, V> | undefined;
        getOrCreateMapOfCacheRedirects(redirectedReference: ResolvedProjectReference | undefined): Map<K, V>;
        update(newOptions: CompilerOptions): void;
        clear(): void;
    }
    /** @internal */
    type ModeAwareCacheKey = string & {
        __modeAwareCacheKey: any;
    };
    /** @internal */
    enum NodeResolutionFeatures {
        None = 0,
        Imports = 2,
        SelfName = 4,
        Exports = 8,
        ExportsPatternTrailers = 16,
        AllFeatures = 30,
        Node16Default = 30,
        NodeNextDefault = 30,
        BundlerDefault = 30,
        EsmMode = 32
    }
    /** @internal */
    const nodeModulesPathPart = "/node_modules/";
    /** @internal */
    interface PackageJsonInfo {
        packageDirectory: string;
        contents: PackageJsonInfoContents;
    }
    /** @internal */
    interface PackageJsonInfoContents {
        packageJsonContent: PackageJsonPathFields;
        /** false: versionPaths are not present. undefined: not yet resolved */
        versionPaths: VersionPaths | false | undefined;
        /** false: resolved to nothing. undefined: not yet resolved */
        resolvedEntrypoints: string[] | false | undefined;
    }
    /** @internal */
    function getModuleInstanceState(node: ModuleDeclaration, visited?: Map<number, ModuleInstanceState | undefined>): ModuleInstanceState;
    /** @internal */
    function bindSourceFile(file: SourceFile, options: CompilerOptions): void;
    /** @internal */
    function isExportsOrModuleExportsOrAlias(sourceFile: SourceFile, node: Expression): boolean;
    /** @internal */
    enum ModuleInstanceState {
        NonInstantiated = 0,
        Instantiated = 1,
        ConstEnumOnly = 2
    }
    /** @internal */
    function createGetSymbolWalker(getRestTypeOfSignature: (sig: Signature) => Type, getTypePredicateOfSignature: (sig: Signature) => TypePredicate | undefined, getReturnTypeOfSignature: (sig: Signature) => Type, getBaseTypes: (type: InterfaceType) => BaseType[], resolveStructuredTypeMembers: (type: ObjectType) => ResolvedType, getTypeOfSymbol: (sym: Symbol) => Type, getResolvedSymbol: (node: Identifier) => Symbol, getConstraintOfTypeParameter: (typeParameter: TypeParameter) => Type | undefined, getFirstIdentifier: (node: EntityNameOrEntityNameExpression) => Identifier, getTypeArguments: (type: TypeReference) => readonly Type[]): (accept?: (symbol: Symbol) => boolean) => SymbolWalker;
    /** @internal */
    function getNodeId(node: Node): number;
    /** @internal */
    function getSymbolId(symbol: Symbol): SymbolId;
    /** @internal */
    function isInstantiatedModule(node: ModuleDeclaration, preserveConstEnums: boolean): boolean;
    /** @internal */
    function createTypeChecker(host: TypeCheckerHost): TypeChecker;
    /** @internal */
    function signatureHasRestParameter(s: Signature): boolean;
    /** @internal */
    function signatureHasLiteralTypes(s: Signature): boolean;
    /** @internal */
    enum TypeFacts {
        None = 0,
        TypeofEQString = 1,
        TypeofEQNumber = 2,
        TypeofEQBigInt = 4,
        TypeofEQBoolean = 8,
        TypeofEQSymbol = 16,
        TypeofEQObject = 32,
        TypeofEQFunction = 64,
        TypeofEQHostObject = 128,
        TypeofNEString = 256,
        TypeofNENumber = 512,
        TypeofNEBigInt = 1024,
        TypeofNEBoolean = 2048,
        TypeofNESymbol = 4096,
        TypeofNEObject = 8192,
        TypeofNEFunction = 16384,
        TypeofNEHostObject = 32768,
        EQUndefined = 65536,
        EQNull = 131072,
        EQUndefinedOrNull = 262144,
        NEUndefined = 524288,
        NENull = 1048576,
        NEUndefinedOrNull = 2097152,
        Truthy = 4194304,
        Falsy = 8388608,
        IsUndefined = 16777216,
        IsNull = 33554432,
        IsUndefinedOrNull = 50331648,
        All = 134217727,
        BaseStringStrictFacts = 3735041,
        BaseStringFacts = 12582401,
        StringStrictFacts = 16317953,
        StringFacts = 16776705,
        EmptyStringStrictFacts = 12123649,
        EmptyStringFacts = 12582401,
        NonEmptyStringStrictFacts = 7929345,
        NonEmptyStringFacts = 16776705,
        BaseNumberStrictFacts = 3734786,
        BaseNumberFacts = 12582146,
        NumberStrictFacts = 16317698,
        NumberFacts = 16776450,
        ZeroNumberStrictFacts = 12123394,
        ZeroNumberFacts = 12582146,
        NonZeroNumberStrictFacts = 7929090,
        NonZeroNumberFacts = 16776450,
        BaseBigIntStrictFacts = 3734276,
        BaseBigIntFacts = 12581636,
        BigIntStrictFacts = 16317188,
        BigIntFacts = 16775940,
        ZeroBigIntStrictFacts = 12122884,
        ZeroBigIntFacts = 12581636,
        NonZeroBigIntStrictFacts = 7928580,
        NonZeroBigIntFacts = 16775940,
        BaseBooleanStrictFacts = 3733256,
        BaseBooleanFacts = 12580616,
        BooleanStrictFacts = 16316168,
        BooleanFacts = 16774920,
        FalseStrictFacts = 12121864,
        FalseFacts = 12580616,
        TrueStrictFacts = 7927560,
        TrueFacts = 16774920,
        SymbolStrictFacts = 7925520,
        SymbolFacts = 16772880,
        ObjectStrictFacts = 7888800,
        ObjectFacts = 16736160,
        FunctionStrictFacts = 7880640,
        FunctionFacts = 16728000,
        VoidFacts = 9830144,
        UndefinedFacts = 26607360,
        NullFacts = 42917664,
        EmptyObjectStrictFacts = 83427327,
        EmptyObjectFacts = 83886079,
        UnknownFacts = 83886079,
        AllTypeofNE = 556800,
        OrFactsMask = 8256,
        AndFactsMask = 134209471
    }
    /** @internal */
    enum CheckMode {
        Normal = 0,
        Contextual = 1,
        Inferential = 2,
        SkipContextSensitive = 4,
        SkipGenericFunctions = 8,
        IsForSignatureHelp = 16,
        IsForStringLiteralArgumentCompletions = 32,
        RestBindingElement = 64
    }
    /** @internal */
    enum SignatureCheckMode {
        None = 0,
        BivariantCallback = 1,
        StrictCallback = 2,
        IgnoreReturnTypes = 4,
        StrictArity = 8,
        StrictTopSignature = 16,
        Callback = 3
    }
    /**
     * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
     *
     * - If the input node is undefined, then the output is undefined.
     * - If the visitor returns undefined, then the output is undefined.
     * - If the output node is not undefined, then it will satisfy the test function.
     * - In order to obtain a return type that is more specific than `Node`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * @param node The Node to visit.
     * @param visitor The callback used to visit the Node.
     * @param test A callback to execute to verify the Node is valid.
     * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
     */
    function visitNode<TIn extends Node | undefined, TVisited extends Node | undefined, TOut extends Node>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test: (node: Node) => node is TOut, lift?: (node: readonly Node[]) => Node): TOut | (TIn & undefined) | (TVisited & undefined);
    /**
     * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
     *
     * - If the input node is undefined, then the output is undefined.
     * - If the visitor returns undefined, then the output is undefined.
     * - If the output node is not undefined, then it will satisfy the test function.
     * - In order to obtain a return type that is more specific than `Node`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * @param node The Node to visit.
     * @param visitor The callback used to visit the Node.
     * @param test A callback to execute to verify the Node is valid.
     * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
     */
    function visitNode<TIn extends Node | undefined, TVisited extends Node | undefined>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => Node): Node | (TIn & undefined) | (TVisited & undefined);
    /**
     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
     *
     * - If the input node array is undefined, the output is undefined.
     * - If the visitor can return undefined, the node it visits in the array will be reused.
     * - If the output node array is not undefined, then its contents will satisfy the test.
     * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * @param nodes The NodeArray to visit.
     * @param visitor The callback used to visit a Node.
     * @param test A node test to execute for each node.
     * @param start An optional value indicating the starting offset at which to start visiting.
     * @param count An optional value indicating the maximum number of nodes to visit.
     */
    function visitNodes<TIn extends Node, TInArray extends NodeArray<TIn> | undefined, TOut extends Node>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test: (node: Node) => node is TOut, start?: number, count?: number): NodeArray<TOut> | (TInArray & undefined);
    /**
     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
     *
     * - If the input node array is undefined, the output is undefined.
     * - If the visitor can return undefined, the node it visits in the array will be reused.
     * - If the output node array is not undefined, then its contents will satisfy the test.
     * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * @param nodes The NodeArray to visit.
     * @param visitor The callback used to visit a Node.
     * @param test A node test to execute for each node.
     * @param start An optional value indicating the starting offset at which to start visiting.
     * @param count An optional value indicating the maximum number of nodes to visit.
     */
    function visitNodes<TIn extends Node, TInArray extends NodeArray<TIn> | undefined>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<Node> | (TInArray & undefined);
    /** @internal */
    function visitArray<TIn extends Node, TInArray extends readonly TIn[] | undefined, TOut extends Node>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test: (node: Node) => node is TOut, start?: number, count?: number): readonly TOut[] | (TInArray & undefined);
    /** @internal */
    function visitArray<TIn extends Node, TInArray extends readonly TIn[] | undefined>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test?: (node: Node) => boolean, start?: number, count?: number): readonly Node[] | (TInArray & undefined);
    /**
     * Starts a new lexical environment and visits a statement list, ending the lexical environment
     * and merging hoisted declarations upon completion.
     */
    function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray<Statement>;
    /**
     * Starts a new lexical environment and visits a parameter list, suspending the lexical
     * environment upon completion.
     */
    function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration>;
    function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration> | undefined;
    /**
     * Resumes a suspended lexical environment and visits a function body, ending the lexical
     * environment and merging hoisted declarations upon completion.
     */
    function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;
    /**
     * Resumes a suspended lexical environment and visits a function body, ending the lexical
     * environment and merging hoisted declarations upon completion.
     */
    function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;
    /**
     * Resumes a suspended lexical environment and visits a concise body, ending the lexical
     * environment and merging hoisted declarations upon completion.
     */
    function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;
    /** @internal */ function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext, nodeVisitor?: NodeVisitor): FunctionBody;
    /** @internal */ function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext, nodeVisitor?: NodeVisitor): FunctionBody | undefined;
    /** @internal */ function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext, nodeVisitor?: NodeVisitor): ConciseBody;
    /**
     * Visits an iteration body, adding any block-scoped variables required by the transformation.
     */
    function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;
    /** @internal */
    function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext, nodeVisitor?: NodeVisitor): Statement;
    /**
     * Visits the elements of a {@link CommaListExpression}.
     * @param visitor The visitor to use when visiting expressions whose result will not be discarded at runtime.
     * @param discardVisitor The visitor to use when visiting expressions whose result will be discarded at runtime. Defaults to {@link visitor}.
     */
    function visitCommaListElements(elements: NodeArray<Expression>, visitor: Visitor, discardVisitor?: Visitor): NodeArray<Expression>;
    /**
     * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
     *
     * @param node The Node whose children will be visited.
     * @param visitor The callback used to visit each child.
     * @param context A lexical environment context for the visitor.
     */
    function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext): T;
    /** @internal */
    function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor, tokenVisitor?: Visitor, nodeVisitor?: NodeVisitor): T;
    /**
     * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
     *
     * @param node The Node whose children will be visited.
     * @param visitor The callback used to visit each child.
     * @param context A lexical environment context for the visitor.
     */
    function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
    /** @internal */
    function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor, tokenVisitor?: Visitor, nodeVisitor?: NodeVisitor): T | undefined;
    /** @internal */
    function createSourceMapGenerator(host: EmitHost, file: string, sourceRoot: string, sourcesDirectoryPath: string, generatorOptions: SourceMapGeneratorOptions): SourceMapGenerator;
    /** @internal */
    function getLineInfo(text: string, lineStarts: readonly number[]): LineInfo;
    /**
     * Tries to find the sourceMappingURL comment at the end of a file.
     *
     * @internal
     */
    function tryGetSourceMappingURL(lineInfo: LineInfo): string | undefined;
    /** @internal */
    function isRawSourceMap(x: any): x is RawSourceMap;
    /** @internal */
    function tryParseRawSourceMap(text: string): RawSourceMap | undefined;
    /** @internal */
    function decodeMappings(mappings: string): MappingsDecoder;
    /** @internal */
    function sameMapping<T extends Mapping>(left: T, right: T): boolean;
    /** @internal */
    function isSourceMapping(mapping: Mapping): mapping is SourceMapping;
    /** @internal */
    function createDocumentPositionMapper(host: DocumentPositionMapperHost, map: RawSourceMap, mapPath: string): DocumentPositionMapper;
    /** @internal */
    interface SourceMapGeneratorOptions {
        extendedDiagnostics?: boolean;
    }
    /** @internal */
    const sourceMapCommentRegExpDontCareLineStart: RegExp;
    /** @internal */
    const sourceMapCommentRegExp: RegExp;
    /** @internal */
    const whitespaceOrMapCommentRegExp: RegExp;
    /** @internal */
    interface LineInfo {
        getLineCount(): number;
        getLineText(line: number): string;
    }
    /** @internal */
    interface MappingsDecoder extends IterableIterator<Mapping> {
        readonly pos: number;
        readonly error: string | undefined;
        readonly state: Required<Mapping>;
    }
    /** @internal */
    interface Mapping {
        generatedLine: number;
        generatedCharacter: number;
        sourceIndex?: number;
        sourceLine?: number;
        sourceCharacter?: number;
        nameIndex?: number;
    }
    /** @internal */
    interface SourceMapping extends Mapping {
        sourceIndex: number;
        sourceLine: number;
        sourceCharacter: number;
    }
    /** @internal */
    const identitySourceMapConsumer: DocumentPositionMapper;
    function reorderSourceFiles(program: Program): SortingResult;
    interface SortingResult {
        sortedFileNames: string[];
        circularReferences: string[];
    }
    /** @internal */
    function getOriginalNodeId(node: Node): number;
    /** @internal */
    function chainBundle(context: CoreTransformationContext, transformSourceFile: (x: SourceFile) => SourceFile): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function getExportNeedsImportStarHelper(node: ExportDeclaration): boolean;
    /** @internal */
    function getImportNeedsImportStarHelper(node: ImportDeclaration): boolean;
    /** @internal */
    function getImportNeedsImportDefaultHelper(node: ImportDeclaration): boolean;
    /** @internal */
    function collectExternalModuleInfo(context: TransformationContext, sourceFile: SourceFile, resolver: EmitResolver, compilerOptions: CompilerOptions): ExternalModuleInfo;
    /**
     * Used in the module transformer to check if an expression is reasonably without sideeffect,
     *  and thus better to copy into multiple places rather than to cache in a temporary variable
     *  - this is mostly subjective beyond the requirement that the expression not be sideeffecting
     *
     * @internal
     */
    function isSimpleCopiableExpression(expression: Expression): boolean;
    /**
     * A simple inlinable expression is an expression which can be copied into multiple locations
     * without risk of repeating any sideeffects and whose value could not possibly change between
     * any such locations
     *
     * @internal
     */
    function isSimpleInlineableExpression(expression: Expression): boolean;
    /** @internal */
    function isCompoundAssignment(kind: BinaryOperator): kind is CompoundAssignmentOperator;
    /** @internal */
    function getNonAssignmentOperatorForCompoundAssignment(kind: CompoundAssignmentOperator): LogicalOperatorOrHigher | SyntaxKind.QuestionQuestionToken;
    /**
     * @returns Contained super() call from descending into the statement ignoring parentheses, if that call exists.
     *
     * @internal
     */
    function getSuperCallFromStatement(statement: Statement): SuperCall | undefined;
    /**
     * @returns The index (after prologue statements) of a super call, or -1 if not found.
     *
     * @internal
     */
    function findSuperStatementIndex(statements: NodeArray<Statement>, indexAfterLastPrologueStatement: number): number;
    /**
     * Gets all the static or all the instance property declarations of a class
     *
     * @param node The class node.
     * @param isStatic A value indicating whether to get properties from the static or instance side of the class.
     *
     * @internal
     */
    function getProperties(node: ClassExpression | ClassDeclaration, requireInitializer: true, isStatic: boolean): readonly InitializedPropertyDeclaration[];
    /** @internal */
    function getProperties(node: ClassExpression | ClassDeclaration, requireInitializer: boolean, isStatic: boolean): readonly PropertyDeclaration[];
    /** @internal */
    function getStaticPropertiesAndClassStaticBlock(node: ClassExpression | ClassDeclaration): readonly (PropertyDeclaration | ClassStaticBlockDeclaration)[];
    /** @internal */
    function getStaticPropertiesAndClassStaticBlock(node: ClassExpression | ClassDeclaration): readonly (PropertyDeclaration | ClassStaticBlockDeclaration)[];
    /**
     * Gets a value indicating whether a class element is either a static or an instance property declaration with an initializer.
     *
     * @param member The class element node.
     * @param isStatic A value indicating whether the member should be a static or instance member.
     *
     * @internal
     */
    function isInitializedProperty(member: ClassElement): member is PropertyDeclaration & {
        initializer: Expression;
    };
    /**
     * Gets a value indicating whether a class element is a private instance method or accessor.
     *
     * @param member The class element node.
     *
     * @internal
     */
    function isNonStaticMethodOrAccessorWithPrivateName(member: ClassElement): member is PrivateIdentifierMethodDeclaration | PrivateIdentifierAccessorDeclaration | PrivateIdentifierAutoAccessorPropertyDeclaration;
    /**
     * Gets an AllDecorators object containing the decorators for the class and the decorators for the
     * parameters of the constructor of the class.
     *
     * @param node The class node.
     *
     * @internal
     */
    function getAllDecoratorsOfClass(node: ClassLikeDeclaration): AllDecorators | undefined;
    /**
     * Gets an AllDecorators object containing the decorators for the member and its parameters.
     *
     * @param parent The class node that contains the member.
     * @param member The class member.
     *
     * @internal
     */
    function getAllDecoratorsOfClassElement(member: ClassElement, parent: ClassLikeDeclaration, useLegacyDecorators: boolean): AllDecorators | undefined;
    /** @internal */
    function walkUpLexicalEnvironments<TEnvData, TPrivateEnvData, TPrivateEntry, U>(env: LexicalEnvironment<TEnvData, TPrivateEnvData, TPrivateEntry> | undefined, cb: (env: LexicalEnvironment<TEnvData, TPrivateEnvData, TPrivateEntry>) => U): U | undefined;
    /** @internal */
    function newPrivateEnvironment<TData, TEntry>(data: TData): PrivateEnvironment<TData, TEntry>;
    /** @internal */
    function getPrivateIdentifier<TData, TEntry>(privateEnv: PrivateEnvironment<TData, TEntry> | undefined, name: PrivateIdentifier): TEntry | undefined;
    /** @internal */
    function setPrivateIdentifier<TData, TEntry>(privateEnv: PrivateEnvironment<TData, TEntry>, name: PrivateIdentifier, entry: TEntry): void;
    /** @internal */
    function accessPrivateIdentifier<TEnvData, TPrivateEnvData, TPrivateEntry>(env: LexicalEnvironment<TEnvData, TPrivateEnvData, TPrivateEntry> | undefined, name: PrivateIdentifier): TPrivateEntry | undefined;
    /** @internal */
    interface ExternalModuleInfo {
        externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];
        externalHelpersImportDeclaration: ImportDeclaration | undefined;
        exportSpecifiers: Map<string, ExportSpecifier[]>;
        exportedBindings: Identifier[][];
        exportedNames: Identifier[] | undefined;
        exportEquals: ExportAssignment | undefined;
        hasExportStarsToExportValues: boolean;
    }
    /** @internal */
    interface PrivateEnvironment<TData, TEntry> {
        readonly data: TData;
        /**
         * A mapping of private names to information needed for transformation.
         */
        identifiers?: UnderscoreEscapedMap<TEntry>;
        /**
         * A mapping of generated private names to information needed for transformation.
         */
        generatedIdentifiers?: Map<Node, TEntry>;
    }
    /** @internal */
    interface LexicalEnvironment<in out TEnvData, TPrivateEnvData, TPrivateEntry> {
        data: TEnvData;
        privateEnv?: PrivateEnvironment<TPrivateEnvData, TPrivateEntry>;
        readonly previous: LexicalEnvironment<TEnvData, TPrivateEnvData, TPrivateEntry> | undefined;
    }
    /**
     * Flattens a DestructuringAssignment or a VariableDeclaration to an expression.
     *
     * @param node The node to flatten.
     * @param visitor An optional visitor used to visit initializers.
     * @param context The transformation context.
     * @param level Indicates the extent to which flattening should occur.
     * @param needsValue An optional value indicating whether the value from the right-hand-side of
     * the destructuring assignment is needed as part of a larger expression.
     * @param createAssignmentCallback An optional callback used to create the assignment expression.
     *
     * @internal
     */
    function flattenDestructuringAssignment(node: VariableDeclaration | DestructuringAssignment, visitor: ((node: Node) => VisitResult<Node | undefined>), context: TransformationContext, level: FlattenLevel, needsValue?: boolean, createAssignmentCallback?: (name: Identifier, value: Expression, location?: TextRange) => Expression): Expression;
    /**
     * Flattens a VariableDeclaration or ParameterDeclaration to one or more variable declarations.
     *
     * @param node The node to flatten.
     * @param visitor An optional visitor used to visit initializers.
     * @param context The transformation context.
     * @param boundValue The value bound to the declaration.
     * @param skipInitializer A value indicating whether to ignore the initializer of `node`.
     * @param hoistTempVariables Indicates whether temporary variables should not be recorded in-line.
     * @param level Indicates the extent to which flattening should occur.
     *
     * @internal
     */
    function flattenDestructuringBinding(node: VariableDeclaration | ParameterDeclaration, visitor: (node: Node) => VisitResult<Node | undefined>, context: TransformationContext, level: FlattenLevel, rval?: Expression, hoistTempVariables?: boolean, skipInitializer?: boolean): VariableDeclaration[];
    /** @internal */
    enum FlattenLevel {
        All = 0,
        ObjectRest = 1
    }
    /** @internal */
    function processTaggedTemplateExpression(context: TransformationContext, node: TaggedTemplateExpression, visitor: Visitor, currentSourceFile: SourceFile, recordTaggedTemplateString: (temp: Identifier) => void, level: ProcessLevel): CallExpression | TaggedTemplateExpression;
    /** @internal */
    enum ProcessLevel {
        LiftRestriction = 0,
        All = 1
    }
    /** @internal */
    function transformTypeScript(context: TransformationContext): (node: SourceFile | Bundle) => SourceFile | Bundle;
    /**
     * Transforms ECMAScript Class Syntax.
     * TypeScript parameter property syntax is transformed in the TypeScript transformer.
     * For now, this transforms public field declarations using TypeScript class semantics,
     * where declarations are elided and initializers are transformed as assignments in the constructor.
     * When --useDefineForClassFields is on, this transforms to ECMAScript semantics, with Object.defineProperty.
     *
     * @internal
     */
    function transformClassFields(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function createRuntimeTypeSerializer(context: TransformationContext): RuntimeTypeSerializer;
    /** @internal */
    type SerializedEntityName = Identifier | PropertyAccessEntityNameExpression;
    /** @internal */
    type SerializedTypeNode = SerializedEntityName | ConditionalExpression | VoidExpression;
    /** @internal */
    interface RuntimeTypeSerializerContext {
        /** Specifies the current lexical block scope */
        currentLexicalScope: SourceFile | Block | ModuleBlock | CaseBlock;
        /** Specifies the containing `class`, but only when there is no other block scope between the current location and the `class`. */
        currentNameScope: ClassLikeDeclaration | undefined;
    }
    /** @internal */
    interface RuntimeTypeSerializer {
        /**
         * Serializes a type node for use with decorator type metadata.
         *
         * Types are serialized in the following fashion:
         * - Void types point to "undefined" (e.g. "void 0")
         * - Function and Constructor types point to the global "Function" constructor.
         * - Interface types with a call or construct signature types point to the global
         *   "Function" constructor.
         * - Array and Tuple types point to the global "Array" constructor.
         * - Type predicates and booleans point to the global "Boolean" constructor.
         * - String literal types and strings point to the global "String" constructor.
         * - Enum and number types point to the global "Number" constructor.
         * - Symbol types point to the global "Symbol" constructor.
         * - Type references to classes (or class-like variables) point to the constructor for the class.
         * - Anything else points to the global "Object" constructor.
         *
         * @param node The type node to serialize.
         */
        serializeTypeNode(serializerContext: RuntimeTypeSerializerContext, node: TypeNode): Expression;
        /**
         * Serializes the type of a node for use with decorator type metadata.
         * @param node The node that should have its type serialized.
         */
        serializeTypeOfNode(serializerContext: RuntimeTypeSerializerContext, node: PropertyDeclaration | ParameterDeclaration | AccessorDeclaration | ClassLikeDeclaration | MethodDeclaration): Expression;
        /**
         * Serializes the types of the parameters of a node for use with decorator type metadata.
         * @param node The node that should have its parameter types serialized.
         */
        serializeParameterTypesOfNode(serializerContext: RuntimeTypeSerializerContext, node: Node, container: ClassLikeDeclaration): ArrayLiteralExpression;
        /**
         * Serializes the return type of a node for use with decorator type metadata.
         * @param node The node that should have its return type serialized.
         */
        serializeReturnTypeOfNode(serializerContext: RuntimeTypeSerializerContext, node: Node): SerializedTypeNode;
    }
    /** @internal */
    function transformLegacyDecorators(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformESDecorators(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformES2017(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /**
     * Creates a variable named `_super` with accessor properties for the given property names.
     *
     * @internal
     */
    function createSuperAccessVariableStatement(factory: NodeFactory, resolver: EmitResolver, node: FunctionLikeDeclaration, names: Set<__String>): VariableStatement;
    /** @internal */
    function transformES2018(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformES2019(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformES2020(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformES2021(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformESNext(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformJsx(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformES2016(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformES2015(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /**
     * Transforms ES5 syntax into ES3 syntax.
     *
     * @param context Context and state information for the transformation.
     *
     * @internal
     */
    function transformES5(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformGenerators(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformSystemModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformECMAScriptModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function transformNodeModule(context: TransformationContext): (node: SourceFile | Bundle) => SourceFile | Bundle;
    /** @internal */
    function canProduceDiagnostics(node: Node): node is DeclarationDiagnosticProducing;
    /** @internal */
    function createGetSymbolAccessibilityDiagnosticForNodeName(node: DeclarationDiagnosticProducing): (symbolAccessibilityResult: SymbolAccessibilityResult) => SymbolAccessibilityDiagnostic | undefined;
    /** @internal */
    function createGetSymbolAccessibilityDiagnosticForNode(node: DeclarationDiagnosticProducing): GetSymbolAccessibilityDiagnostic;
    /** @internal */
    type GetSymbolAccessibilityDiagnostic = (symbolAccessibilityResult: SymbolAccessibilityResult) => (SymbolAccessibilityDiagnostic | undefined);
    /** @internal */
    interface SymbolAccessibilityDiagnostic {
        errorNode: Node;
        diagnosticMessage: DiagnosticMessage;
        typeName?: DeclarationName | QualifiedName;
    }
    /** @internal */
    type DeclarationDiagnosticProducing = VariableDeclaration | PropertyDeclaration | PropertySignature | BindingElement | SetAccessorDeclaration | GetAccessorDeclaration | ConstructSignatureDeclaration | CallSignatureDeclaration | MethodDeclaration | MethodSignature | FunctionDeclaration | ParameterDeclaration | TypeParameterDeclaration | ExpressionWithTypeArguments | ImportEqualsDeclaration | TypeAliasDeclaration | ConstructorDeclaration | IndexSignatureDeclaration | PropertyAccessExpression | JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag;
    /** @internal */
    function getDeclarationDiagnostics(host: EmitHost, resolver: EmitResolver, file: SourceFile | undefined): DiagnosticWithLocation[] | undefined;
    /** @internal */
    function isInternalDeclaration(node: Node, currentSourceFile: SourceFile): boolean | 0 | undefined;
    /**
     * Transforms a ts file into a .d.ts file
     * This process requires type information, which is retrieved through the emit resolver. Because of this,
     * in many places this transformer assumes it will be operating on parse tree nodes directly.
     * This means that _no transforms should be allowed to occur before this one_.
     *
     * @internal
     */
    function transformDeclarations(context: TransformationContext): {
        (node: Bundle): Bundle;
        (node: SourceFile): SourceFile;
        (node: SourceFile | Bundle): SourceFile | Bundle;
    };
    /** @internal */
    function getTransformers(compilerOptions: CompilerOptions, customTransformers?: CustomTransformers, emitOnly?: boolean | EmitOnly): EmitTransformers;
    /** @internal */
    function noEmitSubstitution(_hint: EmitHint, node: Node): Node;
    /** @internal */
    function noEmitNotification(hint: EmitHint, node: Node, callback: (hint: EmitHint, node: Node) => void): void;
    /**
     * Transforms an array of SourceFiles by passing them through each transformer.
     *
     * @param resolver The emit resolver provided by the checker.
     * @param host The emit host object used to interact with the file system.
     * @param options Compiler options to surface in the `TransformationContext`.
     * @param nodes An array of nodes to transform.
     * @param transforms An array of `TransformerFactory` callbacks.
     * @param allowDtsFiles A value indicating whether to allow the transformation of .d.ts files.
     *
     * @internal
     */
    function transformNodes<T extends Node>(resolver: EmitResolver | undefined, host: EmitHost | undefined, factory: NodeFactory, options: CompilerOptions, nodes: readonly T[], transformers: readonly TransformerFactory<T>[], allowDtsFiles: boolean): TransformationResult<T>;
    /** @internal */
    const noTransformers: EmitTransformers;
    /** @internal */
    const nullTransformationContext: TransformationContext;
    /** @internal */
    function isBuildInfoFile(file: string): boolean;
    /**
     * Iterates over the source files that are expected to have an emit output.
     *
     * @param host An EmitHost.
     * @param action The action to execute.
     * @param sourceFilesOrTargetSourceFile
     *   If an array, the full list of source files to emit.
     *   Else, calls `getSourceFilesToEmit` with the (optional) target source file to determine the list of source files to emit.
     *
     * @internal
     */
    function forEachEmittedFile<T>(host: EmitHost, action: (emitFileNames: EmitFileNames, sourceFileOrBundle: SourceFile | Bundle | undefined) => T, sourceFilesOrTargetSourceFile?: readonly SourceFile[] | SourceFile, forceDtsEmit?: boolean, onlyBuildInfo?: boolean, includeBuildInfo?: boolean): T | undefined;
    function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;
    /** @internal */
    function getOutputPathsForBundle(options: CompilerOptions, forceDtsPaths: boolean): EmitFileNames;
    /** @internal */
    function getOutputPathsFor(sourceFile: SourceFile | Bundle, host: EmitHost, forceDtsPaths: boolean): EmitFileNames;
    /** @internal */
    function getOutputExtension(fileName: string, options: CompilerOptions): Extension;
    /** @internal */
    function getOutputDeclarationFileName(inputFileName: string, configFile: ParsedCommandLine, ignoreCase: boolean, getCommonSourceDirectory?: () => string): string;
    /** @internal */
    function getCommonSourceDirectory(options: CompilerOptions, emittedFiles: () => readonly string[], currentDirectory: string, getCanonicalFileName: GetCanonicalFileName, checkSourceFilesBelongToPath?: (commonSourceDirectory: string) => void): string;
    /** @internal */
    function getCommonSourceDirectoryOfConfig({ options, fileNames }: ParsedCommandLine, ignoreCase: boolean): string;
    /** @internal */
    function getAllProjectOutputs(configFile: ParsedCommandLine, ignoreCase: boolean): readonly string[];
    function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];
    /** @internal */
    function getFirstProjectOutput(configFile: ParsedCommandLine, ignoreCase: boolean): string;
    /** @internal */
    function emitFiles(resolver: EmitResolver, host: EmitHost, targetSourceFile: SourceFile | undefined, { scriptTransformers, declarationTransformers }: EmitTransformers, emitOnly?: boolean | EmitOnly, onlyBuildInfo?: boolean, forceDtsEmit?: boolean): EmitResult;
    /** @internal */
    function createBuildInfo(program: ProgramBuildInfo | undefined, bundle: BundleBuildInfo | undefined): BuildInfo;
    /** @internal */
    function getBuildInfoText(buildInfo: BuildInfo): string;
    /** @internal */
    function getBuildInfo(buildInfoFile: string, buildInfoText: string): ts.BuildInfo | undefined;
    /** @deprecated @internal */
    function emitUsingBuildInfo(config: ParsedCommandLine, host: CompilerHost, getCommandLine: (ref: ProjectReference) => ParsedCommandLine | undefined, customTransformers?: CustomTransformers): EmitUsingBuildInfoResult;
    function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;
    /** @internal */
    const notImplementedResolver: EmitResolver;
    /**
     * File that isnt present resulting in error or output files
     *
     * @deprecated
     * @internal
     */
    type EmitUsingBuildInfoResult = string | readonly OutputFile[];
    /** @internal */
    const createPrinterWithDefaults: () => ts.Printer;
    /** @internal */
    const createPrinterWithRemoveComments: () => ts.Printer;
    /** @internal */
    const createPrinterWithRemoveCommentsNeverAsciiEscape: () => ts.Printer;
    /** @internal */
    const createPrinterWithRemoveCommentsOmitTrailingSemicolon: () => ts.Printer;
    /** @internal */
    function createCachedDirectoryStructureHost(host: DirectoryStructureHost, currentDirectory: string, useCaseSensitiveFileNames: boolean): CachedDirectoryStructureHost | undefined;
    /**
     * Updates the map of shared extended config file watches with a new set of extended config files from a base config file of the project
     *
     * @internal
     */
    function updateSharedExtendedConfigFileWatcher<T>(projectPath: T, options: CompilerOptions | undefined, extendedConfigFilesMap: Map<Path, SharedExtendedConfigFileWatcher<T>>, createExtendedConfigFileWatch: (extendedConfigPath: string, extendedConfigFilePath: Path) => FileWatcher, toPath: (fileName: string) => Path): void;
    /**
     * Remove the project from the extended config file watchers and close not needed watches
     *
     * @internal
     */
    function clearSharedExtendedConfigFileWatcher<T>(projectPath: T, extendedConfigFilesMap: Map<Path, SharedExtendedConfigFileWatcher<T>>): void;
    /**
     * Clean the extendsConfigCache when extended config file has changed
     *
     * @internal
     */
    function cleanExtendedConfigCache(extendedConfigCache: Map<string, ExtendedConfigCacheEntry>, extendedConfigFilePath: Path, toPath: (fileName: string) => Path): void;
    /**
     * Updates watchers based on the package json files used in module resolution
     *
     * @internal
     */
    function updatePackageJsonWatch(lookups: readonly (readonly [
        Path,
        object | boolean
    ])[], packageJsonWatches: Map<Path, FileWatcher>, createPackageJsonWatch: (packageJsonPath: Path, data: object | boolean) => FileWatcher): void;
    /**
     * Updates the existing missing file watches with the new set of missing files after new program is created
     *
     * @internal
     */
    function updateMissingFilePathsWatch(program: Program, missingFileWatches: Map<Path, FileWatcher>, createMissingFileWatch: (missingFilePath: Path) => FileWatcher): void;
    /**
     * Updates the existing wild card directory watches with the new set of wild card directories from the config file
     * after new program is created because the config file was reloaded or program was created first time from the config file
     * Note that there is no need to call this function when the program is updated with additional files without reloading config files,
     * as wildcard directories wont change unless reloading config file
     *
     * @internal
     */
    function updateWatchingWildcardDirectories(existingWatchedForWildcards: Map<string, WildcardDirectoryWatcher>, wildcardDirectories: Map<string, WatchDirectoryFlags>, watchDirectory: (directory: string, flags: WatchDirectoryFlags) => FileWatcher): void;
    /** @internal */
    function isIgnoredFileFromWildCardWatching({ watchedDirPath, fileOrDirectory, fileOrDirectoryPath, configFileName, options, program, extraFileExtensions, currentDirectory, useCaseSensitiveFileNames, writeLog, toPath, }: IsIgnoredFileFromWildCardWatchingInput): boolean;
    /** @internal */
    function isEmittedFileOfProgram(program: Program | undefined, file: string): boolean;
    /** @internal */
    function getWatchFactory<X, Y = undefined>(host: WatchFactoryHost, watchLogLevel: WatchLogLevel, log: (s: string) => void, getDetailWatchInfo?: GetDetailWatchInfo<X, Y>): WatchFactory<X, Y>;
    /** @internal */
    function getFallbackOptions(options: WatchOptions | undefined): WatchOptions;
    /** @internal */
    function closeFileWatcherOf<T extends {
        watcher: FileWatcher;
    }>(objWithWatcher: T): void;
    /**
     * Partial interface of the System thats needed to support the caching of directory structure
     *
     * @internal
     */
    interface DirectoryStructureHost {
        fileExists(path: string): boolean;
        readFile(path: string, encoding?: string): string | undefined;
        directoryExists?(path: string): boolean;
        getDirectories?(path: string): string[];
        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
        realpath?(path: string): string;
        createDirectory?(path: string): void;
        writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;
    }
    /** @internal */
    interface FileAndDirectoryExistence {
        fileExists: boolean;
        directoryExists: boolean;
    }
    /** @internal */
    interface CachedDirectoryStructureHost extends DirectoryStructureHost {
        useCaseSensitiveFileNames: boolean;
        getDirectories(path: string): string[];
        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
        /** Returns the queried result for the file exists and directory exists if at all it was done */
        addOrDeleteFileOrDirectory(fileOrDirectory: string, fileOrDirectoryPath: Path): FileAndDirectoryExistence | undefined;
        addOrDeleteFile(fileName: string, filePath: Path, eventKind: FileWatcherEventKind): void;
        clearCache(): void;
    }
    /** @internal */
    enum ConfigFileProgramReloadLevel {
        None = 0,
        /** Update the file name list from the disk */
        Partial = 1,
        /** Reload completely by re-reading contents of config file from disk and updating program */
        Full = 2
    }
    /** @internal */
    interface SharedExtendedConfigFileWatcher<T> extends FileWatcher {
        watcher: FileWatcher;
        projects: Set<T>;
    }
    /** @internal */
    interface WildcardDirectoryWatcher {
        watcher: FileWatcher;
        flags: WatchDirectoryFlags;
    }
    /** @internal */
    interface IsIgnoredFileFromWildCardWatchingInput {
        watchedDirPath: Path;
        fileOrDirectory: string;
        fileOrDirectoryPath: Path;
        configFileName: string;
        options: CompilerOptions;
        program: BuilderProgram | Program | readonly string[] | undefined;
        extraFileExtensions?: readonly FileExtensionInfo[];
        currentDirectory: string;
        useCaseSensitiveFileNames: boolean;
        writeLog: (s: string) => void;
        toPath: (fileName: string) => Path;
    }
    /** @internal */
    enum WatchLogLevel {
        None = 0,
        TriggerOnly = 1,
        Verbose = 2
    }
    /** @internal */
    interface WatchFactoryHost {
        watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
        watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
        getCurrentDirectory?(): string;
        useCaseSensitiveFileNames: boolean | (() => boolean);
    }
    /** @internal */
    interface WatchFactory<X, Y = undefined> {
        watchFile: (file: string, callback: FileWatcherCallback, pollingInterval: PollingInterval, options: WatchOptions | undefined, detailInfo1: X, detailInfo2?: Y) => FileWatcher;
        watchDirectory: (directory: string, callback: DirectoryWatcherCallback, flags: WatchDirectoryFlags, options: WatchOptions | undefined, detailInfo1: X, detailInfo2?: Y) => FileWatcher;
    }
    /** @internal */
    type GetDetailWatchInfo<X, Y> = (detailInfo1: X, detailInfo2: Y | undefined) => string;
    function findConfigFile(searchPath: string, fileExists: (fileName: string) => boolean, configName?: string): string | undefined;
    function resolveTripleslashReference(moduleName: string, containingFile: string): string;
    /** @internal */
    function computeCommonSourceDirectoryOfFilenames(fileNames: readonly string[], currentDirectory: string, getCanonicalFileName: GetCanonicalFileName): string;
    function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost;
    /** @internal */
    function createGetSourceFile(readFile: ProgramHost<any>["readFile"], getCompilerOptions: () => CompilerOptions, setParentNodes: boolean | undefined): CompilerHost["getSourceFile"];
    /** @internal */
    function createWriteFileMeasuringIO(actualWriteFile: (path: string, data: string, writeByteOrderMark: boolean) => void, createDirectory: (path: string) => void, directoryExists: (path: string) => boolean): CompilerHost["writeFile"];
    /** @internal */
    function createCompilerHostWorker(options: CompilerOptions, setParentNodes?: boolean, system?: ts.System): CompilerHost;
    /** @internal */
    function changeCompilerHostLikeToUseCache(host: CompilerHostLikeForCache, toPath: (fileName: string) => Path, getSourceFile?: CompilerHost["getSourceFile"]): {
        originalReadFile: (fileName: string, encoding?: string | undefined) => string | undefined;
        originalFileExists: (fileName: string) => boolean;
        originalDirectoryExists: ((directory: string) => boolean) | undefined;
        originalCreateDirectory: ((directory: string) => void) | undefined;
        originalWriteFile: ts.WriteFileCallback | undefined;
        getSourceFileWithCache: ((fileName: string, languageVersionOrOptions: ts.ScriptTarget | ts.CreateSourceFileOptions, onError?: ((message: string) => void) | undefined, shouldCreateNewSourceFile?: boolean | undefined) => ts.SourceFile | undefined) | undefined;
        readFileWithCache: (fileName: string) => string | undefined;
    };
    function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
    /** @internal */ function getPreEmitDiagnostics(program: BuilderProgram, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
    function formatDiagnostics(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
    function formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): string;
    /** @internal */
    function formatColorAndReset(text: string, formatStyle: string): string;
    /** @internal */
    function formatLocation(file: SourceFile, start: number, host: FormatDiagnosticsHost, color?: typeof formatColorAndReset): string;
    function formatDiagnosticsWithColorAndContext(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
    function flattenDiagnosticMessageText(diag: string | DiagnosticMessageChain | undefined, newLine: string, indent?: number): string;
    /**
     * Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly
     * provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.
     */
    function getModeForFileReference(ref: FileReference | string, containingFileMode: ResolutionMode): ts.ResolutionMode;
    /**
     * Calculates the final resolution mode for an import at some index within a file's imports list. This is generally the explicitly
     * defined mode of the import if provided, or, if not, the mode of the containing file (with some exceptions: import=require is always commonjs, dynamic import is always esm).
     * If you have an actual import node, prefer using getModeForUsageLocation on the reference string node.
     * @param file File to fetch the resolution mode within
     * @param index Index into the file's complete resolution list to get the resolution of - this is a concatenation of the file's imports and module augmentations
     */
    function getModeForResolutionAtIndex(file: SourceFile, index: number): ResolutionMode;
    /** @internal */
    function getModeForResolutionAtIndex(file: SourceFileImportsList, index: number): ResolutionMode;
    /** @internal */
    function isExclusivelyTypeOnlyImportOrExport(decl: ImportDeclaration | ExportDeclaration): boolean;
    /**
     * Calculates the final resolution mode for a given module reference node. This is generally the explicitly provided resolution mode, if
     * one exists, or the mode of the containing source file. (Excepting import=require, which is always commonjs, and dynamic import, which is always esm).
     * Notably, this function always returns `undefined` if the containing file has an `undefined` `impliedNodeFormat` - this field is only set when
     * `moduleResolution` is `node16`+.
     * @param file The file the import or import-like reference is contained within
     * @param usage The module reference string
     * @returns The final resolution mode of the import
     */
    function getModeForUsageLocation(file: {
        impliedNodeFormat?: ResolutionMode;
    }, usage: StringLiteralLike): ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined;
    /** @internal */
    function getResolutionModeOverrideForClause(clause: AssertClause | undefined, grammarErrorOnNode?: (node: Node, diagnostic: DiagnosticMessage) => void): ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined;
    /** @internal */
    function createModuleResolutionLoader(containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, host: ModuleResolutionHost, cache: ModuleResolutionCache | undefined): ResolutionLoader<StringLiteralLike, ResolvedModuleWithFailedLookupLocations, SourceFile>;
    /** @internal */
    function createTypeReferenceResolutionLoader<T extends FileReference | string>(containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, host: ModuleResolutionHost, cache: TypeReferenceDirectiveResolutionCache | undefined): ResolutionLoader<T, ResolvedTypeReferenceDirectiveWithFailedLookupLocations, SourceFile | undefined>;
    /** @internal */
    function loadWithModeAwareCache<Entry, SourceFile, ResolutionCache, Resolution>(entries: readonly Entry[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, host: ModuleResolutionHost, resolutionCache: ResolutionCache | undefined, createLoader: (containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, host: ModuleResolutionHost, resolutionCache: ResolutionCache | undefined) => ResolutionLoader<Entry, Resolution, SourceFile>): readonly Resolution[];
    /** @internal */
    function forEachResolvedProjectReference<T>(resolvedProjectReferences: readonly (ResolvedProjectReference | undefined)[] | undefined, cb: (resolvedProjectReference: ResolvedProjectReference, parent: ResolvedProjectReference | undefined) => T | undefined): T | undefined;
    /** @internal */
    function isReferencedFile(reason: FileIncludeReason | undefined): reason is ReferencedFile;
    /** @internal */
    function isReferenceFileLocation(location: ReferenceFileLocation | SyntheticReferenceFileLocation): location is ReferenceFileLocation;
    /** @internal */
    function getReferencedFileLocation(getSourceFileByPath: (path: Path) => SourceFile | undefined, ref: ReferencedFile): ReferenceFileLocation | SyntheticReferenceFileLocation;
    /**
     * Determines if program structure is upto date or needs to be recreated
     *
     * @internal
     */
    function isProgramUptoDate(program: Program | undefined, rootFileNames: string[], newOptions: CompilerOptions, getSourceVersion: (path: Path, fileName: string) => string | undefined, fileExists: (fileName: string) => boolean, hasInvalidatedResolutions: HasInvalidatedResolutions, hasChangedAutomaticTypeDirectiveNames: HasChangedAutomaticTypeDirectiveNames | undefined, getParsedCommandLine: (fileName: string) => ParsedCommandLine | undefined, projectReferences: readonly ProjectReference[] | undefined): boolean;
    function getConfigFileParsingDiagnostics(configFileParseResult: ParsedCommandLine): readonly Diagnostic[];
    /**
     * A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the
     * `options` parameter.
     *
     * @param fileName The normalized absolute path to check the format of (it need not exist on disk)
     * @param [packageJsonInfoCache] A cache for package file lookups - it's best to have a cache when this function is called often
     * @param host The ModuleResolutionHost which can perform the filesystem lookups for package json data
     * @param options The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution`
     * @returns `undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format
     */
    function getImpliedNodeFormatForFile(fileName: Path, packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ResolutionMode;
    /** @internal */
    function getImpliedNodeFormatForFileWorker(fileName: string, packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | Partial<ts.CreateSourceFileOptions> | undefined;
    /**
     * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
     * that represent a compilation unit.
     *
     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
     * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
     *
     * @param createProgramOptions - The options for creating a program.
     * @returns A 'Program' object.
     */
    function createProgram(createProgramOptions: CreateProgramOptions): Program;
    /**
     * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
     * that represent a compilation unit.
     *
     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
     * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
     *
     * @param rootNames - A set of root files.
     * @param options - The compiler options which should be used.
     * @param host - The host interacts with the underlying file system.
     * @param oldProgram - Reuses an old program structure.
     * @param configFileParsingDiagnostics - error during config file parsing
     * @returns A 'Program' object.
     */
    function createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program;
    /** @internal */
    function handleNoEmitOptions<T extends BuilderProgram>(program: Program | T, sourceFile: SourceFile | undefined, writeFile: WriteFileCallback | undefined, cancellationToken: CancellationToken | undefined): EmitResult | undefined;
    /** @internal */
    function filterSemanticDiagnostics(diagnostic: readonly Diagnostic[], option: CompilerOptions): readonly Diagnostic[];
    /** @internal */
    function parseConfigHostFromCompilerHostLike(host: CompilerHostLike, directoryStructureHost?: DirectoryStructureHost): ParseConfigFileHost;
    /** @deprecated @internal */
    function createPrependNodes(projectReferences: readonly ProjectReference[] | undefined, getCommandLine: (ref: ProjectReference, index: number) => ParsedCommandLine | undefined, readFile: (path: string) => string | undefined, host: CompilerHost): ts.InputFiles[];
    /**
     * Returns the target config filename of a project reference.
     * Note: The file might not exist.
     */
    function resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName;
    /**
     * Returns a DiagnosticMessage if we won't include a resolved module due to its extension.
     * The DiagnosticMessage's parameters are the imported module name, and the filename it resolved to.
     * This returns a diagnostic even if the module will be an untyped module.
     *
     * @internal
     */
    function getResolutionDiagnostic(options: CompilerOptions, { extension }: ResolvedModuleFull, { isDeclarationFile }: {
        isDeclarationFile: SourceFile["isDeclarationFile"];
    }): DiagnosticMessage | undefined;
    /** @internal */
    function getModuleNameStringLiteralAt({ imports, moduleAugmentations }: SourceFileImportsList, index: number): StringLiteralLike;
    /** @internal */
    interface CompilerHostLikeForCache {
        fileExists(fileName: string): boolean;
        readFile(fileName: string, encoding?: string): string | undefined;
        directoryExists?(directory: string): boolean;
        createDirectory?(directory: string): void;
        writeFile?: WriteFileCallback;
    }
    interface FormatDiagnosticsHost {
        getCurrentDirectory(): string;
        getCanonicalFileName(fileName: string): string;
        getNewLine(): string;
    }
    /** @internal */
    enum ForegroundColorEscapeSequences {
        Grey = "\u001B[90m",
        Red = "\u001B[91m",
        Yellow = "\u001B[93m",
        Blue = "\u001B[94m",
        Cyan = "\u001B[96m"
    }
    /**
     * Subset of a SourceFile used to calculate index-based resolutions
     * This includes some internal fields, so unless you have very good reason,
     * (and are willing to use some less stable internals) you should probably just pass a SourceFile.
     *
     * @internal
     */
    interface SourceFileImportsList {
        /** @internal */ imports: SourceFile["imports"];
        /** @internal */ moduleAugmentations: SourceFile["moduleAugmentations"];
        impliedNodeFormat?: ResolutionMode;
    }
    /** @internal */
    interface ResolutionNameAndModeGetter<Entry, SourceFile> {
        getName(entry: Entry): string;
        getMode(entry: Entry, file: SourceFile): ResolutionMode;
    }
    /** @internal */
    interface ResolutionLoader<Entry, Resolution, SourceFile> {
        nameAndMode: ResolutionNameAndModeGetter<Entry, SourceFile>;
        resolve(name: string, mode: ResolutionMode): Resolution;
    }
    /** @internal */
    const moduleResolutionNameAndModeGetter: ResolutionNameAndModeGetter<StringLiteralLike, SourceFile>;
    /** @internal */
    const typeReferenceResolutionNameAndModeGetter: ResolutionNameAndModeGetter<FileReference | string, SourceFile | undefined>;
    /** @internal */
    const inferredTypesContainingFile = "__inferred type names__.ts";
    /** @internal */
    interface ReferenceFileLocation {
        file: SourceFile;
        pos: number;
        end: number;
        packageId: PackageId | undefined;
    }
    /** @internal */
    interface SyntheticReferenceFileLocation {
        file: SourceFile;
        packageId: PackageId | undefined;
        text: string;
    }
    /** @internal */
    const plainJSErrors: Set<number>;
    /** @internal */
    const emitSkippedWithNoDiagnostics: EmitResult;
    /** @internal */
    interface CompilerHostLike {
        useCaseSensitiveFileNames(): boolean;
        getCurrentDirectory(): string;
        fileExists(fileName: string): boolean;
        readFile(fileName: string): string | undefined;
        readDirectory?(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): string[];
        trace?(s: string): void;
        onUnRecoverableConfigFileDiagnostic?: DiagnosticReporter;
    }
    interface EmitOutput {
        outputFiles: OutputFile[];
        emitSkipped: boolean;
        /** @internal */ diagnostics: readonly Diagnostic[];
    }
    interface OutputFile {
        name: string;
        writeByteOrderMark: boolean;
        text: string;
        /** @internal */ data?: WriteFileCallbackData;
    }
    /** @internal */
    function getFileEmitOutput(program: Program, sourceFile: SourceFile, emitOnlyDtsFiles: boolean, cancellationToken?: CancellationToken, customTransformers?: CustomTransformers, forceDtsEmit?: boolean): EmitOutput;
    /** @internal */
    interface BuilderState {
        /**
         * Information of the file eg. its version, signature etc
         */
        fileInfos: Map<Path, BuilderState.FileInfo>;
        /**
         * Contains the map of ReferencedSet=Referenced files of the file if module emit is enabled
         * Otherwise undefined
         * Thus non undefined value indicates, module emit
         */
        readonly referencedMap?: BuilderState.ReadonlyManyToManyPathMap | undefined;
        /**
         * Contains the map of exported modules ReferencedSet=exported module files from the file if module emit is enabled
         * Otherwise undefined
         *
         * This is equivalent to referencedMap, but for the emitted .d.ts file.
         */
        readonly exportedModulesMap?: BuilderState.ManyToManyPathMap | undefined;
        /**
         * true if file version is used as signature
         * This helps in delaying the calculation of the d.ts hash as version for the file till reasonable time
         */
        useFileVersionAsSignature?: boolean;
        /**
         * Map of files that have already called update signature.
         * That means hence forth these files are assumed to have
         * no change in their signature for this version of the program
         */
        hasCalledUpdateShapeSignature?: Set<Path>;
        /**
         * Stores signatures before before the update till affected file is commited
         */
        oldSignatures?: Map<Path, string | false>;
        /**
         * Stores exportedModulesMap before the update till affected file is commited
         */
        oldExportedModulesMap?: Map<Path, ReadonlySet<Path> | false>;
        /**
         * Cache of all files excluding default library file for the current program
         */
        allFilesExcludingDefaultLibraryFile?: readonly SourceFile[];
        /**
         * Cache of all the file names
         */
        allFileNames?: readonly string[];
    }
    /** @internal */
    namespace BuilderState {
        /**
         * Information about the source file: Its version and optional signature from last emit
         */
        interface FileInfo {
            readonly version: string;
            signature: string | undefined;
            affectsGlobalScope: true | undefined;
            impliedFormat: ResolutionMode;
        }
        interface ReadonlyManyToManyPathMap {
            getKeys(v: Path): ReadonlySet<Path> | undefined;
            getValues(k: Path): ReadonlySet<Path> | undefined;
            keys(): IterableIterator<Path>;
        }
        interface ManyToManyPathMap extends ReadonlyManyToManyPathMap {
            deleteKey(k: Path): boolean;
            set(k: Path, v: ReadonlySet<Path>): void;
        }
        function createManyToManyPathMap(): ManyToManyPathMap;
        /**
         * Returns true if oldState is reusable, that is the emitKind = module/non module has not changed
         */
        function canReuseOldState(newReferencedMap: ReadonlyManyToManyPathMap | undefined, oldState: BuilderState | undefined): boolean | undefined;
        /**
         * Creates the state of file references and signature for the new program from oldState if it is safe
         */
        function create(newProgram: Program, oldState: Readonly<BuilderState> | undefined, disableUseFileVersionAsSignature: boolean): BuilderState;
        /**
         * Releases needed properties
         */
        function releaseCache(state: BuilderState): void;
        /**
         * Gets the files affected by the path from the program
         */
        function getFilesAffectedBy(state: BuilderState, programOfThisState: Program, path: Path, cancellationToken: CancellationToken | undefined, host: HostForComputeHash): readonly SourceFile[];
        function getFilesAffectedByWithOldState(state: BuilderState, programOfThisState: Program, path: Path, cancellationToken: CancellationToken | undefined, host: HostForComputeHash): readonly SourceFile[];
        function updateSignatureOfFile(state: BuilderState, signature: string | undefined, path: Path): void;
        function computeDtsSignature(programOfThisState: Program, sourceFile: SourceFile, cancellationToken: CancellationToken | undefined, host: HostForComputeHash, onNewSignature: (signature: string, sourceFiles: readonly SourceFile[]) => void): void;
        /**
         * Returns if the shape of the signature has changed since last emit
         */
        function updateShapeSignature(state: BuilderState, programOfThisState: Program, sourceFile: SourceFile, cancellationToken: CancellationToken | undefined, host: HostForComputeHash, useFileVersionAsSignature?: boolean | undefined): boolean;
        /**
         * Coverts the declaration emit result into exported modules map
         */
        function updateExportedModules(state: BuilderState, sourceFile: SourceFile, exportedModulesFromDeclarationEmit: ExportedModulesFromDeclarationEmit | undefined): void;
        function getExportedModules(exportedModulesFromDeclarationEmit: ExportedModulesFromDeclarationEmit | undefined): Set<Path> | undefined;
        /**
         * Get all the dependencies of the sourceFile
         */
        function getAllDependencies(state: BuilderState, programOfThisState: Program, sourceFile: SourceFile): readonly string[];
        /**
         * Gets the files referenced by the the file path
         */
        function getReferencedByPaths(state: Readonly<BuilderState>, referencedFilePath: Path): Path[];
        /**
         * Gets all files of the program excluding the default library file
         */
        function getAllFilesExcludingDefaultLibraryFile(state: BuilderState, programOfThisState: Program, firstSourceFile: SourceFile | undefined): readonly SourceFile[];
    }
    /**
     * Get flags determining what all needs to be emitted
     *
     * @internal
     */
    function getBuilderFileEmit(options: CompilerOptions): ts.BuilderFileEmit;
    /**
     * Determing what all is pending to be emitted based on previous options or previous file emit flags
     *
     * @internal
     */
    function getPendingEmitKind(optionsOrEmitKind: CompilerOptions | BuilderFileEmit, oldOptionsOrEmitKind: CompilerOptions | BuilderFileEmit | undefined): BuilderFileEmit;
    /** @internal */
    function isProgramBundleEmitBuildInfo(info: ProgramBuildInfo): info is ProgramBundleEmitBuildInfo;
    /** @internal */
    function getBuilderCreationParameters(newProgramOrRootNames: Program | readonly string[] | undefined, hostOrOptions: BuilderProgramHost | CompilerOptions | undefined, oldProgramOrHost?: BuilderProgram | CompilerHost, configFileParsingDiagnosticsOrOldProgram?: readonly Diagnostic[] | BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderCreationParameters;
    /** @internal */
    function computeSignatureWithDiagnostics(program: Program, sourceFile: SourceFile, text: string, host: HostForComputeHash, data: WriteFileCallbackData | undefined): string;
    /** @internal */
    function computeSignature(text: string, host: HostForComputeHash, data?: WriteFileCallbackData): string;
    /** @internal */
    function createBuilderProgram(kind: BuilderProgramKind.SemanticDiagnosticsBuilderProgram, builderCreationParameters: BuilderCreationParameters): SemanticDiagnosticsBuilderProgram;
    /** @internal */
    function createBuilderProgram(kind: BuilderProgramKind.EmitAndSemanticDiagnosticsBuilderProgram, builderCreationParameters: BuilderCreationParameters): EmitAndSemanticDiagnosticsBuilderProgram;
    /** @internal */
    function toBuilderStateFileInfoForMultiEmit(fileInfo: ProgramMultiFileEmitBuildInfoFileInfo): BuilderState.FileInfo;
    /** @internal */
    function toBuilderFileEmit(value: ProgramBuilderInfoFilePendingEmit, fullEmitForOptions: BuilderFileEmit): BuilderFileEmit;
    /** @internal */
    function toProgramEmitPending(value: ProgramBuildInfoBundlePendingEmit, options: CompilerOptions | undefined): BuilderFileEmit | undefined;
    /** @internal */
    function createBuilderProgramUsingProgramBuildInfo(buildInfo: BuildInfo, buildInfoPath: string, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram;
    /** @internal */
    function getBuildInfoFileVersionMap(program: ProgramBuildInfo, buildInfoPath: string, host: Pick<ReadBuildProgramHost, "useCaseSensitiveFileNames" | "getCurrentDirectory">): {
        fileInfos: Map<ts.Path, string>;
        roots: ts.Path[];
    };
    /** @internal */
    function createRedirectedBuilderProgram(getState: () => {
        program?: Program | undefined;
        compilerOptions: CompilerOptions;
    }, configFileParsingDiagnostics: readonly Diagnostic[]): BuilderProgram;
    /** @internal */
    interface ReusableDiagnostic extends ReusableDiagnosticRelatedInformation {
        /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */
        reportsUnnecessary?: {};
        reportDeprecated?: {};
        source?: string;
        relatedInformation?: ReusableDiagnosticRelatedInformation[];
        skippedOn?: keyof CompilerOptions;
    }
    /** @internal */
    interface ReusableDiagnosticRelatedInformation {
        category: DiagnosticCategory;
        code: number;
        file: string | undefined;
        start: number | undefined;
        length: number | undefined;
        messageText: string | ReusableDiagnosticMessageChain;
    }
    /** @internal */
    type ReusableDiagnosticMessageChain = DiagnosticMessageChain;
    /**
     * Signature (Hash of d.ts emitted), is string if it was emitted using same d.ts.map option as what compilerOptions indicate, otherwise tuple of string
     *
     * @internal
     */
    type EmitSignature = string | [
        signature: string
    ];
    /** @internal */
    interface ReusableBuilderProgramState extends BuilderState {
        /**
         * Cache of bind and check diagnostics for files with their Path being the key
         */
        semanticDiagnosticsPerFile?: Map<Path, readonly ReusableDiagnostic[] | readonly Diagnostic[]> | undefined;
        /**
         * The map has key by source file's path that has been changed
         */
        changedFilesSet?: Set<Path>;
        /**
         * program corresponding to this state
         */
        program?: Program | undefined;
        /**
         * compilerOptions for the program
         */
        compilerOptions: CompilerOptions;
        /**
         * Files pending to be emitted
         */
        affectedFilesPendingEmit?: ReadonlyMap<Path, BuilderFileEmit>;
        /**
         * emitKind pending for a program with --out
         */
        programEmitPending?: BuilderFileEmit;
        hasReusableDiagnostic?: true;
        /**
         * Hash of d.ts emitted for the file, use to track when emit of d.ts changes
         */
        emitSignatures?: Map<Path, EmitSignature>;
        /**
         * Hash of d.ts emit with --out
         */
        outSignature?: EmitSignature;
        /**
         * Name of the file whose dts was the latest to change
         */
        latestChangedDtsFile: string | undefined;
        /**
         * @deprecated
         * Bundle information either from oldState or current one so it can be used to complete the information in buildInfo when emitting only js or dts files
         */
        bundle?: BundleBuildInfo;
    }
    /** @internal */
    enum BuilderFileEmit {
        None = 0,
        Js = 1,
        JsMap = 2,
        JsInlineMap = 4,
        Dts = 8,
        DtsMap = 16,
        AllJs = 7,
        AllDts = 24,
        All = 31
    }
    /**
     * State to store the changed files, affected files and cache semantic diagnostics
     *
     * @internal
     */
    interface BuilderProgramState extends BuilderState, ReusableBuilderProgramState {
        /**
         * Cache of bind and check diagnostics for files with their Path being the key
         */
        semanticDiagnosticsPerFile: Map<Path, readonly Diagnostic[]> | undefined;
        /**
         * The map has key by source file's path that has been changed
         */
        changedFilesSet: Set<Path>;
        /**
         * Set of affected files being iterated
         */
        affectedFiles?: readonly SourceFile[] | undefined;
        /**
         * Current index to retrieve affected file from
         */
        affectedFilesIndex: number | undefined;
        /**
         * Current changed file for iterating over affected files
         */
        currentChangedFilePath?: Path | undefined;
        /**
         * Already seen affected files
         */
        seenAffectedFiles: Set<Path> | undefined;
        /**
         * whether this program has cleaned semantic diagnostics cache for lib files
         */
        cleanedDiagnosticsOfLibFiles?: boolean;
        /**
         * True if the semantic diagnostics were copied from the old state
         */
        semanticDiagnosticsFromOldState?: Set<Path>;
        /**
         * Records if change in dts emit was detected
         */
        hasChangedEmitSignature?: boolean;
        /**
         * Files pending to be emitted
         */
        affectedFilesPendingEmit?: Map<Path, BuilderFileEmit>;
        /**
         * true if build info is emitted
         */
        buildInfoEmitPending: boolean;
        /**
         * Already seen emitted files
         */
        seenEmittedFiles: Map<Path, BuilderFileEmit> | undefined;
        /** Stores list of files that change signature during emit - test only */
        filesChangingSignature?: Set<Path>;
    }
    /** @internal */
    type SavedBuildProgramEmitState = Pick<BuilderProgramState, "affectedFilesPendingEmit" | "seenEmittedFiles" | "programEmitPending" | "emitSignatures" | "outSignature" | "latestChangedDtsFile" | "hasChangedEmitSignature"> & {
        changedFilesSet: BuilderProgramState["changedFilesSet"] | undefined;
    };
    /** @internal */
    type ProgramBuildInfoFileId = number & {
        __programBuildInfoFileIdBrand: any;
    };
    /** @internal */
    type ProgramBuildInfoFileIdListId = number & {
        __programBuildInfoFileIdListIdBrand: any;
    };
    /** @internal */
    type ProgramBuildInfoDiagnostic = ProgramBuildInfoFileId | [
        fileId: ProgramBuildInfoFileId,
        diagnostics: readonly ReusableDiagnostic[]
    ];
    /**
     * fileId if pending emit is same as what compilerOptions suggest
     * [fileId] if pending emit is only dts file emit
     * [fileId, emitKind] if any other type emit is pending
     *
     * @internal
     */
    type ProgramBuilderInfoFilePendingEmit = ProgramBuildInfoFileId | [
        fileId: ProgramBuildInfoFileId
    ] | [
        fileId: ProgramBuildInfoFileId,
        emitKind: BuilderFileEmit
    ];
    /** @internal */
    type ProgramBuildInfoReferencedMap = [
        fileId: ProgramBuildInfoFileId,
        fileIdListId: ProgramBuildInfoFileIdListId
    ][];
    /** @internal */
    type ProgramMultiFileEmitBuildInfoBuilderStateFileInfo = Omit<BuilderState.FileInfo, "signature"> & {
        /**
         * Signature is
         * - undefined if FileInfo.version === FileInfo.signature
         * - false if FileInfo has signature as undefined (not calculated)
         * - string actual signature
         */
        signature: string | false | undefined;
    };
    /**
     * [fileId, signature] if different from file's signature
     * fileId if file wasnt emitted
     *
     * @internal
     */
    type ProgramBuildInfoEmitSignature = ProgramBuildInfoFileId | [
        fileId: ProgramBuildInfoFileId,
        signature: EmitSignature | [
        ]
    ];
    /**
     * ProgramMultiFileEmitBuildInfoFileInfo is string if FileInfo.version === FileInfo.signature && !FileInfo.affectsGlobalScope otherwise encoded FileInfo
     *
     * @internal
     */
    type ProgramMultiFileEmitBuildInfoFileInfo = string | ProgramMultiFileEmitBuildInfoBuilderStateFileInfo;
    /** @internal */
    type ProgramBuildInfoRootStartEnd = [
        start: ProgramBuildInfoFileId,
        end: ProgramBuildInfoFileId
    ];
    /**
     * Either start and end of FileId for consecutive fileIds to be included as root or single fileId that is root
     * @internal
     */
    type ProgramBuildInfoRoot = ProgramBuildInfoRootStartEnd | ProgramBuildInfoFileId;
    /** @internal */
    interface ProgramMultiFileEmitBuildInfo {
        fileNames: readonly string[];
        fileInfos: readonly ProgramMultiFileEmitBuildInfoFileInfo[];
        root: readonly ProgramBuildInfoRoot[];
        options: CompilerOptions | undefined;
        fileIdsList: readonly (readonly ProgramBuildInfoFileId[])[] | undefined;
        referencedMap: ProgramBuildInfoReferencedMap | undefined;
        exportedModulesMap: ProgramBuildInfoReferencedMap | undefined;
        semanticDiagnosticsPerFile: ProgramBuildInfoDiagnostic[] | undefined;
        affectedFilesPendingEmit: ProgramBuilderInfoFilePendingEmit[] | undefined;
        changeFileSet: readonly ProgramBuildInfoFileId[] | undefined;
        emitSignatures: readonly ProgramBuildInfoEmitSignature[] | undefined;
        latestChangedDtsFile?: string | undefined;
    }
    /**
     * ProgramBundleEmitBuildInfoFileInfo is string if !FileInfo.impliedFormat otherwise encoded FileInfo
     *
     * @internal
     */
    type ProgramBundleEmitBuildInfoFileInfo = string | BuilderState.FileInfo;
    /**
     * false if it is the emit corresponding to compilerOptions
     * value otherwise
     *
     * @internal
     */
    type ProgramBuildInfoBundlePendingEmit = BuilderFileEmit | false;
    /** @internal */
    interface ProgramBundleEmitBuildInfo {
        fileNames: readonly string[];
        fileInfos: readonly ProgramBundleEmitBuildInfoFileInfo[];
        root: readonly ProgramBuildInfoRoot[];
        options: CompilerOptions | undefined;
        outSignature: EmitSignature | undefined;
        latestChangedDtsFile: string | undefined;
        pendingEmit: ProgramBuildInfoBundlePendingEmit | undefined;
    }
    /** @internal */
    type ProgramBuildInfo = ProgramMultiFileEmitBuildInfo | ProgramBundleEmitBuildInfo;
    /** @internal */
    enum BuilderProgramKind {
        SemanticDiagnosticsBuilderProgram = 0,
        EmitAndSemanticDiagnosticsBuilderProgram = 1
    }
    /** @internal */
    interface BuilderCreationParameters {
        newProgram: Program;
        host: BuilderProgramHost;
        oldProgram: BuilderProgram | undefined;
        configFileParsingDiagnostics: readonly Diagnostic[];
    }
    /**
     * Create the builder to manage semantic diagnostics and cache them
     */
    function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;
    function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;
    /**
     * Create the builder that can handle the changes in program and iterate through changed files
     * to emit the those files and manage semantic diagnostics cache as well
     */
    function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;
    function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;
    /**
     * Creates a builder thats just abstraction over program and can be used with watch
     */
    function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;
    function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;
    type AffectedFileResult<T> = {
        result: T;
        affected: SourceFile | Program;
    } | undefined;
    interface BuilderProgramHost {
        /**
         * If provided this would be used this hash instead of actual file shape text for detecting changes
         */
        createHash?: (data: string) => string;
        /**
         * When emit or emitNextAffectedFile are called without writeFile,
         * this callback if present would be used to write files
         */
        writeFile?: WriteFileCallback;
        /**
         * Store the list of files that update signature during the emit
         *
         * @internal
         */
        storeFilesChangingSignatureDuringEmit?: boolean;
    }
    /** @internal */
    type HostForComputeHash = Pick<BuilderProgramHost, "createHash">;
    /**
     * Builder to manage the program state changes
     */
    interface BuilderProgram {
        /** @internal */
        getState(): ReusableBuilderProgramState;
        /** @internal */
        saveEmitState(): SavedBuildProgramEmitState;
        /** @internal */
        restoreEmitState(saved: SavedBuildProgramEmitState): void;
        /** @internal */
        hasChangedEmitSignature?(): boolean;
        /**
         * Returns current program
         */
        getProgram(): Program;
        /**
         * Returns current program that could be undefined if the program was released
         *
         * @internal
         */
        getProgramOrUndefined(): Program | undefined;
        /**
         * Releases reference to the program, making all the other operations that need program to fail.
         *
         * @internal
         */
        releaseProgram(): void;
        /**
         * Get compiler options of the program
         */
        getCompilerOptions(): CompilerOptions;
        /**
         * Get the source file in the program with file name
         */
        getSourceFile(fileName: string): SourceFile | undefined;
        /**
         * Get a list of files in the program
         */
        getSourceFiles(): readonly SourceFile[];
        /**
         * Get the diagnostics for compiler options
         */
        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        /**
         * Get the diagnostics that dont belong to any file
         */
        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        /**
         * Get the diagnostics from config file parsing
         */
        getConfigFileParsingDiagnostics(): readonly Diagnostic[];
        /**
         * Get the syntax diagnostics, for all source files if source file is not supplied
         */
        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        /**
         * Get the declaration diagnostics, for all source files if source file is not supplied
         */
        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
        /**
         * Get all the dependencies of the file
         */
        getAllDependencies(sourceFile: SourceFile): readonly string[];
        /**
         * Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program
         * The semantic diagnostics are cached and managed here
         * Note that it is assumed that when asked about semantic diagnostics through this API,
         * the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics
         * In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,
         * it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics
         */
        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        /**
         * Emits the JavaScript and declaration files.
         * When targetSource file is specified, emits the files corresponding to that source file,
         * otherwise for the whole program.
         * In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,
         * it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,
         * it will only emit all the affected files instead of whole program
         *
         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
         * in that order would be used to write the files
         */
        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;
        /** @internal */
        emitBuildInfo(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken): EmitResult;
        /**
         * Get the current directory of the program
         */
        getCurrentDirectory(): string;
        /** @internal */
        close(): void;
    }
    /**
     * The builder that caches the semantic diagnostics for the program and handles the changed files and affected files
     */
    interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {
        /**
         * Gets the semantic diagnostics from the program for the next affected file and caches it
         * Returns undefined if the iteration is complete
         */
        getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;
    }
    /**
     * The builder that can handle the changes in program and iterate through changed file to emit the files
     * The semantic diagnostics are cached per file and managed by clearing for the changed/affected files
     */
    interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {
        /**
         * Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete
         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
         * in that order would be used to write the files
         */
        emitNextAffectedFile(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): AffectedFileResult<EmitResult>;
    }
    /** @internal */
    function removeIgnoredPath(path: Path): Path | undefined;
    /**
     * Filter out paths like
     * "/", "/user", "/user/username", "/user/username/folderAtRoot",
     * "c:/", "c:/users", "c:/users/username", "c:/users/username/folderAtRoot", "c:/folderAtRoot"
     * @param dirPath
     *
     * @internal
     */
    function canWatchDirectoryOrFile(dirPath: Path): boolean;
    /** @internal */
    function createResolutionCache(resolutionHost: ResolutionCacheHost, rootDirForResolution: string | undefined, logChangesWhenResolvingModule: boolean): ResolutionCache;
    /**
     * This is the cache of module/typedirectives resolution that can be retained across program
     *
     * @internal
     */
    interface ResolutionCache {
        startRecordingFilesWithChangedResolutions(): void;
        finishRecordingFilesWithChangedResolutions(): Path[] | undefined;
        resolveModuleNameLiterals(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
        resolveTypeReferenceDirectiveReferences<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
        resolveSingleModuleNameWithoutWatching(moduleName: string, containingFile: string): ResolvedModuleWithFailedLookupLocations;
        invalidateResolutionsOfFailedLookupLocations(): boolean;
        invalidateResolutionOfFile(filePath: Path): void;
        removeResolutionsOfFile(filePath: Path): void;
        removeResolutionsFromProjectReferenceRedirects(filePath: Path): void;
        setFilesWithInvalidatedNonRelativeUnresolvedImports(filesWithUnresolvedImports: Map<Path, readonly string[]>): void;
        createHasInvalidatedResolutions(customHasInvalidatedResolutions: HasInvalidatedResolutions): HasInvalidatedResolutions;
        hasChangedAutomaticTypeDirectiveNames(): boolean;
        isFileWithInvalidatedNonRelativeUnresolvedImports(path: Path): boolean;
        startCachingPerDirectoryResolution(): void;
        finishCachingPerDirectoryResolution(newProgram: Program | undefined, oldProgram: Program | undefined): void;
        updateTypeRootsWatch(): void;
        closeTypeRootsWatch(): void;
        getModuleResolutionCache(): ModuleResolutionCache;
        clear(): void;
    }
    /** @internal */
    interface ResolutionWithFailedLookupLocations {
        failedLookupLocations?: string[];
        affectingLocations?: string[];
        isInvalidated?: boolean;
        refCount?: number;
        files?: Set<Path>;
    }
    /** @internal */
    interface CachedResolvedModuleWithFailedLookupLocations extends ResolvedModuleWithFailedLookupLocations, ResolutionWithFailedLookupLocations {
    }
    /** @internal */
    interface ResolutionCacheHost extends MinimalResolutionCacheHost {
        toPath(fileName: string): Path;
        getCanonicalFileName: GetCanonicalFileName;
        getCompilationSettings(): CompilerOptions;
        watchDirectoryOfFailedLookupLocation(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags): FileWatcher;
        watchAffectingFileLocation(file: string, cb: FileWatcherCallback): FileWatcher;
        onInvalidatedResolution(): void;
        watchTypeRootsDirectory(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags): FileWatcher;
        onChangedAutomaticTypeDirectiveNames(): void;
        scheduleInvalidateResolutionsOfFailedLookupLocations(): void;
        getCachedDirectoryStructureHost(): CachedDirectoryStructureHost | undefined;
        projectName?: string;
        getGlobalCache?(): string | undefined;
        globalCacheResolutionModuleName?(externalModuleName: string): string;
        writeLog(s: string): void;
        getCurrentProgram(): Program | undefined;
        fileIsOpen(filePath: Path): boolean;
        onDiscoveredSymlink?(): void;
    }
    /**
     * Create a function that reports error by writing to the system and handles the formatting of the diagnostic
     *
     * @internal
     */
    function createDiagnosticReporter(system: System, pretty?: boolean): DiagnosticReporter;
    /**
     * Get locale specific time based on whether we are in test mode
     *
     * @internal
     */
    function getLocaleTimeString(system: System): string;
    /**
     * Create a function that reports watch status by writing to the system and handles the formatting of the diagnostic
     *
     * @internal
     */
    function createWatchStatusReporter(system: System, pretty?: boolean): WatchStatusReporter;
    /**
     * Parses config file using System interface
     *
     * @internal
     */
    function parseConfigFileWithSystem(configFileName: string, optionsToExtend: CompilerOptions, extendedConfigCache: Map<string, ExtendedConfigCacheEntry> | undefined, watchOptionsToExtend: WatchOptions | undefined, system: System, reportDiagnostic: DiagnosticReporter): ParsedCommandLine | undefined;
    /** @internal */
    function getErrorCountForSummary(diagnostics: readonly Diagnostic[]): number;
    /** @internal */
    function getFilesInErrorForSummary(diagnostics: readonly Diagnostic[]): (ReportFileInError | undefined)[];
    /** @internal */
    function getWatchErrorSummaryDiagnosticMessage(errorCount: number): DiagnosticMessage;
    /** @internal */
    function getErrorSummaryText(errorCount: number, filesInError: readonly (ReportFileInError | undefined)[], newLine: string, host: HasCurrentDirectory): string;
    /** @internal */
    function isBuilderProgram(program: Program | BuilderProgram): program is BuilderProgram;
    /** @internal */
    function listFiles<T extends BuilderProgram>(program: Program | T, write: (s: string) => void): void;
    /** @internal */
    function explainFiles(program: Program, write: (s: string) => void): void;
    /** @internal */
    function explainIfFileIsRedirectAndImpliedFormat(file: SourceFile, fileNameConvertor?: (fileName: string) => string): DiagnosticMessageChain[] | undefined;
    /** @internal */
    function getMatchedFileSpec(program: Program, fileName: string): string | undefined;
    /** @internal */
    function getMatchedIncludeSpec(program: Program, fileName: string): string | true | undefined;
    /** @internal */
    function fileIncludeReasonToDiagnostics(program: Program, reason: FileIncludeReason, fileNameConvertor?: (fileName: string) => string): DiagnosticMessageChain;
    /**
     * Helper that emit files, report diagnostics and lists emitted and/or source files depending on compiler options
     *
     * @internal
     */
    function emitFilesAndReportErrors<T extends BuilderProgram>(program: Program | T, reportDiagnostic: DiagnosticReporter, write?: (s: string) => void, reportSummary?: ReportEmitErrorSummary, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): {
        emitResult: EmitResult;
        diagnostics: SortedReadonlyArray<Diagnostic>;
    };
    /** @internal */
    function emitFilesAndReportErrorsAndGetExitStatus<T extends BuilderProgram>(program: Program | T, reportDiagnostic: DiagnosticReporter, write?: (s: string) => void, reportSummary?: ReportEmitErrorSummary, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers, options?: CompilerOptions): ExitStatus.Success | ExitStatus.DiagnosticsPresent_OutputsSkipped | ExitStatus.DiagnosticsPresent_OutputsGenerated;
    /** @internal */
    function createWatchHost(system?: System, reportWatchStatus?: WatchStatusReporter): WatchHost;
    /** @internal */
    function createWatchFactory<Y = undefined>(host: WatchFactoryHost & {
        trace?(s: string): void;
    }, options: {
        extendedDiagnostics?: boolean;
        diagnostics?: boolean;
    }): ts.WatchFactoryWithLog<ts.WatchType, Y>;
    /** @internal */
    function createCompilerHostFromProgramHost(host: ProgramHost<any>, getCompilerOptions: () => CompilerOptions, directoryStructureHost?: DirectoryStructureHost): CompilerHost;
    /** @internal */
    function getSourceFileVersionAsHashFromText(host: Pick<CompilerHost, "createHash">, text: string): string;
    /** @internal */
    function setGetSourceFileAsHashVersioned(compilerHost: CompilerHost): void;
    /**
     * Creates the watch compiler host that can be extended with config file or root file names and options host
     *
     * @internal
     */
    function createProgramHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system: System, createProgram: CreateProgram<T> | undefined): ProgramHost<T>;
    /**
     * Creates the watch compiler host from system for config file in watch mode
     *
     * @internal
     */
    function createWatchCompilerHostOfConfigFile<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ configFileName, optionsToExtend, watchOptionsToExtend, extraFileExtensions, system, createProgram, reportDiagnostic, reportWatchStatus }: CreateWatchCompilerHostOfConfigFileInput<T>): WatchCompilerHostOfConfigFile<T>;
    /**
     * Creates the watch compiler host from system for compiling root files and options in watch mode
     *
     * @internal
     */
    function createWatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootFiles, options, watchOptions, projectReferences, system, createProgram, reportDiagnostic, reportWatchStatus }: CreateWatchCompilerHostOfFilesAndCompilerOptionsInput<T>): WatchCompilerHostOfFilesAndCompilerOptions<T>;
    /** @internal */
    function performIncrementalCompilation(input: IncrementalCompilationOptions): ExitStatus.Success | ExitStatus.DiagnosticsPresent_OutputsSkipped | ExitStatus.DiagnosticsPresent_OutputsGenerated;
    /** @internal */
    const screenStartingMessageCodes: number[];
    /** @internal */
    const noopFileWatcher: FileWatcher;
    /** @internal */
    const returnNoopFileWatcher: () => FileWatcher;
    /** @internal */
    type WatchType = WatchTypeRegistry[keyof WatchTypeRegistry];
    /** @internal */
    const WatchType: WatchTypeRegistry;
    /** @internal */
    interface WatchTypeRegistry {
        ConfigFile: "Config file";
        ExtendedConfigFile: "Extended config file";
        SourceFile: "Source file";
        MissingFile: "Missing file";
        WildcardDirectory: "Wild card directory";
        FailedLookupLocations: "Failed Lookup Locations";
        AffectingFileLocation: "File location affecting resolution";
        TypeRoots: "Type roots";
        ConfigFileOfReferencedProject: "Config file of referened project";
        ExtendedConfigOfReferencedProject: "Extended config file of referenced project";
        WildcardDirectoryOfReferencedProject: "Wild card directory of referenced project";
        PackageJson: "package.json file";
        ClosedScriptInfo: "Closed Script info";
        ConfigFileForInferredRoot: "Config file for the inferred project root";
        NodeModules: "node_modules for closed script infos and package.jsons affecting module specifier cache";
        MissingSourceMapFile: "Missing source map file";
        NoopConfigFileForInferredRoot: "Noop Config file for the inferred project root";
        MissingGeneratedFile: "Missing generated file";
        NodeModulesForModuleSpecifierCache: "node_modules for module specifier cache invalidation";
    }
    /** @internal */
    interface WatchFactoryWithLog<X, Y = undefined> extends WatchFactory<X, Y> {
        writeLog: (s: string) => void;
    }
    /** @internal */
    interface CreateWatchCompilerHostInput<T extends BuilderProgram> {
        system: System;
        createProgram?: CreateProgram<T>;
        reportDiagnostic?: DiagnosticReporter;
        reportWatchStatus?: WatchStatusReporter;
    }
    /** @internal */
    interface CreateWatchCompilerHostOfConfigFileInput<T extends BuilderProgram> extends CreateWatchCompilerHostInput<T> {
        configFileName: string;
        optionsToExtend?: CompilerOptions;
        watchOptionsToExtend?: WatchOptions;
        extraFileExtensions?: readonly FileExtensionInfo[];
    }
    /** @internal */
    interface CreateWatchCompilerHostOfFilesAndCompilerOptionsInput<T extends BuilderProgram> extends CreateWatchCompilerHostInput<T> {
        rootFiles: string[];
        options: CompilerOptions;
        watchOptions: WatchOptions | undefined;
        projectReferences?: readonly ProjectReference[];
    }
    /** @internal */
    interface IncrementalCompilationOptions {
        rootNames: readonly string[];
        options: CompilerOptions;
        configFileParsingDiagnostics?: readonly Diagnostic[];
        projectReferences?: readonly ProjectReference[];
        host?: CompilerHost;
        reportDiagnostic?: DiagnosticReporter;
        reportErrorSummary?: ReportEmitErrorSummary;
        afterProgramEmitAndDiagnostics?(program: EmitAndSemanticDiagnosticsBuilderProgram): void;
        system?: System;
    }
    function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): ts.EmitAndSemanticDiagnosticsBuilderProgram | undefined;
    function createIncrementalCompilerHost(options: CompilerOptions, system?: ts.System): CompilerHost;
    function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;
    /**
     * Create the watch compiler host for either configFile or fileNames and its options
     */
    function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;
    function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;
    /**
     * Creates the watch from the host for root files and compiler options
     */
    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;
    /**
     * Creates the watch from the host for config file
     */
    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;
    interface ReadBuildProgramHost {
        useCaseSensitiveFileNames(): boolean;
        getCurrentDirectory(): string;
        readFile(fileName: string): string | undefined;
        /** @internal */
        getBuildInfo?(fileName: string, configFilePath: string | undefined): BuildInfo | undefined;
    }
    interface IncrementalProgramOptions<T extends BuilderProgram> {
        rootNames: readonly string[];
        options: CompilerOptions;
        configFileParsingDiagnostics?: readonly Diagnostic[];
        projectReferences?: readonly ProjectReference[];
        host?: CompilerHost;
        createProgram?: CreateProgram<T>;
    }
    type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;
    /** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */
    type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;
    /** Host that has watch functionality used in --watch mode */
    interface WatchHost {
        /** If provided, called with Diagnostic message that informs about change in watch status */
        onWatchStatusChange?(diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number): void;
        /** Used to watch changes in source files, missing files needed to update the program or config file */
        watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
        /** Used to watch resolved module's failed lookup locations, config file specs, type roots where auto type reference directives are added */
        watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
        /** If provided, will be used to set delayed compilation, so that multiple changes in short span are compiled together */
        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
        /** If provided, will be used to reset existing delayed compilation */
        clearTimeout?(timeoutId: any): void;
    }
    interface ProgramHost<T extends BuilderProgram> {
        /**
         * Used to create the program when need for program creation or recreation detected
         */
        createProgram: CreateProgram<T>;
        useCaseSensitiveFileNames(): boolean;
        getNewLine(): string;
        getCurrentDirectory(): string;
        getDefaultLibFileName(options: CompilerOptions): string;
        getDefaultLibLocation?(): string;
        createHash?(data: string): string;
        /**
         * Use to check file presence for source files and
         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well
         */
        fileExists(path: string): boolean;
        /**
         * Use to read file text for source files and
         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well
         */
        readFile(path: string, encoding?: string): string | undefined;
        /** If provided, used for module resolution as well as to handle directory structure */
        directoryExists?(path: string): boolean;
        /** If provided, used in resolutions as well as handling directory structure */
        getDirectories?(path: string): string[];
        /** If provided, used to cache and handle directory structure modifications */
        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
        /** Symbol links resolution */
        realpath?(path: string): string;
        /** If provided would be used to write log about compilation */
        trace?(s: string): void;
        /** If provided is used to get the environment variable */
        getEnvironmentVariable?(name: string): string | undefined;
        /**
         * @deprecated supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext
         *
         * If provided, used to resolve the module names, otherwise typescript's default module resolution
         */
        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
        /**
         * @deprecated supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext
         *
         * If provided, used to resolve type reference directives, otherwise typescript's default resolution
         */
        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];
        resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
        resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
        /** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */
        hasInvalidatedResolutions?(filePath: Path): boolean;
        /**
         * Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it
         */
        getModuleResolutionCache?(): ModuleResolutionCache | undefined;
    }
    /**
     * Internal interface used to wire emit through same host
     *
     * @internal
     */
    interface ProgramHost<T extends BuilderProgram> {
        createDirectory?(path: string): void;
        writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;
        storeFilesChangingSignatureDuringEmit?: boolean;
        now?(): Date;
    }
    interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {
        /** Instead of using output d.ts file from project reference, use its source file */
        useSourceOfProjectReferenceRedirect?(): boolean;
        /** If provided, use this method to get parsed command lines for referenced projects */
        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
        /** If provided, callback to invoke after every new program creation */
        afterProgramCreate?(program: T): void;
    }
    /**
     * Host to create watch with root files and options
     */
    interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {
        /** root files to use to generate program */
        rootFiles: string[];
        /** Compiler options */
        options: CompilerOptions;
        watchOptions?: WatchOptions;
        /** Project References */
        projectReferences?: readonly ProjectReference[];
    }
    /**
     * Host to create watch with config file
     */
    interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {
        /** Name of the config file to compile */
        configFileName: string;
        /** Options to extend */
        optionsToExtend?: CompilerOptions;
        watchOptionsToExtend?: WatchOptions;
        extraFileExtensions?: readonly FileExtensionInfo[];
        /**
         * Used to generate source file names from the config file and its include, exclude, files rules
         * and also to cache the directory stucture
         */
        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
    }
    /**
     * Host to create watch with config file that is already parsed (from tsc)
     *
     * @internal
     */
    interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T> {
        configFileParsingResult?: ParsedCommandLine;
        extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>;
    }
    interface Watch<T> {
        /** Synchronize with host and get updated program */
        getProgram(): T;
        /**
         * Gets the existing program without synchronizing with changes on host
         *
         * @internal
         */
        getCurrentProgram(): T;
        /** Closes the watch */
        close(): void;
    }
    /**
     * Creates the watch what generates program using the config file
     */
    interface WatchOfConfigFile<T> extends Watch<T> {
    }
    /**
     * Creates the watch that generates program using the root files and compiler options
     */
    interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {
        /** Updates the root files in the program, only if this is not config file compilation */
        updateRootFileNames(fileNames: string[]): void;
    }
    /** @internal */
    function resolveConfigFileProjectName(project: string): ResolvedConfigFileName;
    /** @internal */
    enum UpToDateStatusType {
        Unbuildable = 0,
        UpToDate = 1,
        /**
         * The project appears out of date because its upstream inputs are newer than its outputs,
         * but all of its outputs are actually newer than the previous identical outputs of its (.d.ts) inputs.
         * This means we can Pseudo-build (just touch timestamps), as if we had actually built this project.
         */
        UpToDateWithUpstreamTypes = 2,
        /**
         * @deprecated
         * The project appears out of date because its upstream inputs are newer than its outputs,
         * but all of its outputs are actually newer than the previous identical outputs of its (.d.ts) inputs.
         * This means we can Pseudo-build (just manipulate outputs), as if we had actually built this project.
         */
        OutOfDateWithPrepend = 3,
        OutputMissing = 4,
        ErrorReadingFile = 5,
        OutOfDateWithSelf = 6,
        OutOfDateWithUpstream = 7,
        OutOfDateBuildInfo = 8,
        OutOfDateOptions = 9,
        OutOfDateRoots = 10,
        UpstreamOutOfDate = 11,
        UpstreamBlocked = 12,
        ComputingUpstream = 13,
        TsVersionOutputOfDate = 14,
        UpToDateWithInputFileText = 15,
        /**
         * Projects with no outputs (i.e. "solution" files)
         */
        ContainerOnly = 16,
        ForceBuild = 17
    }
    /** @internal */
    type UpToDateStatus = Status.Unbuildable | Status.UpToDate | Status.OutOfDateWithPrepend | Status.OutputMissing | Status.ErrorReadingFile | Status.OutOfDateWithSelf | Status.OutOfDateWithUpstream | Status.OutOfDateBuildInfo | Status.OutOfDateRoots | Status.UpstreamOutOfDate | Status.UpstreamBlocked | Status.ComputingUpstream | Status.TsVersionOutOfDate | Status.ContainerOnly | Status.ForceBuild;
    /** @internal */
    namespace Status {
        /**
         * The project can't be built at all in its current state. For example,
         * its config file cannot be parsed, or it has a syntax error or missing file
         */
        interface Unbuildable {
            type: UpToDateStatusType.Unbuildable;
            reason: string;
        }
        /**
         * This project doesn't have any outputs, so "is it up to date" is a meaningless question.
         */
        interface ContainerOnly {
            type: UpToDateStatusType.ContainerOnly;
        }
        /**
         * The project is up to date with respect to its inputs.
         * We track what the newest input file is.
         */
        interface UpToDate {
            type: UpToDateStatusType.UpToDate | UpToDateStatusType.UpToDateWithUpstreamTypes | UpToDateStatusType.UpToDateWithInputFileText;
            newestInputFileTime?: Date;
            newestInputFileName?: string;
            oldestOutputFileName: string;
        }
        /**
         * @deprecated
         * The project is up to date with respect to its inputs except for prepend output changed (no declaration file change in prepend).
         */
        interface OutOfDateWithPrepend {
            type: UpToDateStatusType.OutOfDateWithPrepend;
            outOfDateOutputFileName: string;
            newerProjectName: string;
        }
        /**
         * One or more of the outputs of the project does not exist.
         */
        interface OutputMissing {
            type: UpToDateStatusType.OutputMissing;
            /**
             * The name of the first output file that didn't exist
             */
            missingOutputFileName: string;
        }
        /** Error reading file */
        interface ErrorReadingFile {
            type: UpToDateStatusType.ErrorReadingFile;
            fileName: string;
        }
        /**
         * One or more of the project's outputs is older than its newest input.
         */
        interface OutOfDateWithSelf {
            type: UpToDateStatusType.OutOfDateWithSelf;
            outOfDateOutputFileName: string;
            newerInputFileName: string;
        }
        /**
         * Buildinfo indicates that build is out of date
         */
        interface OutOfDateBuildInfo {
            type: UpToDateStatusType.OutOfDateBuildInfo | UpToDateStatusType.OutOfDateOptions;
            buildInfoFile: string;
        }
        interface OutOfDateRoots {
            type: UpToDateStatusType.OutOfDateRoots;
            buildInfoFile: string;
            inputFile: Path;
        }
        /**
         * This project depends on an out-of-date project, so shouldn't be built yet
         */
        interface UpstreamOutOfDate {
            type: UpToDateStatusType.UpstreamOutOfDate;
            upstreamProjectName: string;
        }
        /**
         * This project depends an upstream project with build errors
         */
        interface UpstreamBlocked {
            type: UpToDateStatusType.UpstreamBlocked;
            upstreamProjectName: string;
            upstreamProjectBlocked: boolean;
        }
        /**
         *  Computing status of upstream projects referenced
         */
        interface ComputingUpstream {
            type: UpToDateStatusType.ComputingUpstream;
        }
        interface TsVersionOutOfDate {
            type: UpToDateStatusType.TsVersionOutputOfDate;
            version: string;
        }
        /**
         * One or more of the project's outputs is older than the newest output of
         * an upstream project.
         */
        interface OutOfDateWithUpstream {
            type: UpToDateStatusType.OutOfDateWithUpstream;
            outOfDateOutputFileName: string;
            newerProjectName: string;
        }
        interface ForceBuild {
            type: UpToDateStatusType.ForceBuild;
        }
    }
    /**
     * Helper to use now method instead of current date for testing purposes to get consistent baselines
     *
     * @internal
     */
    function getCurrentTime(host: {
        now?(): Date;
    }): Date;
    /** @internal */
    function isCircularBuildOrder(buildOrder: AnyBuildOrder): buildOrder is CircularBuildOrder;
    /** @internal */
    function getBuildOrderFromAnyBuildOrder(anyBuildOrder: AnyBuildOrder): BuildOrder;
    /**
     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
     */
    function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;
    function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: ts.System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): ts.SolutionBuilderHost<T>;
    function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: ts.System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): ts.SolutionBuilderWithWatchHost<T>;
    function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;
    function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;
    interface BuildOptions {
        dry?: boolean;
        force?: boolean;
        verbose?: boolean;
        /** @internal */ clean?: boolean;
        /** @internal */ watch?: boolean;
        /** @internal */ help?: boolean;
        /** @internal */ preserveWatchOutput?: boolean;
        /** @internal */ listEmittedFiles?: boolean;
        /** @internal */ listFiles?: boolean;
        /** @internal */ explainFiles?: boolean;
        /** @internal */ pretty?: boolean;
        incremental?: boolean;
        assumeChangesOnlyAffectDirectDependencies?: boolean;
        declaration?: boolean;
        declarationMap?: boolean;
        emitDeclarationOnly?: boolean;
        sourceMap?: boolean;
        inlineSourceMap?: boolean;
        traceResolution?: boolean;
        /** @internal */ diagnostics?: boolean;
        /** @internal */ extendedDiagnostics?: boolean;
        /** @internal */ locale?: string;
        /** @internal */ generateCpuProfile?: string;
        /** @internal */ generateTrace?: string;
        [option: string]: CompilerOptionsValue | undefined;
    }
    /** @internal */
    type ResolvedConfigFilePath = ResolvedConfigFileName & Path;
    type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) => void;
    interface ReportFileInError {
        fileName: string;
        line: number;
    }
    interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {
        createDirectory?(path: string): void;
        /**
         * Should provide create directory and writeFile if done of invalidatedProjects is not invoked with
         * writeFileCallback
         */
        writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;
        getCustomTransformers?: (project: string) => CustomTransformers | undefined;
        getModifiedTime(fileName: string): Date | undefined;
        setModifiedTime(fileName: string, date: Date): void;
        deleteFile(fileName: string): void;
        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
        reportDiagnostic: DiagnosticReporter;
        reportSolutionBuilderStatus: DiagnosticReporter;
        afterProgramEmitAndDiagnostics?(program: T): void;
        /** @deprecated @internal */ beforeEmitBundle?(config: ParsedCommandLine): void;
        /** @deprecated @internal */ afterEmitBundle?(config: ParsedCommandLine): void;
        /** @internal */ now?(): Date;
    }
    interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {
        reportErrorSummary?: ReportEmitErrorSummary;
    }
    interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {
    }
    /** @internal */
    type BuildOrder = readonly ResolvedConfigFileName[];
    /** @internal */
    interface CircularBuildOrder {
        buildOrder: BuildOrder;
        circularDiagnostics: readonly Diagnostic[];
    }
    /** @internal */
    type AnyBuildOrder = BuildOrder | CircularBuildOrder;
    interface SolutionBuilder<T extends BuilderProgram> {
        build(project?: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
        clean(project?: string): ExitStatus;
        buildReferences(project: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
        cleanReferences(project?: string): ExitStatus;
        getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject<T> | undefined;
        /** @internal */ getBuildOrder(): AnyBuildOrder;
        /** @internal */ getUpToDateStatusOfProject(project: string): UpToDateStatus;
        /** @internal */ invalidateProject(configFilePath: ResolvedConfigFilePath, reloadLevel?: ConfigFileProgramReloadLevel): void;
        /** @internal */ close(): void;
    }
    enum InvalidatedProjectKind {
        Build = 0,
        /** @deprecated */ UpdateBundle = 1,
        UpdateOutputFileStamps = 2
    }
    interface InvalidatedProjectBase {
        readonly kind: InvalidatedProjectKind;
        readonly project: ResolvedConfigFileName;
        /** @internal */ readonly projectPath: ResolvedConfigFilePath;
        /** @internal */ readonly buildOrder: readonly ResolvedConfigFileName[];
        /**
         *  To dispose this project and ensure that all the necessary actions are taken and state is updated accordingly
         */
        done(cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): ExitStatus;
        getCompilerOptions(): CompilerOptions;
        getCurrentDirectory(): string;
    }
    interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {
        readonly kind: InvalidatedProjectKind.UpdateOutputFileStamps;
        updateOutputFileStatmps(): void;
    }
    interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {
        readonly kind: InvalidatedProjectKind.Build;
        getBuilderProgram(): T | undefined;
        getProgram(): Program | undefined;
        getSourceFile(fileName: string): SourceFile | undefined;
        getSourceFiles(): readonly SourceFile[];
        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        getConfigFileParsingDiagnostics(): readonly Diagnostic[];
        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        getAllDependencies(sourceFile: SourceFile): readonly string[];
        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;
        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult | undefined;
    }
    /** @deprecated */
    interface UpdateBundleProject<T extends BuilderProgram> extends InvalidatedProjectBase {
        readonly kind: InvalidatedProjectKind.UpdateBundle;
        emit(writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): EmitResult | BuildInvalidedProject<T> | undefined;
    }
    type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T> | UpdateBundleProject<T>;
    namespace JsTyping {
        /** @internal */
        function isTypingUpToDate(cachedTyping: CachedTyping, availableTypingVersions: MapLike<string>): boolean;
        /** @internal */
        function nonRelativeModuleNameForTypingCache(moduleName: string): string;
        /** @internal */
        function loadSafeList(host: TypingResolutionHost, safeListPath: Path): SafeList;
        /** @internal */
        function loadTypesMap(host: TypingResolutionHost, typesMapPath: Path): SafeList | undefined;
        /**
         * @param host is the object providing I/O related operations.
         * @param fileNames are the file names that belong to the same project
         * @param projectRootPath is the path to the project root directory
         * @param safeListPath is the path used to retrieve the safe list
         * @param packageNameToTypingLocation is the map of package names to their cached typing locations and installed versions
         * @param typeAcquisition is used to customize the typing acquisition process
         * @param compilerOptions are used as a source for typing inference
         *
         * @internal
         */
        function discoverTypings(host: TypingResolutionHost, log: ((message: string) => void) | undefined, fileNames: string[], projectRootPath: Path, safeList: SafeList, packageNameToTypingLocation: ReadonlyMap<string, CachedTyping>, typeAcquisition: TypeAcquisition, unresolvedImports: readonly string[], typesRegistry: ReadonlyMap<string, MapLike<string>>, compilerOptions: CompilerOptions): {
            cachedTypingPaths: string[];
            newTypingNames: string[];
            filesToWatch: string[];
        };
        /**
         * Validates package name using rules defined at https://docs.npmjs.com/files/package.json
         *
         * @internal
         */
        function validatePackageName(packageName: string): PackageNameValidationResult;
        /** @internal */
        function renderPackageNameValidationFailure(result: PackageNameValidationResult, typing: string): string;
        /** @internal */
        interface TypingResolutionHost {
            directoryExists(path: string): boolean;
            fileExists(fileName: string): boolean;
            readFile(path: string, encoding?: string): string | undefined;
            readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[] | undefined, depth?: number): string[];
        }
        /** @internal */
        interface CachedTyping {
            typingLocation: string;
            version: Version;
        }
        /** @internal */
        const prefixedNodeCoreModuleList: string[];
        /** @internal */
        const nodeCoreModuleList: readonly string[];
        /** @internal */
        const nodeCoreModules: Set<string>;
        /**
         * A map of loose file names to library names that we are confident require typings
         *
         * @internal
         */
        type SafeList = ReadonlyMap<string, string>;
        /** @internal */
        enum NameValidationResult {
            Ok = 0,
            EmptyName = 1,
            NameTooLong = 2,
            NameStartsWithDot = 3,
            NameStartsWithUnderscore = 4,
            NameContainsNonURISafeCharacters = 5
        }
        /** @internal */
        interface ScopedPackageNameValidationResult {
            name: string;
            isScopeName: boolean;
            result: NameValidationResult;
        }
        /** @internal */
        type PackageNameValidationResult = NameValidationResult | ScopedPackageNameValidationResult;
    }
    namespace BreakpointResolver {
        /**
         * Get the breakpoint span in given sourceFile
         *
         * @internal
         */
        function spanInSourceFileAtLocation(sourceFile: SourceFile, position: number): TextSpan | undefined;
    }
    namespace CallHierarchy {
        /**
         * Resolves the call hierarchy declaration for a node.
         *
         * @internal
         */
        function resolveCallHierarchyDeclaration(program: Program, location: Node): CallHierarchyDeclaration | CallHierarchyDeclaration[] | undefined;
        /**
         * Creates a `CallHierarchyItem` for a call hierarchy declaration.
         *
         * @internal
         */
        function createCallHierarchyItem(program: Program, node: CallHierarchyDeclaration): CallHierarchyItem;
        /**
         * Gets the call sites that call into the provided call hierarchy declaration.
         *
         * @internal
         */
        function getIncomingCalls(program: Program, declaration: CallHierarchyDeclaration, cancellationToken: CancellationToken): CallHierarchyIncomingCall[];
        /**
         * Gets the call sites that call out of the provided call hierarchy declaration.
         *
         * @internal
         */
        function getOutgoingCalls(program: Program, declaration: CallHierarchyDeclaration): CallHierarchyOutgoingCall[];
        /** @internal */
        type NamedExpression = ClassExpression & {
            name: Identifier;
        } | FunctionExpression & {
            name: Identifier;
        };
        /** @internal */
        type ConstNamedExpression = ClassExpression & {
            name: undefined;
            parent: VariableDeclaration & {
                name: Identifier;
            };
        } | FunctionExpression & {
            name: undefined;
            parent: VariableDeclaration & {
                name: Identifier;
            };
        } | ArrowFunction & {
            name: undefined;
            parent: VariableDeclaration & {
                name: Identifier;
            };
        };
        /** @internal */
        type CallHierarchyDeclaration = SourceFile | ModuleDeclaration & {
            name: Identifier;
        } | FunctionDeclaration | ClassDeclaration | ClassStaticBlockDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | NamedExpression | ConstNamedExpression;
    }
    namespace classifier {
        namespace v2020 {
            /**
             * This is mainly used internally for testing
             *
             * @internal
             */
            function getSemanticClassifications(program: Program, cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): ClassifiedSpan2020[];
            /** @internal */
            function getEncodedSemanticClassifications(program: Program, cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): Classifications;
            /** @internal */
            enum TokenEncodingConsts {
                typeOffset = 8,
                modifierMask = 255
            }
            /** @internal */
            enum TokenType {
                class = 0,
                enum = 1,
                interface = 2,
                namespace = 3,
                typeParameter = 4,
                type = 5,
                parameter = 6,
                variable = 7,
                enumMember = 8,
                property = 9,
                function = 10,
                member = 11
            }
            /** @internal */
            enum TokenModifier {
                declaration = 0,
                static = 1,
                async = 2,
                readonly = 3,
                defaultLibrary = 4,
                local = 5
            }
        }
    }
    namespace codefix {
        /** @internal */
        function createCodeFixActionWithoutFixAll(fixName: string, changes: FileTextChanges[], description: DiagnosticAndArguments): CodeFixAction;
        /** @internal */
        function createCodeFixAction(fixName: string, changes: FileTextChanges[], description: DiagnosticAndArguments, fixId: {}, fixAllDescription: DiagnosticAndArguments, command?: CodeActionCommand): CodeFixAction;
        /** @internal */
        function createCodeFixActionMaybeFixAll(fixName: string, changes: FileTextChanges[], description: DiagnosticAndArguments, fixId?: {}, fixAllDescription?: DiagnosticAndArguments, command?: CodeActionCommand): CodeFixAction;
        /** @internal */
        function registerCodeFix(reg: CodeFixRegistration): void;
        /** @internal */
        function getSupportedErrorCodes(): readonly string[];
        /** @internal */
        function getFixes(context: CodeFixContext): readonly CodeFixAction[];
        /** @internal */
        function getAllFixes(context: CodeFixAllContext): CombinedCodeActions;
        /** @internal */
        function createCombinedCodeActions(changes: FileTextChanges[], commands?: CodeActionCommand[]): CombinedCodeActions;
        /** @internal */
        function createFileTextChanges(fileName: string, textChanges: TextChange[]): FileTextChanges;
        /** @internal */
        function codeFixAll(context: CodeFixAllContext, errorCodes: number[], use: (changes: textChanges.ChangeTracker, error: DiagnosticWithLocation, commands: Push<CodeActionCommand>) => void): CombinedCodeActions;
        /** @internal */
        function eachDiagnostic(context: CodeFixAllContext, errorCodes: readonly number[], cb: (diag: DiagnosticWithLocation) => void): void;
        /** @internal */
        function parameterShouldGetTypeFromJSDoc(node: Node): node is DeclarationWithType;
        /** @internal */
        type DeclarationWithType = FunctionLikeDeclaration | VariableDeclaration | PropertySignature | PropertyDeclaration;
        /** @internal */
        function createImportAdder(sourceFile: SourceFile, program: Program, preferences: UserPreferences, host: LanguageServiceHost, cancellationToken?: CancellationToken): ImportAdder;
        /** @internal */
        function createImportSpecifierResolver(importingFile: SourceFile, program: Program, host: LanguageServiceHost, preferences: UserPreferences): ImportSpecifierResolver;
        /** @internal */
        function getImportCompletionAction(targetSymbol: Symbol, moduleSymbol: Symbol, exportMapKey: string | undefined, sourceFile: SourceFile, symbolName: string, isJsxTagName: boolean, host: LanguageServiceHost, program: Program, formatContext: formatting.FormatContext, position: number, preferences: UserPreferences, cancellationToken: CancellationToken): {
            readonly moduleSpecifier: string;
            readonly codeAction: CodeAction;
        };
        /** @internal */
        function getPromoteTypeOnlyCompletionAction(sourceFile: SourceFile, symbolToken: Identifier, program: Program, host: LanguageServiceHost, formatContext: formatting.FormatContext, preferences: UserPreferences): CodeAction | undefined;
        /**
         * @param forceImportKeyword Indicates that the user has already typed `import`, so the result must start with `import`.
         * (In other words, do not allow `const x = require("...")` for JS files.)
         *
         * @internal
         */
        function getImportKind(importingFile: SourceFile, exportKind: ExportKind, compilerOptions: CompilerOptions, forceImportKeyword?: boolean): ImportKind;
        /** @internal */
        function moduleSymbolToValidIdentifier(moduleSymbol: Symbol, target: ScriptTarget | undefined, forceCapitalize: boolean): string;
        /** @internal */
        function moduleSpecifierToValidIdentifier(moduleSpecifier: string, target: ScriptTarget | undefined, forceCapitalize?: boolean): string;
        /** @internal */
        const importFixName = "import";
        /**
         * Computes multiple import additions to a file and writes them to a ChangeTracker.
         *
         * @internal
         */
        interface ImportAdder {
            hasFixes(): boolean;
            addImportFromDiagnostic: (diagnostic: DiagnosticWithLocation, context: CodeFixContextBase) => void;
            addImportFromExportedSymbol: (exportedSymbol: Symbol, isValidTypeOnlyUseSite?: boolean) => void;
            writeFixes: (changeTracker: textChanges.ChangeTracker) => void;
        }
        /**
         * Computes module specifiers for multiple import additions to a file.
         *
         * @internal
         */
        interface ImportSpecifierResolver {
            getModuleSpecifierForBestExportInfo(exportInfo: readonly SymbolExportInfo[], position: number, isValidTypeOnlyUseSite: boolean, fromCacheOnly?: boolean): {
                exportInfo?: SymbolExportInfo;
                moduleSpecifier: string;
                computedWithoutCacheCount: number;
            } | undefined;
        }
        /**
         * Finds members of the resolved type that are missing in the class pointed to by class decl
         * and generates source code for the missing members.
         * @param possiblyMissingSymbols The collection of symbols to filter and then get insertions for.
         * @param importAdder If provided, type annotations will use identifier type references instead of ImportTypeNodes, and the missing imports will be added to the importAdder.
         * @returns Empty string iff there are no member insertions.
         *
         * @internal
         */
        function createMissingMemberNodes(classDeclaration: ClassLikeDeclaration, possiblyMissingSymbols: readonly Symbol[], sourceFile: SourceFile, context: TypeConstructionContext, preferences: UserPreferences, importAdder: ImportAdder | undefined, addClassElement: (node: AddNode) => void): void;
        /** @internal */
        function getNoopSymbolTrackerWithResolver(context: TypeConstructionContext): SymbolTracker;
        /**
         * `addClassElement` will not be called if we can't figure out a representation for `symbol` in `enclosingDeclaration`.
         * @param body If defined, this will be the body of the member node passed to `addClassElement`. Otherwise, the body will default to a stub.
         *
         * @internal
         */
        function addNewNodeForMemberSymbol(symbol: Symbol, enclosingDeclaration: ClassLikeDeclaration, sourceFile: SourceFile, context: TypeConstructionContext, preferences: UserPreferences, importAdder: ImportAdder | undefined, addClassElement: (node: AddNode) => void, body: Block | undefined, preserveOptional?: PreserveOptionalFlags, isAmbient?: boolean): void;
        /** @internal */
        function createSignatureDeclarationFromSignature(kind: SyntaxKind.MethodDeclaration | SyntaxKind.FunctionExpression | SyntaxKind.ArrowFunction | SyntaxKind.FunctionDeclaration, context: TypeConstructionContext, quotePreference: QuotePreference, signature: Signature, body: Block | undefined, name: PropertyName | undefined, modifiers: NodeArray<Modifier> | undefined, optional: boolean | undefined, enclosingDeclaration: Node | undefined, importAdder: ImportAdder | undefined): FunctionDeclaration | MethodDeclaration | FunctionExpression | ArrowFunction | undefined;
        /** @internal */
        function createSignatureDeclarationFromCallExpression(kind: SyntaxKind.MethodDeclaration | SyntaxKind.FunctionDeclaration | SyntaxKind.MethodSignature, context: CodeFixContextBase, importAdder: ImportAdder, call: CallExpression, name: Identifier | string, modifierFlags: ModifierFlags, contextNode: Node): MethodDeclaration | FunctionDeclaration | MethodSignature;
        /** @internal */
        function typeToAutoImportableTypeNode(checker: TypeChecker, importAdder: ImportAdder, type: Type, contextNode: Node | undefined, scriptTarget: ScriptTarget, flags?: NodeBuilderFlags, tracker?: SymbolTracker): TypeNode | undefined;
        /** @internal */
        function getArgumentTypesAndTypeParameters(checker: TypeChecker, importAdder: ImportAdder, instanceTypes: Type[], contextNode: Node | undefined, scriptTarget: ScriptTarget, flags?: NodeBuilderFlags, tracker?: SymbolTracker): {
            argumentTypeNodes: TypeNode[];
            argumentTypeParameters: [
                string,
                ArgumentTypeParameterAndConstraint | undefined
            ][];
        };
        /** @internal */
        function createStubbedBody(text: string, quotePreference: QuotePreference): Block;
        /** @internal */
        function setJsonCompilerOptionValues(changeTracker: textChanges.ChangeTracker, configFile: TsConfigSourceFile, options: [
            string,
            Expression
        ][]): undefined;
        /** @internal */
        function setJsonCompilerOptionValue(changeTracker: textChanges.ChangeTracker, configFile: TsConfigSourceFile, optionName: string, optionValue: Expression): void;
        /** @internal */
        function createJsonPropertyAssignment(name: string, initializer: Expression): PropertyAssignment;
        /** @internal */
        function findJsonProperty(obj: ObjectLiteralExpression, name: string): PropertyAssignment | undefined;
        /**
         * Given a type node containing 'import("./a").SomeType<import("./b").OtherType<...>>',
         * returns an equivalent type reference node with any nested ImportTypeNodes also replaced
         * with type references, and a list of symbols that must be imported to use the type reference.
         *
         * @internal
         */
        function tryGetAutoImportableReferenceFromTypeNode(importTypeNode: TypeNode | undefined, scriptTarget: ScriptTarget): {
            typeNode: TypeNode;
            symbols: Symbol[];
        } | undefined;
        /** @internal */
        function importSymbols(importAdder: ImportAdder, symbols: readonly Symbol[]): void;
        /** @internal */
        function findAncestorMatchingSpan(sourceFile: SourceFile, span: TextSpan): Node;
        /** @internal */
        interface TypeConstructionContext {
            program: Program;
            host: LanguageServiceHost;
        }
        /** @internal */
        type AddNode = PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | FunctionExpression | ArrowFunction;
        /** @internal */
        enum PreserveOptionalFlags {
            Method = 1,
            Property = 2,
            All = 3
        }
        /** @internal */
        interface ArgumentTypeParameterAndConstraint {
            argumentType: Type;
            constraint?: TypeNode;
        }
        /** @internal */
        function generateAccessorFromProperty(file: SourceFile, program: Program, start: number, end: number, context: textChanges.TextChangesContext, _actionName: string): FileTextChanges[] | undefined;
        /** @internal */
        function getAccessorConvertiblePropertyAtPosition(file: SourceFile, program: Program, start: number, end: number, considerEmptySpans?: boolean): AccessorOrRefactorErrorInfo | undefined;
        /** @internal */
        function getAllSupers(decl: ClassOrInterface | undefined, checker: TypeChecker): readonly ClassOrInterface[];
        /** @internal */
        type AcceptedDeclaration = ParameterPropertyDeclaration | PropertyDeclaration | PropertyAssignment;
        /** @internal */
        type AcceptedNameType = Identifier | StringLiteral;
        /** @internal */
        type ContainerDeclaration = ClassLikeDeclaration | ObjectLiteralExpression;
        /** @internal */
        type AccessorOrRefactorErrorInfo = AccessorInfo | refactor.RefactorErrorInfo;
        /** @internal */
        interface AccessorInfo {
            readonly container: ContainerDeclaration;
            readonly isStatic: boolean;
            readonly isReadonly: boolean;
            readonly type: TypeNode | undefined;
            readonly declaration: AcceptedDeclaration;
            readonly fieldName: AcceptedNameType;
            readonly accessorName: AcceptedNameType;
            readonly originalName: string;
            readonly renameAccessor: boolean;
        }
        /** @internal */
        type ClassOrInterface = ClassLikeDeclaration | InterfaceDeclaration;
    }
    namespace Completions {
        namespace StringCompletions {
            /** @internal */
            function getStringLiteralCompletions(sourceFile: SourceFile, position: number, contextToken: Node | undefined, options: CompilerOptions, host: LanguageServiceHost, program: Program, log: Log, preferences: UserPreferences, includeSymbol: boolean): CompletionInfo | undefined;
            /** @internal */
            function getStringLiteralCompletionDetails(name: string, sourceFile: SourceFile, position: number, contextToken: Node | undefined, checker: TypeChecker, options: CompilerOptions, host: LanguageServiceHost, cancellationToken: CancellationToken, preferences: UserPreferences): CompletionEntryDetails | undefined;
        }
        /** @internal */
        function getCompletionsAtPosition(host: LanguageServiceHost, program: Program, log: Log, sourceFile: SourceFile, position: number, preferences: UserPreferences, triggerCharacter: CompletionsTriggerCharacter | undefined, completionKind: CompletionTriggerKind | undefined, cancellationToken: CancellationToken, formatContext?: formatting.FormatContext, includeSymbol?: boolean): CompletionInfo | undefined;
        /** @internal */
        function getCompletionEntriesFromSymbols(symbols: readonly Symbol[], entries: SortedArray<CompletionEntry>, replacementToken: Node | undefined, contextToken: Node | undefined, location: Node, position: number, sourceFile: SourceFile, host: LanguageServiceHost, program: Program, target: ScriptTarget, log: Log, kind: CompletionKind, preferences: UserPreferences, compilerOptions: CompilerOptions, formatContext: formatting.FormatContext | undefined, isTypeOnlyLocation?: boolean, propertyAccessToConvert?: PropertyAccessExpression, jsxIdentifierExpected?: boolean, isJsxInitializer?: IsJsxInitializer, importStatementCompletion?: ImportStatementCompletionInfo, recommendedCompletion?: Symbol, symbolToOriginInfoMap?: SymbolOriginInfoMap, symbolToSortTextMap?: SymbolSortTextMap, isJsxIdentifierExpected?: boolean, isRightOfOpenTag?: boolean, includeSymbol?: boolean): UniqueNameSet;
        /** @internal */
        function getCompletionEntryDetails(program: Program, log: Log, sourceFile: SourceFile, position: number, entryId: CompletionEntryIdentifier, host: LanguageServiceHost, formatContext: formatting.FormatContext, preferences: UserPreferences, cancellationToken: CancellationToken): CompletionEntryDetails | undefined;
        /** @internal */
        function createCompletionDetailsForSymbol(symbol: Symbol, name: string, checker: TypeChecker, sourceFile: SourceFile, location: Node, cancellationToken: CancellationToken, codeActions?: CodeAction[], sourceDisplay?: SymbolDisplayPart[]): CompletionEntryDetails;
        /** @internal */
        function createCompletionDetails(name: string, kindModifiers: string, kind: ScriptElementKind, displayParts: SymbolDisplayPart[], documentation?: SymbolDisplayPart[], tags?: JSDocTagInfo[], codeActions?: CodeAction[], source?: SymbolDisplayPart[]): CompletionEntryDetails;
        /** @internal */
        function getCompletionEntrySymbol(program: Program, log: Log, sourceFile: SourceFile, position: number, entryId: CompletionEntryIdentifier, host: LanguageServiceHost, preferences: UserPreferences): Symbol | undefined;
        /** @internal */
        function getPropertiesForObjectExpression(contextualType: Type, completionsType: Type | undefined, obj: ObjectLiteralExpression | JsxAttributes, checker: TypeChecker): Symbol[];
        /** @internal */
        const moduleSpecifierResolutionLimit = 100;
        /** @internal */
        const moduleSpecifierResolutionCacheAttemptLimit = 1000;
        /** @internal */
        type Log = (message: string) => void;
        /** @internal */
        type SortText = string & {
            __sortText: any;
        };
        /** @internal */
        const SortText: {
            LocalDeclarationPriority: SortText;
            LocationPriority: SortText;
            OptionalMember: SortText;
            MemberDeclaredBySpreadAssignment: SortText;
            SuggestedClassMembers: SortText;
            GlobalsOrKeywords: SortText;
            AutoImportSuggestions: SortText;
            ClassMemberSnippets: SortText;
            JavascriptIdentifiers: SortText;
            Deprecated(sortText: SortText): SortText;
            ObjectLiteralProperty(presetSortText: SortText, symbolDisplayName: string): SortText;
            SortBelow(sortText: SortText): SortText;
        };
        /**
         * Special values for `CompletionInfo['source']` used to disambiguate
         * completion items with the same `name`. (Each completion item must
         * have a unique name/source combination, because those two fields
         * comprise `CompletionEntryIdentifier` in `getCompletionEntryDetails`.
         *
         * When the completion item is an auto-import suggestion, the source
         * is the module specifier of the suggestion. To avoid collisions,
         * the values here should not be a module specifier we would ever
         * generate for an auto-import.
         *
         * @internal
         */
        enum CompletionSource {
            /** Completions that require `this.` insertion text */
            ThisProperty = "ThisProperty/",
            /** Auto-import that comes attached to a class member snippet */
            ClassMemberSnippet = "ClassMemberSnippet/",
            /** A type-only import that needs to be promoted in order to be used at the completion location */
            TypeOnlyAlias = "TypeOnlyAlias/",
            /** Auto-import that comes attached to an object literal method snippet */
            ObjectLiteralMethodSnippet = "ObjectLiteralMethodSnippet/",
            /** Case completions for switch statements */
            SwitchCases = "SwitchCases/"
        }
        /** @internal */
        enum SymbolOriginInfoKind {
            ThisType = 1,
            SymbolMember = 2,
            Export = 4,
            Promise = 8,
            Nullable = 16,
            ResolvedExport = 32,
            TypeOnlyAlias = 64,
            ObjectLiteralMethod = 128,
            Ignore = 256,
            ComputedPropertyName = 512,
            SymbolMemberNoExport = 2,
            SymbolMemberExport = 6
        }
        /** @internal */
        interface SymbolOriginInfo {
            kind: SymbolOriginInfoKind;
            isDefaultExport?: boolean;
            isFromPackageJson?: boolean;
            fileName?: string;
        }
        /** @internal */
        interface UniqueNameSet {
            add(name: string): void;
            has(name: string): boolean;
        }
        /**
         * Map from symbol index in `symbols` -> SymbolOriginInfo.
         *
         * @internal
         */
        type SymbolOriginInfoMap = Record<number, SymbolOriginInfo>;
        /**
         * Map from symbol id -> SortText.
         *
         * @internal
         */
        type SymbolSortTextMap = (SortText | undefined)[];
        /** @internal */
        interface CompletionEntryIdentifier {
            name: string;
            source?: string;
            data?: CompletionEntryData;
        }
        /**
         * true: after the `=` sign but no identifier has been typed yet. Else is the Identifier after the initializer.
         *
         * @internal
         */
        type IsJsxInitializer = boolean | Identifier;
        /** @internal */
        enum CompletionKind {
            ObjectPropertyDeclaration = 0,
            Global = 1,
            PropertyAccess = 2,
            MemberLike = 3,
            String = 4,
            None = 5
        }
        /** @internal */
        interface ImportStatementCompletionInfo {
            isKeywordOnlyCompletion: boolean;
            keywordCompletion: TokenSyntaxKind | undefined;
            isNewIdentifierLocation: boolean;
            isTopLevelTypeOnly: boolean;
            couldBeTypeOnlyImportSpecifier: boolean;
            replacementSpan: TextSpan | undefined;
        }
    }
    namespace FindAllReferences {
        /**
         * Creates the imports map and returns an ImportTracker that uses it. Call this lazily to avoid calling `getDirectImportsMap` unnecessarily.
         *
         * @internal
         */
        function createImportTracker(sourceFiles: readonly SourceFile[], sourceFilesSet: ReadonlySet<string>, checker: TypeChecker, cancellationToken: CancellationToken | undefined): ImportTracker;
        /** @internal */
        function findModuleReferences(program: Program, sourceFiles: readonly SourceFile[], searchModuleSymbol: Symbol): ModuleReference[];
        /**
         * Given a local reference, we might notice that it's an import/export and recursively search for references of that.
         * If at an import, look locally for the symbol it imports.
         * If at an export, look for all imports of it.
         * This doesn't handle export specifiers; that is done in `getReferencesAtExportSpecifier`.
         * @param comingFromExport If we are doing a search for all exports, don't bother looking backwards for the imported symbol, since that's the reason we're here.
         *
         * @internal
         */
        function getImportOrExportSymbol(node: Node, symbol: Symbol, checker: TypeChecker, comingFromExport: boolean): ImportedSymbol | ExportedSymbol | undefined;
        /** @internal */
        function getExportInfo(exportSymbol: Symbol, exportKind: ExportKind, checker: TypeChecker): ExportInfo | undefined;
        /** @internal */
        interface ImportsResult {
            /** For every import of the symbol, the location and local symbol for the import. */
            importSearches: readonly [
                Identifier,
                Symbol
            ][];
            /** For rename imports/exports `{ foo as bar }`, `foo` is not a local, so it may be added as a reference immediately without further searching. */
            singleReferences: readonly (Identifier | StringLiteral)[];
            /** List of source files that may (or may not) use the symbol via a namespace. (For UMD modules this is every file.) */
            indirectUsers: readonly SourceFile[];
        }
        /** @internal */
        type ImportTracker = (exportSymbol: Symbol, exportInfo: ExportInfo, isForRename: boolean) => ImportsResult;
        /**
         * Info about an exported symbol to perform recursive search on.
         *
         * @internal
         */
        interface ExportInfo {
            exportingModuleSymbol: Symbol;
            exportKind: ExportKind;
        }
        /** @internal */
        enum ExportKind {
            Named = 0,
            Default = 1,
            ExportEquals = 2
        }
        /** @internal */
        enum ImportExport {
            Import = 0,
            Export = 1
        }
        /** @internal */
        type ModuleReference =
        /** "import" also includes require() calls. */
        {
            kind: "import";
            literal: StringLiteralLike;
        }
        /** <reference path> or <reference types> */
         | {
            kind: "reference";
            referencingFile: SourceFile;
            ref: FileReference;
        };
        /** @internal */
        interface ImportedSymbol {
            kind: ImportExport.Import;
            symbol: Symbol;
        }
        /** @internal */
        interface ExportedSymbol {
            kind: ImportExport.Export;
            symbol: Symbol;
            exportInfo: ExportInfo;
        }
        /** @internal */
        function nodeEntry(node: Node, kind?: NodeEntryKind): NodeEntry;
        /** @internal */
        function isContextWithStartAndEndNode(node: ContextNode): node is ContextWithStartAndEndNode;
        /** @internal */
        function getContextNode(node: NamedDeclaration | BinaryExpression | ForInOrOfStatement | undefined): ContextNode | undefined;
        /** @internal */
        function toContextSpan(textSpan: TextSpan, sourceFile: SourceFile, context?: ContextNode): {
            contextSpan: TextSpan;
        } | undefined;
        /** @internal */
        function findReferencedSymbols(program: Program, cancellationToken: CancellationToken, sourceFiles: readonly SourceFile[], sourceFile: SourceFile, position: number): ReferencedSymbol[] | undefined;
        /** @internal */
        function getImplementationsAtPosition(program: Program, cancellationToken: CancellationToken, sourceFiles: readonly SourceFile[], sourceFile: SourceFile, position: number): ImplementationLocation[] | undefined;
        /** @internal */
        function findReferenceOrRenameEntries<T>(program: Program, cancellationToken: CancellationToken, sourceFiles: readonly SourceFile[], node: Node, position: number, options: Options | undefined, convertEntry: ToReferenceOrRenameEntry<T>): T[] | undefined;
        /** @internal */
        function getReferenceEntriesForNode(position: number, node: Node, program: Program, sourceFiles: readonly SourceFile[], cancellationToken: CancellationToken, options?: Options, sourceFilesSet?: ReadonlySet<string>): readonly Entry[] | undefined;
        /** @internal */
        function toRenameLocation(entry: Entry, originalNode: Node, checker: TypeChecker, providePrefixAndSuffixText: boolean): RenameLocation;
        /** @internal */
        function toReferenceEntry(entry: Entry): ReferenceEntry;
        /** @internal */
        function toHighlightSpan(entry: Entry): {
            fileName: string;
            span: HighlightSpan;
        };
        /** @internal */
        function getTextSpanOfEntry(entry: Entry): TextSpan;
        /**
         * Whether a reference, `node`, is a definition of the `target` symbol
         *
         * @internal
         */
        function isDeclarationOfSymbol(node: Node, target: Symbol | undefined): boolean;
        /** @internal */
        interface SymbolAndEntries {
            readonly definition: Definition | undefined;
            readonly references: readonly Entry[];
        }
        /** @internal */
        enum DefinitionKind {
            Symbol = 0,
            Label = 1,
            Keyword = 2,
            This = 3,
            String = 4,
            TripleSlashReference = 5
        }
        /** @internal */
        type Definition = {
            readonly type: DefinitionKind.Symbol;
            readonly symbol: Symbol;
        } | {
            readonly type: DefinitionKind.Label;
            readonly node: Identifier;
        } | {
            readonly type: DefinitionKind.Keyword;
            readonly node: Node;
        } | {
            readonly type: DefinitionKind.This;
            readonly node: Node;
        } | {
            readonly type: DefinitionKind.String;
            readonly node: StringLiteralLike;
        } | {
            readonly type: DefinitionKind.TripleSlashReference;
            readonly reference: FileReference;
            readonly file: SourceFile;
        };
        /** @internal */
        enum EntryKind {
            Span = 0,
            Node = 1,
            StringLiteral = 2,
            SearchedLocalFoundProperty = 3,
            SearchedPropertyFoundLocal = 4
        }
        /** @internal */
        type NodeEntryKind = EntryKind.Node | EntryKind.StringLiteral | EntryKind.SearchedLocalFoundProperty | EntryKind.SearchedPropertyFoundLocal;
        /** @internal */
        type Entry = NodeEntry | SpanEntry;
        /** @internal */
        interface ContextWithStartAndEndNode {
            start: Node;
            end: Node;
        }
        /** @internal */
        type ContextNode = Node | ContextWithStartAndEndNode;
        /** @internal */
        interface NodeEntry {
            readonly kind: NodeEntryKind;
            readonly node: Node;
            readonly context?: ContextNode;
        }
        /** @internal */
        interface SpanEntry {
            readonly kind: EntryKind.Span;
            readonly fileName: string;
            readonly textSpan: TextSpan;
        }
        /** @internal */
        enum FindReferencesUse {
            /**
             * When searching for references to a symbol, the location will not be adjusted (this is the default behavior when not specified).
             */
            Other = 0,
            /**
             * When searching for references to a symbol, the location will be adjusted if the cursor was on a keyword.
             */
            References = 1,
            /**
             * When searching for references to a symbol, the location will be adjusted if the cursor was on a keyword.
             * Unlike `References`, the location will only be adjusted keyword belonged to a declaration with a valid name.
             * If set, we will find fewer references -- if it is referenced by several different names, we still only find references for the original name.
             */
            Rename = 2
        }
        /** @internal */
        interface Options {
            readonly findInStrings?: boolean;
            readonly findInComments?: boolean;
            readonly use?: FindReferencesUse;
            /** True if we are searching for implementations. We will have a different method of adding references if so. */
            readonly implementations?: boolean;
            /**
             * True to opt in for enhanced renaming of shorthand properties and import/export specifiers.
             * The options controls the behavior for the whole rename operation; it cannot be changed on a per-file basis.
             * Default is false for backwards compatibility.
             */
            readonly providePrefixAndSuffixTextForRename?: boolean;
        }
        /** @internal */
        type ToReferenceOrRenameEntry<T> = (entry: Entry, originalNode: Node, checker: TypeChecker) => T;
        /**
         * Encapsulates the core find-all-references algorithm.
         *
         * @internal
         */
        namespace Core {
            /** Core find-all-references algorithm. Handles special cases before delegating to `getReferencedSymbolsForSymbol`. */
            function getReferencedSymbolsForNode(position: number, node: Node, program: Program, sourceFiles: readonly SourceFile[], cancellationToken: CancellationToken, options?: Options, sourceFilesSet?: ReadonlySet<string>): readonly SymbolAndEntries[] | undefined;
            function getAdjustedNode(node: Node, options: Options): Node;
            function getReferencesForFileName(fileName: string, program: Program, sourceFiles: readonly SourceFile[], sourceFilesSet?: ReadonlySet<string>): readonly Entry[];
            function eachExportReference(sourceFiles: readonly SourceFile[], checker: TypeChecker, cancellationToken: CancellationToken | undefined, exportSymbol: Symbol, exportingModuleSymbol: Symbol, exportName: string, isDefaultExport: boolean, cb: (ref: Identifier) => void): void;
            /** Used as a quick check for whether a symbol is used at all in a file (besides its definition). */
            function isSymbolReferencedInFile(definition: Identifier, checker: TypeChecker, sourceFile: SourceFile, searchContainer?: Node): boolean;
            function eachSymbolReferenceInFile<T>(definition: Identifier, checker: TypeChecker, sourceFile: SourceFile, cb: (token: Identifier) => T, searchContainer?: Node): T | undefined;
            function getTopMostDeclarationNamesInFile(declarationName: string, sourceFile: SourceFile): readonly Node[];
            function someSignatureUsage(signature: SignatureDeclaration, sourceFiles: readonly SourceFile[], checker: TypeChecker, cb: (name: Identifier, call?: CallExpression) => boolean): boolean;
            /**
             * Given an initial searchMeaning, extracted from a location, widen the search scope based on the declarations
             * of the corresponding symbol. e.g. if we are searching for "Foo" in value position, but "Foo" references a class
             * then we need to widen the search to include type positions as well.
             * On the contrary, if we are searching for "Bar" in type position and we trace bar to an interface, and an uninstantiated
             * module, we want to keep the search limited to only types, as the two declarations (interface and uninstantiated module)
             * do not intersect in any of the three spaces.
             */
            function getIntersectingMeaningFromDeclarations(node: Node, symbol: Symbol): SemanticMeaning;
            function getReferenceEntriesForShorthandPropertyAssignment(node: Node, checker: TypeChecker, addReference: (node: Node) => void): void;
        }
    }
    namespace GoToDefinition {
        /** @internal */
        function getDefinitionAtPosition(program: Program, sourceFile: SourceFile, position: number, searchOtherFilesOnly?: boolean, stopAtAlias?: boolean): readonly DefinitionInfo[] | undefined;
        /** @internal */
        function getReferenceAtPosition(sourceFile: SourceFile, position: number, program: Program): {
            reference: FileReference;
            fileName: string;
            unverified: boolean;
            file?: SourceFile;
        } | undefined;
        /** @internal */
        function getTypeDefinitionAtPosition(typeChecker: TypeChecker, sourceFile: SourceFile, position: number): readonly DefinitionInfo[] | undefined;
        /** @internal */
        function getDefinitionAndBoundSpan(program: Program, sourceFile: SourceFile, position: number): DefinitionInfoAndBoundSpan | undefined;
        /**
         * Creates a DefinitionInfo from a Declaration, using the declaration's name if possible.
         *
         * @internal
         */
        function createDefinitionInfo(declaration: Declaration, checker: TypeChecker, symbol: Symbol, node: Node, unverified?: boolean, failedAliasResolution?: boolean): DefinitionInfo;
        /** @internal */
        function findReferenceInPosition(refs: readonly FileReference[], pos: number): FileReference | undefined;
    }
    namespace InlayHints {
        /** @internal */
        function provideInlayHints(context: InlayHintsContext): InlayHint[];
    }
    namespace JsDoc {
        /** @internal */
        function getJsDocCommentsFromDeclarations(declarations: readonly Declaration[], checker?: TypeChecker): SymbolDisplayPart[];
        /** @internal */
        function getJsDocTagsFromDeclarations(declarations?: Declaration[], checker?: TypeChecker): JSDocTagInfo[];
        /** @internal */
        function getJSDocTagNameCompletions(): CompletionEntry[];
        /** @internal */
        function getJSDocTagCompletions(): CompletionEntry[];
        /** @internal */
        function getJSDocTagCompletionDetails(name: string): CompletionEntryDetails;
        /** @internal */
        function getJSDocParameterNameCompletions(tag: JSDocParameterTag): CompletionEntry[];
        /** @internal */
        function getJSDocParameterNameCompletionDetails(name: string): CompletionEntryDetails;
        /**
         * Checks if position points to a valid position to add JSDoc comments, and if so,
         * returns the appropriate template. Otherwise returns an empty string.
         * Valid positions are
         *      - outside of comments, statements, and expressions, and
         *      - preceding a:
         *          - function/constructor/method declaration
         *          - class declarations
         *          - variable statements
         *          - namespace declarations
         *          - interface declarations
         *          - method signatures
         *          - type alias declarations
         *
         * Hosts should ideally check that:
         * - The line is all whitespace up to 'position' before performing the insertion.
         * - If the keystroke sequence "/\*\*" induced the call, we also check that the next
         * non-whitespace character is '*', which (approximately) indicates whether we added
         * the second '*' to complete an existing (JSDoc) comment.
         * @param fileName The file in which to perform the check.
         * @param position The (character-indexed) position in the file where the check should
         * be performed.
         *
         * @internal
         */
        function getDocCommentTemplateAtPosition(newLine: string, sourceFile: SourceFile, position: number, options?: DocCommentTemplateOptions): TextInsertion | undefined;
        /** @internal */
        const getJSDocTagNameCompletionDetails: typeof getJSDocTagCompletionDetails;
    }
    namespace NavigateTo {
        /** @internal */
        function getNavigateToItems(sourceFiles: readonly SourceFile[], checker: TypeChecker, cancellationToken: CancellationToken, searchValue: string, maxResultCount: number | undefined, excludeDtsFiles: boolean): NavigateToItem[];
    }
    namespace NavigationBar {
        /** @internal */
        function getNavigationBarItems(sourceFile: SourceFile, cancellationToken: CancellationToken): NavigationBarItem[];
        /** @internal */
        function getNavigationTree(sourceFile: SourceFile, cancellationToken: CancellationToken): NavigationTree;
    }
    namespace OrganizeImports {
        /**
         * Organize imports by:
         *   1) Removing unused imports
         *   2) Coalescing imports from the same module
         *   3) Sorting imports
         *
         * @internal
         */
        function organizeImports(sourceFile: SourceFile, formatContext: formatting.FormatContext, host: LanguageServiceHost, program: Program, preferences: UserPreferences, mode: OrganizeImportsMode): FileTextChanges[];
        /**
         * @param importGroup a list of ImportDeclarations, all with the same module name.
         *
         * @deprecated Only used for testing
         * @internal
         */
        function coalesceImports(importGroup: readonly ImportDeclaration[], ignoreCase: boolean, sourceFile?: SourceFile): readonly ImportDeclaration[];
        /**
         * @param exportGroup a list of ExportDeclarations, all with the same module name.
         *
         * @deprecated Only used for testing
         * @internal
         */
        function coalesceExports(exportGroup: readonly ExportDeclaration[], ignoreCase: boolean): readonly ExportDeclaration[];
        /** @internal */
        function compareImportOrExportSpecifiers<T extends ImportOrExportSpecifier>(s1: T, s2: T, comparer: Comparer<string>): Comparison;
        /**
         * Exported for testing
         *
         * @deprecated Only used for testing
         * @internal
         */
        function compareModuleSpecifiers(m1: Expression | undefined, m2: Expression | undefined, ignoreCase?: boolean): Comparison;
        /** @internal */
        function detectSorting(sourceFile: SourceFile, preferences: UserPreferences): SortKind;
        /** @internal */
        function detectImportDeclarationSorting(imports: readonly AnyImportOrRequireStatement[], preferences: UserPreferences): SortKind;
        /** @internal */
        function getImportDeclarationInsertionIndex(sortedImports: readonly AnyImportOrRequireStatement[], newImport: AnyImportOrRequireStatement, comparer: Comparer<string>): number;
        /** @internal */
        function getImportSpecifierInsertionIndex(sortedImports: readonly ImportSpecifier[], newImport: ImportSpecifier, comparer: Comparer<string>): number;
        /** @internal */
        function compareImportsOrRequireStatements(s1: AnyImportOrRequireStatement, s2: AnyImportOrRequireStatement, comparer: Comparer<string>): Comparison;
        /** @internal */
        function getOrganizeImportsComparer(preferences: UserPreferences, ignoreCase: boolean): Comparer<string>;
        /** @internal */
        const detectImportSpecifierSorting: (args_0: readonly ImportSpecifier[], args_1: UserPreferences) => SortKind;
    }
    namespace OutliningElementsCollector {
        /** @internal */
        function collectElements(sourceFile: SourceFile, cancellationToken: CancellationToken): OutliningSpan[];
    }
    namespace refactor {
        namespace addOrRemoveBracesToArrowFunction {
        }
        namespace convertArrowFunctionOrFunctionExpression {
        }
        namespace convertParamsToDestructuredObject {
        }
        namespace convertStringOrTemplateLiteral {
        }
        namespace convertToOptionalChainExpression {
        }
        namespace extractSymbol {
            /**
             * Compute the associated code actions
             * Exported for tests.
             *
             * @internal
             */
            function getRefactorActionsToExtractSymbol(context: RefactorContext): readonly ApplicableRefactorInfo[];
            /**
             * Exported for tests
             *
             * @internal
             */
            function getRefactorEditsToExtractSymbol(context: RefactorContext, actionName: string): RefactorEditInfo | undefined;
            /**
             * getRangeToExtract takes a span inside a text file and returns either an expression or an array
             * of statements representing the minimum set of nodes needed to extract the entire span. This
             * process may fail, in which case a set of errors is returned instead. These errors are shown to
             * users if they have the provideRefactorNotApplicableReason option set.
             *
             * @internal
             */
            function getRangeToExtract(sourceFile: SourceFile, span: TextSpan, invoked?: boolean): RangeToExtract;
            /** @internal */
            namespace Messages {
                const cannotExtractRange: DiagnosticMessage;
                const cannotExtractImport: DiagnosticMessage;
                const cannotExtractSuper: DiagnosticMessage;
                const cannotExtractJSDoc: DiagnosticMessage;
                const cannotExtractEmpty: DiagnosticMessage;
                const expressionExpected: DiagnosticMessage;
                const uselessConstantType: DiagnosticMessage;
                const statementOrExpressionExpected: DiagnosticMessage;
                const cannotExtractRangeContainingConditionalBreakOrContinueStatements: DiagnosticMessage;
                const cannotExtractRangeContainingConditionalReturnStatement: DiagnosticMessage;
                const cannotExtractRangeContainingLabeledBreakOrContinueStatementWithTargetOutsideOfTheRange: DiagnosticMessage;
                const cannotExtractRangeThatContainsWritesToReferencesLocatedOutsideOfTheTargetRangeInGenerators: DiagnosticMessage;
                const typeWillNotBeVisibleInTheNewScope: DiagnosticMessage;
                const functionWillNotBeVisibleInTheNewScope: DiagnosticMessage;
                const cannotExtractIdentifier: DiagnosticMessage;
                const cannotExtractExportedEntity: DiagnosticMessage;
                const cannotWriteInExpression: DiagnosticMessage;
                const cannotExtractReadonlyPropertyInitializerOutsideConstructor: DiagnosticMessage;
                const cannotExtractAmbientBlock: DiagnosticMessage;
                const cannotAccessVariablesFromNestedScopes: DiagnosticMessage;
                const cannotExtractToJSClass: DiagnosticMessage;
                const cannotExtractToExpressionArrowFunction: DiagnosticMessage;
                const cannotExtractFunctionsContainingThisToMethod: DiagnosticMessage;
            }
            /** @internal */
            enum RangeFacts {
                None = 0,
                HasReturn = 1,
                IsGenerator = 2,
                IsAsyncFunction = 4,
                UsesThis = 8,
                UsesThisInFunction = 16,
                /**
                 * The range is in a function which needs the 'static' modifier in a class
                 */
                InStaticRegion = 32
            }
            /**
             * Represents an expression or a list of statements that should be extracted with some extra information
             *
             * @internal
             */
            interface TargetRange {
                readonly range: Expression | Statement[];
                readonly facts: RangeFacts;
                /**
                 * If `this` is referring to a function instead of class, we need to retrieve its type.
                 */
                readonly thisNode: Node | undefined;
            }
            /**
             * Result of 'getRangeToExtract' operation: contains either a range or a list of errors
             *
             * @internal
             */
            type RangeToExtract = {
                readonly targetRange?: never;
                readonly errors: readonly Diagnostic[];
            } | {
                readonly targetRange: TargetRange;
                readonly errors?: never;
            };
        }
        namespace generateGetAccessorAndSetAccessor {
        }
        namespace inferFunctionReturnType {
        }
        /**
         * @param name An unique code associated with each refactor. Does not have to be human-readable.
         *
         * @internal
         */
        function registerRefactor(name: string, refactor: Refactor): void;
        /** @internal */
        function getApplicableRefactors(context: RefactorContext): ApplicableRefactorInfo[];
        /** @internal */
        function getEditsForRefactor(context: RefactorContext, refactorName: string, actionName: string): RefactorEditInfo | undefined;
        /** @internal */
        function doChangeNamedToNamespaceOrDefault(sourceFile: SourceFile, program: Program, changes: textChanges.ChangeTracker, toConvert: NamedImports, shouldUseDefault?: boolean): void;
        /**
         * Checks if some refactor info has refactor error info.
         *
         * @internal
         */
        function isRefactorErrorInfo(info: unknown): info is RefactorErrorInfo;
        /**
         * Checks if string "known" begins with string "requested".
         * Used to match requested kinds with a known kind.
         *
         * @internal
         */
        function refactorKindBeginsWith(known: string, requested: string | undefined): boolean;
        /**
         * Returned by refactor functions when some error message needs to be surfaced to users.
         *
         * @internal
         */
        interface RefactorErrorInfo {
            error: string;
        }
    }
    namespace Rename {
        /** @internal */
        function getRenameInfo(program: Program, sourceFile: SourceFile, position: number, preferences: UserPreferences): RenameInfo;
        /** @internal */
        function nodeIsEligibleForRename(node: Node): boolean;
    }
    namespace SignatureHelp {
        /** @internal */
        function getSignatureHelpItems(program: Program, sourceFile: SourceFile, position: number, triggerReason: SignatureHelpTriggerReason | undefined, cancellationToken: CancellationToken): SignatureHelpItems | undefined;
        /** @internal */
        function getArgumentInfoForCompletions(node: Node, position: number, sourceFile: SourceFile): ArgumentInfoForCompletions | undefined;
        /** @internal */
        interface ArgumentInfoForCompletions {
            readonly invocation: CallLikeExpression;
            readonly argumentIndex: number;
            readonly argumentCount: number;
        }
    }
    namespace SmartSelectionRange {
        /** @internal */
        function getSmartSelectionRange(pos: number, sourceFile: SourceFile): SelectionRange;
    }
    namespace SymbolDisplay {
        /** @internal */
        function getSymbolKind(typeChecker: TypeChecker, symbol: Symbol, location: Node): ScriptElementKind;
        /** @internal */
        function getSymbolModifiers(typeChecker: TypeChecker, symbol: Symbol): string;
        /** @internal */
        function getSymbolDisplayPartsDocumentationAndSymbolKind(typeChecker: TypeChecker, symbol: Symbol, sourceFile: SourceFile, enclosingDeclaration: Node | undefined, location: Node, semanticMeaning?: SemanticMeaning, alias?: Symbol): SymbolDisplayPartsDocumentationAndSymbolKind;
        /** @internal */
        interface SymbolDisplayPartsDocumentationAndSymbolKind {
            displayParts: SymbolDisplayPart[];
            documentation: SymbolDisplayPart[];
            symbolKind: ScriptElementKind;
            tags: JSDocTagInfo[] | undefined;
        }
    }
    namespace textChanges {
        /** @internal */
        function isThisTypeAnnotatable(containingFunction: SignatureDeclaration): containingFunction is ThisTypeAnnotatable;
        /** @internal */
        function getNewFileText(statements: readonly Statement[], scriptKind: ScriptKind, newLineCharacter: string, formatContext: formatting.FormatContext): string;
        /** @internal */
        function applyChanges(text: string, changes: readonly TextChange[]): string;
        /** @internal */
        function assignPositionsToNode(node: Node): Node;
        /** @internal */
        function createWriter(newLine: string): TextChangesWriter;
        /** @internal */
        function isValidLocationToAddComment(sourceFile: SourceFile, position: number): boolean;
        /**
         * Warning: This deletes comments too. See `copyComments` in `convertFunctionToEs6Class`.
         *
         * @internal
         */
        function deleteNode(changes: ChangeTracker, sourceFile: SourceFile, node: Node, options?: ConfigurableStartEnd): void;
        /** @internal */
        interface ConfigurableStart {
            leadingTriviaOption?: LeadingTriviaOption;
        }
        /** @internal */
        interface ConfigurableEnd {
            trailingTriviaOption?: TrailingTriviaOption;
        }
        /** @internal */
        enum LeadingTriviaOption {
            /** Exclude all leading trivia (use getStart()) */
            Exclude = 0,
            /** Include leading trivia and,
             * if there are no line breaks between the node and the previous token,
             * include all trivia between the node and the previous token
             */
            IncludeAll = 1,
            /**
             * Include attached JSDoc comments
             */
            JSDoc = 2,
            /**
             * Only delete trivia on the same line as getStart().
             * Used to avoid deleting leading comments
             */
            StartLine = 3
        }
        /** @internal */
        enum TrailingTriviaOption {
            /** Exclude all trailing trivia (use getEnd()) */
            Exclude = 0,
            /** Doesn't include whitespace, but does strip comments */
            ExcludeWhitespace = 1,
            /** Include trailing trivia */
            Include = 2
        }
        /**
         * Usually node.pos points to a position immediately after the previous token.
         * If this position is used as a beginning of the span to remove - it might lead to removing the trailing trivia of the previous node, i.e:
         * const x; // this is x
         *        ^ - pos for the next variable declaration will point here
         * const y; // this is y
         *        ^ - end for previous variable declaration
         * Usually leading trivia of the variable declaration 'y' should not include trailing trivia (whitespace, comment 'this is x' and newline) from the preceding
         * variable declaration and trailing trivia for 'y' should include (whitespace, comment 'this is y', newline).
         * By default when removing nodes we adjust start and end positions to respect specification of the trivia above.
         * If pos\end should be interpreted literally (that is, withouth including leading and trailing trivia), `leadingTriviaOption` should be set to `LeadingTriviaOption.Exclude`
         * and `trailingTriviaOption` to `TrailingTriviaOption.Exclude`.
         *
         * @internal
         */
        interface ConfigurableStartEnd extends ConfigurableStart, ConfigurableEnd {
        }
        /** @internal */
        interface InsertNodeOptions {
            /**
             * Text to be inserted before the new node
             */
            prefix?: string;
            /**
             * Text to be inserted after the new node
             */
            suffix?: string;
            /**
             * Text of inserted node will be formatted with this indentation, otherwise indentation will be inferred from the old node
             */
            indentation?: number;
            /**
             * Text of inserted node will be formatted with this delta, otherwise delta will be inferred from the new node kind
             */
            delta?: number;
        }
        /** @internal */
        interface ReplaceWithMultipleNodesOptions extends InsertNodeOptions {
            readonly joiner?: string;
        }
        /** @internal */
        interface ChangeNodeOptions extends ConfigurableStartEnd, InsertNodeOptions {
        }
        /** @internal */
        interface TextChangesContext {
            host: LanguageServiceHost;
            formatContext: formatting.FormatContext;
            preferences: UserPreferences;
        }
        /** @internal */
        type TypeAnnotatable = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertyDeclaration | PropertySignature;
        /** @internal */
        type ThisTypeAnnotatable = FunctionDeclaration | FunctionExpression;
        /** @internal */
        class ChangeTracker {
            private readonly newLineCharacter;
            private readonly formatContext;
            private readonly changes;
            private readonly newFiles;
            private readonly classesWithNodesInsertedAtStart;
            private readonly deletedNodes;
            static fromContext(context: TextChangesContext): ChangeTracker;
            static with(context: TextChangesContext, cb: (tracker: ChangeTracker) => void): FileTextChanges[];
            /** Public for tests only. Other callers should use `ChangeTracker.with`. */
            constructor(newLineCharacter: string, formatContext: formatting.FormatContext);
            pushRaw(sourceFile: SourceFile, change: FileTextChanges): void;
            deleteRange(sourceFile: SourceFile, range: TextRange): void;
            delete(sourceFile: SourceFile, node: Node | NodeArray<TypeParameterDeclaration>): void;
            /** Stop! Consider using `delete` instead, which has logic for deleting nodes from delimited lists. */
            deleteNode(sourceFile: SourceFile, node: Node, options?: ConfigurableStartEnd): void;
            deleteNodes(sourceFile: SourceFile, nodes: readonly Node[], options: ConfigurableStartEnd | undefined, hasTrailingComment: boolean): void;
            deleteModifier(sourceFile: SourceFile, modifier: Modifier): void;
            deleteNodeRange(sourceFile: SourceFile, startNode: Node, endNode: Node, options?: ConfigurableStartEnd): void;
            deleteNodeRangeExcludingEnd(sourceFile: SourceFile, startNode: Node, afterEndNode: Node | undefined, options?: ConfigurableStartEnd): void;
            replaceRange(sourceFile: SourceFile, range: TextRange, newNode: Node, options?: InsertNodeOptions): void;
            replaceNode(sourceFile: SourceFile, oldNode: Node, newNode: Node, options?: ChangeNodeOptions): void;
            replaceNodeRange(sourceFile: SourceFile, startNode: Node, endNode: Node, newNode: Node, options?: ChangeNodeOptions): void;
            private replaceRangeWithNodes;
            replaceNodeWithNodes(sourceFile: SourceFile, oldNode: Node, newNodes: readonly Node[], options?: ChangeNodeOptions): void;
            replaceNodeWithText(sourceFile: SourceFile, oldNode: Node, text: string): void;
            replaceNodeRangeWithNodes(sourceFile: SourceFile, startNode: Node, endNode: Node, newNodes: readonly Node[], options?: ReplaceWithMultipleNodesOptions & ConfigurableStartEnd): void;
            nodeHasTrailingComment(sourceFile: SourceFile, oldNode: Node, configurableEnd?: ConfigurableEnd): boolean;
            private nextCommaToken;
            replacePropertyAssignment(sourceFile: SourceFile, oldNode: PropertyAssignment, newNode: PropertyAssignment): void;
            insertNodeAt(sourceFile: SourceFile, pos: number, newNode: Node, options?: InsertNodeOptions): void;
            private insertNodesAt;
            insertNodeAtTopOfFile(sourceFile: SourceFile, newNode: Statement, blankLineBetween: boolean): void;
            insertNodesAtTopOfFile(sourceFile: SourceFile, newNodes: readonly Statement[], blankLineBetween: boolean): void;
            private insertAtTopOfFile;
            insertFirstParameter(sourceFile: SourceFile, parameters: NodeArray<ParameterDeclaration>, newParam: ParameterDeclaration): void;
            insertNodeBefore(sourceFile: SourceFile, before: Node, newNode: Node, blankLineBetween?: boolean, options?: ConfigurableStartEnd): void;
            insertModifierAt(sourceFile: SourceFile, pos: number, modifier: SyntaxKind, options?: InsertNodeOptions): void;
            insertModifierBefore(sourceFile: SourceFile, modifier: SyntaxKind, before: Node): void;
            insertCommentBeforeLine(sourceFile: SourceFile, lineNumber: number, position: number, commentText: string): void;
            insertJsdocCommentBefore(sourceFile: SourceFile, node: HasJSDoc, tag: JSDoc): void;
            private createJSDocText;
            replaceJSDocComment(sourceFile: SourceFile, node: HasJSDoc, tags: readonly JSDocTag[]): void;
            addJSDocTags(sourceFile: SourceFile, parent: HasJSDoc, newTags: readonly JSDocTag[]): void;
            filterJSDocTags(sourceFile: SourceFile, parent: HasJSDoc, predicate: (tag: JSDocTag) => boolean): void;
            replaceRangeWithText(sourceFile: SourceFile, range: TextRange, text: string): void;
            insertText(sourceFile: SourceFile, pos: number, text: string): void;
            /** Prefer this over replacing a node with another that has a type annotation, as it avoids reformatting the other parts of the node. */
            tryInsertTypeAnnotation(sourceFile: SourceFile, node: TypeAnnotatable, type: TypeNode): boolean;
            tryInsertThisTypeAnnotation(sourceFile: SourceFile, node: ThisTypeAnnotatable, type: TypeNode): void;
            insertTypeParameters(sourceFile: SourceFile, node: SignatureDeclaration, typeParameters: readonly TypeParameterDeclaration[]): void;
            private getOptionsForInsertNodeBefore;
            insertNodeAtConstructorStart(sourceFile: SourceFile, ctr: ConstructorDeclaration, newStatement: Statement): void;
            insertNodeAtConstructorStartAfterSuperCall(sourceFile: SourceFile, ctr: ConstructorDeclaration, newStatement: Statement): void;
            insertNodeAtConstructorEnd(sourceFile: SourceFile, ctr: ConstructorDeclaration, newStatement: Statement): void;
            private replaceConstructorBody;
            insertNodeAtEndOfScope(sourceFile: SourceFile, scope: Node, newNode: Node): void;
            insertMemberAtStart(sourceFile: SourceFile, node: ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode, newElement: ClassElement | PropertySignature | MethodSignature): void;
            insertNodeAtObjectStart(sourceFile: SourceFile, obj: ObjectLiteralExpression, newElement: ObjectLiteralElementLike): void;
            private insertNodeAtStartWorker;
            /**
             * Tries to guess the indentation from the existing members of a class/interface/object. All members must be on
             * new lines and must share the same indentation.
             */
            private guessIndentationFromExistingMembers;
            private computeIndentationForNewMember;
            private getInsertNodeAtStartInsertOptions;
            insertNodeAfterComma(sourceFile: SourceFile, after: Node, newNode: Node): void;
            insertNodeAfter(sourceFile: SourceFile, after: Node, newNode: Node): void;
            insertNodeAtEndOfList(sourceFile: SourceFile, list: NodeArray<Node>, newNode: Node): void;
            insertNodesAfter(sourceFile: SourceFile, after: Node, newNodes: readonly Node[]): void;
            private insertNodeAfterWorker;
            private getInsertNodeAfterOptions;
            private getInsertNodeAfterOptionsWorker;
            insertName(sourceFile: SourceFile, node: FunctionExpression | ClassExpression | ArrowFunction, name: string): void;
            insertExportModifier(sourceFile: SourceFile, node: DeclarationStatement | VariableStatement): void;
            insertImportSpecifierAtIndex(sourceFile: SourceFile, importSpecifier: ImportSpecifier, namedImports: NamedImports, index: number): void;
            /**
             * This function should be used to insert nodes in lists when nodes don't carry separators as the part of the node range,
             * i.e. arguments in arguments lists, parameters in parameter lists etc.
             * Note that separators are part of the node in statements and class elements.
             */
            insertNodeInListAfter(sourceFile: SourceFile, after: Node, newNode: Node, containingList?: NodeArray<Node> | undefined): void;
            parenthesizeExpression(sourceFile: SourceFile, expression: Expression): void;
            private finishClassesWithNodesInsertedAtStart;
            private finishDeleteDeclarations;
            /**
             * Note: after calling this, the TextChanges object must be discarded!
             * @param validate only for tests
             *    The reason we must validate as part of this method is that `getNonFormattedText` changes the node's positions,
             *    so we can only call this once and can't get the non-formatted text separately.
             */
            getChanges(validate?: ValidateNonFormattedText): FileTextChanges[];
            createNewFile(oldFile: SourceFile | undefined, fileName: string, statements: readonly (Statement | SyntaxKind.NewLineTrivia)[]): void;
        }
        /** @internal */
        type ValidateNonFormattedText = (node: Node, text: string) => void;
        /** @internal */
        interface TextChangesWriter extends EmitTextWriter, PrintHandlers {
        }
    }
    namespace formatting {
        /** @internal */
        enum FormattingRequestKind {
            FormatDocument = 0,
            FormatSelection = 1,
            FormatOnEnter = 2,
            FormatOnSemicolon = 3,
            FormatOnOpeningCurlyBrace = 4,
            FormatOnClosingCurlyBrace = 5
        }
        /** @internal */
        class FormattingContext {
            readonly sourceFile: SourceFileLike;
            formattingRequestKind: FormattingRequestKind;
            options: FormatCodeSettings;
            currentTokenSpan: TextRangeWithKind;
            nextTokenSpan: TextRangeWithKind;
            contextNode: Node;
            currentTokenParent: Node;
            nextTokenParent: Node;
            private contextNodeAllOnSameLine;
            private nextNodeAllOnSameLine;
            private tokensAreOnSameLine;
            private contextNodeBlockIsOnOneLine;
            private nextNodeBlockIsOnOneLine;
            constructor(sourceFile: SourceFileLike, formattingRequestKind: FormattingRequestKind, options: FormatCodeSettings);
            updateContext(currentRange: TextRangeWithKind, currentTokenParent: Node, nextRange: TextRangeWithKind, nextTokenParent: Node, commonParent: Node): void;
            ContextNodeAllOnSameLine(): boolean;
            NextNodeAllOnSameLine(): boolean;
            TokensAreOnSameLine(): boolean;
            ContextNodeBlockIsOnOneLine(): boolean;
            NextNodeBlockIsOnOneLine(): boolean;
            private NodeIsOnOneLine;
            private BlockIsOnOneLine;
        }
        /** @internal */
        function getFormattingScanner<T>(text: string, languageVariant: LanguageVariant, startPos: number, endPos: number, cb: (scanner: FormattingScanner) => T): T;
        /** @internal */
        interface FormattingScanner {
            advance(): void;
            getStartPos(): number;
            isOnToken(): boolean;
            isOnEOF(): boolean;
            readTokenInfo(n: Node): TokenInfo;
            readEOFTokenRange(): TextRangeWithKind;
            getCurrentLeadingTrivia(): TextRangeWithKind[] | undefined;
            lastTrailingTriviaWasNewLine(): boolean;
            skipToEndOf(node: Node | NodeArray<Node>): void;
            skipToStartOf(node: Node): void;
        }
        /** @internal */
        interface Rule {
            readonly debugName: string;
            readonly context: readonly ContextPredicate[];
            readonly action: RuleAction;
            readonly flags: RuleFlags;
        }
        /** @internal */
        type ContextPredicate = (context: FormattingContext) => boolean;
        /** @internal */
        const anyContext: readonly ContextPredicate[];
        /** @internal */
        enum RuleAction {
            None = 0,
            StopProcessingSpaceActions = 1,
            StopProcessingTokenActions = 2,
            InsertSpace = 4,
            InsertNewLine = 8,
            DeleteSpace = 16,
            DeleteToken = 32,
            InsertTrailingSemicolon = 64,
            StopAction = 3,
            ModifySpaceAction = 28,
            ModifyTokenAction = 96
        }
        /** @internal */
        enum RuleFlags {
            None = 0,
            CanDeleteNewLines = 1
        }
        /** @internal */
        interface TokenRange {
            readonly tokens: readonly SyntaxKind[];
            readonly isSpecific: boolean;
        }
        /** @internal */
        function getAllRules(): RuleSpec[];
        /** @internal */
        interface RuleSpec {
            readonly leftTokenRange: TokenRange;
            readonly rightTokenRange: TokenRange;
            readonly rule: Rule;
        }
        /** @internal */
        function getFormatContext(options: FormatCodeSettings, host: FormattingHost): FormatContext;
        /** @internal */
        type RulesMap = (context: FormattingContext) => readonly Rule[] | undefined;
        /** @internal */
        function createTextRangeWithKind<T extends SyntaxKind>(pos: number, end: number, kind: T): TextRangeWithKind<T>;
        /** @internal */
        function formatOnEnter(position: number, sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
        /** @internal */
        function formatOnSemicolon(position: number, sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
        /** @internal */
        function formatOnOpeningCurly(position: number, sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
        /** @internal */
        function formatOnClosingCurly(position: number, sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
        /** @internal */
        function formatDocument(sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
        /** @internal */
        function formatSelection(start: number, end: number, sourceFile: SourceFile, formatContext: FormatContext): TextChange[];
        /** @internal */
        function formatNodeGivenIndentation(node: Node, sourceFileLike: SourceFileLike, languageVariant: LanguageVariant, initialIndentation: number, delta: number, formatContext: FormatContext): TextChange[];
        /**
         *
         * @internal
         */
        function getRangeOfEnclosingComment(sourceFile: SourceFile, position: number, precedingToken?: Node | null, tokenAtPosition?: Node): CommentRange | undefined;
        /** @internal */
        function getIndentationString(indentation: number, options: EditorSettings): string;
        /** @internal */
        interface FormatContext {
            readonly options: FormatCodeSettings;
            readonly getRules: RulesMap;
            readonly host: FormattingHost;
        }
        /** @internal */
        interface TextRangeWithKind<T extends SyntaxKind = SyntaxKind> extends TextRange {
            kind: T;
        }
        /** @internal */
        type TextRangeWithTriviaKind = TextRangeWithKind<TriviaSyntaxKind>;
        /** @internal */
        interface TokenInfo {
            leadingTrivia: TextRangeWithTriviaKind[] | undefined;
            token: TextRangeWithKind;
            trailingTrivia: TextRangeWithTriviaKind[] | undefined;
        }
        /** @internal */
        namespace SmartIndenter {
            /**
             * @param assumeNewLineBeforeCloseBrace
             * `false` when called on text from a real source file.
             * `true` when we need to assume `position` is on a newline.
             *
             * This is useful for codefixes. Consider
             * ```
             * function f() {
             * |}
             * ```
             * with `position` at `|`.
             *
             * When inserting some text after an open brace, we would like to get indentation as if a newline was already there.
             * By default indentation at `position` will be 0 so 'assumeNewLineBeforeCloseBrace' overrides this behavior.
             */
            function getIndentation(position: number, sourceFile: SourceFile, options: EditorSettings, assumeNewLineBeforeCloseBrace?: boolean): number;
            function getIndentationForNode(n: Node, ignoreActualIndentationRange: TextRange, sourceFile: SourceFile, options: EditorSettings): number;
            function getBaseIndentation(options: EditorSettings): number;
            function isArgumentAndStartLineOverlapsExpressionBeingCalled(parent: Node, child: Node, childStartLine: number, sourceFile: SourceFileLike): boolean;
            function childStartsOnTheSameLineWithElseInIfStatement(parent: Node, child: TextRangeWithKind, childStartLine: number, sourceFile: SourceFileLike): boolean;
            function childIsUnindentedBranchOfConditionalExpression(parent: Node, child: TextRangeWithKind, childStartLine: number, sourceFile: SourceFileLike): boolean;
            function argumentStartsOnSameLineAsPreviousArgument(parent: Node, child: TextRangeWithKind, childStartLine: number, sourceFile: SourceFileLike): boolean;
            function getContainingList(node: Node, sourceFile: SourceFile): NodeArray<Node> | undefined;
            /**
             * Character is the actual index of the character since the beginning of the line.
             * Column - position of the character after expanding tabs to spaces.
             * "0\t2$"
             * value of 'character' for '$' is 3
             * value of 'column' for '$' is 6 (assuming that tab size is 4)
             */
            function findFirstNonWhitespaceCharacterAndColumn(startPos: number, endPos: number, sourceFile: SourceFileLike, options: EditorSettings): {
                column: number;
                character: number;
            };
            function findFirstNonWhitespaceColumn(startPos: number, endPos: number, sourceFile: SourceFileLike, options: EditorSettings): number;
            function nodeWillIndentChild(settings: FormatCodeSettings, parent: TextRangeWithKind, child: TextRangeWithKind | undefined, sourceFile: SourceFileLike | undefined, indentByDefault: boolean): boolean;
            /**
             * True when the parent node should indent the given child by an explicit rule.
             * @param isNextChild If true, we are judging indent of a hypothetical child *after* this one, not the current child.
             */
            function shouldIndentChildNode(settings: FormatCodeSettings, parent: TextRangeWithKind, child?: Node, sourceFile?: SourceFileLike, isNextChild?: boolean): boolean;
        }
    }
    function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;
    /**
     * Represents an immutable snapshot of a script at a specified time.Once acquired, the
     * snapshot is observably immutable. i.e. the same calls with the same parameters will return
     * the same values.
     */
    interface IScriptSnapshot {
        /** Gets a portion of the script snapshot specified by [start, end). */
        getText(start: number, end: number): string;
        /** Gets the length of this script snapshot. */
        getLength(): number;
        /**
         * Gets the TextChangeRange that describe how the text changed between this text and
         * an older version.  This information is used by the incremental parser to determine
         * what sections of the script need to be re-parsed.  'undefined' can be returned if the
         * change range cannot be determined.  However, in that case, incremental parsing will
         * not happen and the entire document will be re - parsed.
         */
        getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange | undefined;
        /** Releases all resources held by this script snapshot */
        dispose?(): void;
    }
    namespace ScriptSnapshot {
        function fromString(text: string): IScriptSnapshot;
    }
    interface PreProcessedFileInfo {
        referencedFiles: FileReference[];
        typeReferenceDirectives: FileReference[];
        libReferenceDirectives: FileReference[];
        importedFiles: FileReference[];
        ambientExternalModules?: string[];
        isLibFile: boolean;
    }
    interface HostCancellationToken {
        isCancellationRequested(): boolean;
    }
    interface InstallPackageOptions {
        fileName: Path;
        packageName: string;
    }
    /** @internal */
    enum PackageJsonDependencyGroup {
        Dependencies = 1,
        DevDependencies = 2,
        PeerDependencies = 4,
        OptionalDependencies = 8,
        All = 15
    }
    /** @internal */
    interface ProjectPackageJsonInfo {
        fileName: string;
        parseable: boolean;
        dependencies?: Map<string, string>;
        devDependencies?: Map<string, string>;
        peerDependencies?: Map<string, string>;
        optionalDependencies?: Map<string, string>;
        get(dependencyName: string, inGroups?: PackageJsonDependencyGroup): string | undefined;
        has(dependencyName: string, inGroups?: PackageJsonDependencyGroup): boolean;
    }
    /** @internal */
    interface FormattingHost {
        getNewLine?(): string;
    }
    /** @internal */
    enum PackageJsonAutoImportPreference {
        Off = 0,
        On = 1,
        Auto = 2
    }
    interface PerformanceEvent {
        kind: "UpdateGraph" | "CreatePackageJsonAutoImportProvider";
        durationMs: number;
    }
    enum LanguageServiceMode {
        Semantic = 0,
        PartialSemantic = 1,
        Syntactic = 2
    }
    interface IncompleteCompletionsCache {
        get(): CompletionInfo | undefined;
        set(response: CompletionInfo): void;
        clear(): void;
    }
    interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalResolutionCacheHost {
        getCompilationSettings(): CompilerOptions;
        getNewLine?(): string;
        getProjectVersion?(): string;
        getScriptFileNames(): string[];
        getScriptKind?(fileName: string): ScriptKind;
        getScriptVersion(fileName: string): string;
        getScriptSnapshot(fileName: string): IScriptSnapshot | undefined;
        getProjectReferences?(): readonly ProjectReference[] | undefined;
        getLocalizedDiagnosticMessages?(): any;
        getCancellationToken?(): HostCancellationToken;
        getCurrentDirectory(): string;
        getDefaultLibFileName(options: CompilerOptions): string;
        log?(s: string): void;
        trace?(s: string): void;
        error?(s: string): void;
        useCaseSensitiveFileNames?(): boolean;
        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
        realpath?(path: string): string;
        /** @internal */ createHash?(data: string): string;
        readFile(path: string, encoding?: string): string | undefined;
        fileExists(path: string): boolean;
        getTypeRootsVersion?(): number;
        /** @deprecated supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext */
        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
        getResolvedModuleWithFailedLookupLocationsFromCache?(modulename: string, containingFile: string, resolutionMode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;
        /** @deprecated supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext */
        resolveTypeReferenceDirectives?(typeDirectiveNames: string[] | FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];
        resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
        resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
        /** @internal */ hasInvalidatedResolutions?: HasInvalidatedResolutions;
        /** @internal */ hasChangedAutomaticTypeDirectiveNames?: HasChangedAutomaticTypeDirectiveNames;
        /** @internal */ getGlobalTypingsCacheLocation?(): string | undefined;
        /** @internal */ getSymlinkCache?(files?: readonly SourceFile[]): SymlinkCache;
        /** @internal */ getModuleResolutionCache?(): ModuleResolutionCache | undefined;
        getDirectories?(directoryName: string): string[];
        /**
         * Gets a set of custom transformers to use during emit.
         */
        getCustomTransformers?(): CustomTransformers | undefined;
        isKnownTypesPackageName?(name: string): boolean;
        installPackage?(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;
        writeFile?(fileName: string, content: string): void;
        /** @internal */ getDocumentPositionMapper?(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined;
        /** @internal */ getSourceFileLike?(fileName: string): SourceFileLike | undefined;
        /** @internal */ getPackageJsonsVisibleToFile?(fileName: string, rootDir?: string): readonly ProjectPackageJsonInfo[];
        /** @internal */ getNearestAncestorDirectoryWithPackageJson?(fileName: string): string | undefined;
        /** @internal */ getPackageJsonsForAutoImport?(rootDir?: string): readonly ProjectPackageJsonInfo[];
        /** @internal */ getCachedExportInfoMap?(): ExportInfoMap;
        /** @internal */ getModuleSpecifierCache?(): ModuleSpecifierCache;
        /** @internal */ setCompilerHost?(host: CompilerHost): void;
        /** @internal */ useSourceOfProjectReferenceRedirect?(): boolean;
        /** @internal */ getPackageJsonAutoImportProvider?(): Program | undefined;
        /** @internal */ sendPerformanceEvent?(kind: PerformanceEvent["kind"], durationMs: number): void;
        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
        /** @internal */ onReleaseParsedCommandLine?(configFileName: string, oldResolvedRef: ResolvedProjectReference | undefined, optionOptions: CompilerOptions): void;
        /** @internal */ getIncompleteCompletionsCache?(): IncompleteCompletionsCache;
    }
    /** @internal */
    const emptyOptions: {};
    type WithMetadata<T> = T & {
        metadata?: unknown;
    };
    enum SemanticClassificationFormat {
        Original = "original",
        TwentyTwenty = "2020"
    }
    interface LanguageService {
        /** This is used as a part of restarting the language service. */
        cleanupSemanticCache(): void;
        /**
         * Gets errors indicating invalid syntax in a file.
         *
         * In English, "this cdeo have, erorrs" is syntactically invalid because it has typos,
         * grammatical errors, and misplaced punctuation. Likewise, examples of syntax
         * errors in TypeScript are missing parentheses in an `if` statement, mismatched
         * curly braces, and using a reserved keyword as a variable name.
         *
         * These diagnostics are inexpensive to compute and don't require knowledge of
         * other files. Note that a non-empty result increases the likelihood of false positives
         * from `getSemanticDiagnostics`.
         *
         * While these represent the majority of syntax-related diagnostics, there are some
         * that require the type system, which will be present in `getSemanticDiagnostics`.
         *
         * @param fileName A path to the file you want syntactic diagnostics for
         */
        getSyntacticDiagnostics(fileName: string): DiagnosticWithLocation[];
        /**
         * Gets warnings or errors indicating type system issues in a given file.
         * Requesting semantic diagnostics may start up the type system and
         * run deferred work, so the first call may take longer than subsequent calls.
         *
         * Unlike the other get*Diagnostics functions, these diagnostics can potentially not
         * include a reference to a source file. Specifically, the first time this is called,
         * it will return global diagnostics with no associated location.
         *
         * To contrast the differences between semantic and syntactic diagnostics, consider the
         * sentence: "The sun is green." is syntactically correct; those are real English words with
         * correct sentence structure. However, it is semantically invalid, because it is not true.
         *
         * @param fileName A path to the file you want semantic diagnostics for
         */
        getSemanticDiagnostics(fileName: string): Diagnostic[];
        /**
         * Gets suggestion diagnostics for a specific file. These diagnostics tend to
         * proactively suggest refactors, as opposed to diagnostics that indicate
         * potentially incorrect runtime behavior.
         *
         * @param fileName A path to the file you want semantic diagnostics for
         */
        getSuggestionDiagnostics(fileName: string): DiagnosticWithLocation[];
        /**
         * Gets global diagnostics related to the program configuration and compiler options.
         */
        getCompilerOptionsDiagnostics(): Diagnostic[];
        /** @deprecated Use getEncodedSyntacticClassifications instead. */
        getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];
        getSyntacticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];
        /** @deprecated Use getEncodedSemanticClassifications instead. */
        getSemanticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];
        getSemanticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];
        /** Encoded as triples of [start, length, ClassificationType]. */
        getEncodedSyntacticClassifications(fileName: string, span: TextSpan): Classifications;
        /**
         * Gets semantic highlights information for a particular file. Has two formats, an older
         * version used by VS and a format used by VS Code.
         *
         * @param fileName The path to the file
         * @param position A text span to return results within
         * @param format Which format to use, defaults to "original"
         * @returns a number array encoded as triples of [start, length, ClassificationType, ...].
         */
        getEncodedSemanticClassifications(fileName: string, span: TextSpan, format?: SemanticClassificationFormat): Classifications;
        /**
         * Gets completion entries at a particular position in a file.
         *
         * @param fileName The path to the file
         * @param position A zero-based index of the character where you want the entries
         * @param options An object describing how the request was triggered and what kinds
         * of code actions can be returned with the completions.
         * @param formattingSettings settings needed for calling formatting functions.
         */
        getCompletionsAtPosition(fileName: string, position: number, options: GetCompletionsAtPositionOptions | undefined, formattingSettings?: FormatCodeSettings): WithMetadata<CompletionInfo> | undefined;
        /**
         * Gets the extended details for a completion entry retrieved from `getCompletionsAtPosition`.
         *
         * @param fileName The path to the file
         * @param position A zero based index of the character where you want the entries
         * @param entryName The `name` from an existing completion which came from `getCompletionsAtPosition`
         * @param formatOptions How should code samples in the completions be formatted, can be undefined for backwards compatibility
         * @param source `source` property from the completion entry
         * @param preferences User settings, can be undefined for backwards compatibility
         * @param data `data` property from the completion entry
         */
        getCompletionEntryDetails(fileName: string, position: number, entryName: string, formatOptions: FormatCodeOptions | FormatCodeSettings | undefined, source: string | undefined, preferences: UserPreferences | undefined, data: CompletionEntryData | undefined): CompletionEntryDetails | undefined;
        getCompletionEntrySymbol(fileName: string, position: number, name: string, source: string | undefined): Symbol | undefined;
        /**
         * Gets semantic information about the identifier at a particular position in a
         * file. Quick info is what you typically see when you hover in an editor.
         *
         * @param fileName The path to the file
         * @param position A zero-based index of the character where you want the quick info
         */
        getQuickInfoAtPosition(fileName: string, position: number): QuickInfo | undefined;
        getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): TextSpan | undefined;
        getBreakpointStatementAtPosition(fileName: string, position: number): TextSpan | undefined;
        getSignatureHelpItems(fileName: string, position: number, options: SignatureHelpItemsOptions | undefined): SignatureHelpItems | undefined;
        getRenameInfo(fileName: string, position: number, preferences: UserPreferences): RenameInfo;
        /** @deprecated Use the signature with `UserPreferences` instead. */
        getRenameInfo(fileName: string, position: number, options?: RenameInfoOptions): RenameInfo;
        findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, providePrefixAndSuffixTextForRename?: boolean): readonly RenameLocation[] | undefined;
        getSmartSelectionRange(fileName: string, position: number): SelectionRange;
        /** @internal */
        getDefinitionAtPosition(fileName: string, position: number, searchOtherFilesOnly: false, stopAtAlias: boolean): readonly DefinitionInfo[] | undefined;
        /** @internal */
        getDefinitionAtPosition(fileName: string, position: number, searchOtherFilesOnly: boolean, stopAtAlias: false): readonly DefinitionInfo[] | undefined;
        getDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;
        getDefinitionAndBoundSpan(fileName: string, position: number): DefinitionInfoAndBoundSpan | undefined;
        getTypeDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;
        getImplementationAtPosition(fileName: string, position: number): readonly ImplementationLocation[] | undefined;
        getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[] | undefined;
        findReferences(fileName: string, position: number): ReferencedSymbol[] | undefined;
        getDocumentHighlights(fileName: string, position: number, filesToSearch: string[]): DocumentHighlights[] | undefined;
        getFileReferences(fileName: string): ReferenceEntry[];
        /** @deprecated */
        getOccurrencesAtPosition(fileName: string, position: number): readonly ReferenceEntry[] | undefined;
        getNavigateToItems(searchValue: string, maxResultCount?: number, fileName?: string, excludeDtsFiles?: boolean): NavigateToItem[];
        getNavigationBarItems(fileName: string): NavigationBarItem[];
        getNavigationTree(fileName: string): NavigationTree;
        prepareCallHierarchy(fileName: string, position: number): CallHierarchyItem | CallHierarchyItem[] | undefined;
        provideCallHierarchyIncomingCalls(fileName: string, position: number): CallHierarchyIncomingCall[];
        provideCallHierarchyOutgoingCalls(fileName: string, position: number): CallHierarchyOutgoingCall[];
        provideInlayHints(fileName: string, span: TextSpan, preferences: UserPreferences | undefined): InlayHint[];
        getOutliningSpans(fileName: string): OutliningSpan[];
        getTodoComments(fileName: string, descriptors: TodoCommentDescriptor[]): TodoComment[];
        getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[];
        getIndentationAtPosition(fileName: string, position: number, options: EditorOptions | EditorSettings): number;
        getFormattingEditsForRange(fileName: string, start: number, end: number, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
        getFormattingEditsForDocument(fileName: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
        getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
        getDocCommentTemplateAtPosition(fileName: string, position: number, options?: DocCommentTemplateOptions, formatOptions?: FormatCodeSettings): TextInsertion | undefined;
        isValidBraceCompletionAtPosition(fileName: string, position: number, openingBrace: number): boolean;
        /**
         * This will return a defined result if the position is after the `>` of the opening tag, or somewhere in the text, of a JSXElement with no closing tag.
         * Editors should call this after `>` is typed.
         */
        getJsxClosingTagAtPosition(fileName: string, position: number): JsxClosingTagInfo | undefined;
        getSpanOfEnclosingComment(fileName: string, position: number, onlyMultiLine: boolean): TextSpan | undefined;
        toLineColumnOffset?(fileName: string, position: number): LineAndCharacter;
        /** @internal */
        getSourceMapper(): SourceMapper;
        /** @internal */
        clearSourceMapperCache(): void;
        getCodeFixesAtPosition(fileName: string, start: number, end: number, errorCodes: readonly number[], formatOptions: FormatCodeSettings, preferences: UserPreferences): readonly CodeFixAction[];
        getCombinedCodeFix(scope: CombinedCodeFixScope, fixId: {}, formatOptions: FormatCodeSettings, preferences: UserPreferences): CombinedCodeActions;
        applyCodeActionCommand(action: CodeActionCommand, formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult>;
        applyCodeActionCommand(action: CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult[]>;
        applyCodeActionCommand(action: CodeActionCommand | CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;
        /** @deprecated `fileName` will be ignored */
        applyCodeActionCommand(fileName: string, action: CodeActionCommand): Promise<ApplyCodeActionCommandResult>;
        /** @deprecated `fileName` will be ignored */
        applyCodeActionCommand(fileName: string, action: CodeActionCommand[]): Promise<ApplyCodeActionCommandResult[]>;
        /** @deprecated `fileName` will be ignored */
        applyCodeActionCommand(fileName: string, action: CodeActionCommand | CodeActionCommand[]): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;
        getApplicableRefactors(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined, triggerReason?: RefactorTriggerReason, kind?: string): ApplicableRefactorInfo[];
        getEditsForRefactor(fileName: string, formatOptions: FormatCodeSettings, positionOrRange: number | TextRange, refactorName: string, actionName: string, preferences: UserPreferences | undefined): RefactorEditInfo | undefined;
        organizeImports(args: OrganizeImportsArgs, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];
        getEditsForFileRename(oldFilePath: string, newFilePath: string, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];
        getEmitOutput(fileName: string, emitOnlyDtsFiles?: boolean, forceDtsEmit?: boolean): EmitOutput;
        getProgram(): Program | undefined;
        /** @internal */ getCurrentProgram(): Program | undefined;
        /** @internal */ getNonBoundSourceFile(fileName: string): SourceFile;
        /** @internal */ getAutoImportProvider(): Program | undefined;
        /** @internal */ updateIsDefinitionOfReferencedSymbols(referencedSymbols: readonly ReferencedSymbol[], knownSymbolSpans: Set<DocumentSpan>): boolean;
        toggleLineComment(fileName: string, textRange: TextRange): TextChange[];
        toggleMultilineComment(fileName: string, textRange: TextRange): TextChange[];
        commentSelection(fileName: string, textRange: TextRange): TextChange[];
        uncommentSelection(fileName: string, textRange: TextRange): TextChange[];
        getSupportedCodeFixes(fileName?: string): readonly string[];
        dispose(): void;
    }
    interface JsxClosingTagInfo {
        readonly newText: string;
    }
    interface CombinedCodeFixScope {
        type: "file";
        fileName: string;
    }
    enum OrganizeImportsMode {
        All = "All",
        SortAndCombine = "SortAndCombine",
        RemoveUnused = "RemoveUnused"
    }
    interface OrganizeImportsArgs extends CombinedCodeFixScope {
        /** @deprecated Use `mode` instead */
        skipDestructiveCodeActions?: boolean;
        mode?: OrganizeImportsMode;
    }
    type CompletionsTriggerCharacter = "." | '"' | "'" | "`" | "/" | "@" | "<" | "#" | " ";
    enum CompletionTriggerKind {
        /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */
        Invoked = 1,
        /** Completion was triggered by a trigger character. */
        TriggerCharacter = 2,
        /** Completion was re-triggered as the current completion list is incomplete. */
        TriggerForIncompleteCompletions = 3
    }
    interface GetCompletionsAtPositionOptions extends UserPreferences {
        /**
         * If the editor is asking for completions because a certain character was typed
         * (as opposed to when the user explicitly requested them) this should be set.
         */
        triggerCharacter?: CompletionsTriggerCharacter;
        triggerKind?: CompletionTriggerKind;
        /**
         * Include a `symbol` property on each completion entry object.
         * Symbols reference cyclic data structures and sometimes an entire TypeChecker instance,
         * so use caution when serializing or retaining completion entries retrieved with this option.
         * @default false
         */
        includeSymbol?: boolean;
        /** @deprecated Use includeCompletionsForModuleExports */
        includeExternalModuleExports?: boolean;
        /** @deprecated Use includeCompletionsWithInsertText */
        includeInsertTextCompletions?: boolean;
    }
    type SignatureHelpTriggerCharacter = "," | "(" | "<";
    type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
    interface SignatureHelpItemsOptions {
        triggerReason?: SignatureHelpTriggerReason;
    }
    type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
    /**
     * Signals that the user manually requested signature help.
     * The language service will unconditionally attempt to provide a result.
     */
    interface SignatureHelpInvokedReason {
        kind: "invoked";
        triggerCharacter?: undefined;
    }
    /**
     * Signals that the signature help request came from a user typing a character.
     * Depending on the character and the syntactic context, the request may or may not be served a result.
     */
    interface SignatureHelpCharacterTypedReason {
        kind: "characterTyped";
        /**
         * Character that was responsible for triggering signature help.
         */
        triggerCharacter: SignatureHelpTriggerCharacter;
    }
    /**
     * Signals that this signature help request came from typing a character or moving the cursor.
     * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.
     * The language service will unconditionally attempt to provide a result.
     * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.
     */
    interface SignatureHelpRetriggeredReason {
        kind: "retrigger";
        /**
         * Character that was responsible for triggering signature help.
         */
        triggerCharacter?: SignatureHelpRetriggerCharacter;
    }
    interface ApplyCodeActionCommandResult {
        successMessage: string;
    }
    interface Classifications {
        spans: number[];
        endOfLineState: EndOfLineState;
    }
    interface ClassifiedSpan {
        textSpan: TextSpan;
        classificationType: ClassificationTypeNames;
    }
    interface ClassifiedSpan2020 {
        textSpan: TextSpan;
        classificationType: number;
    }
    /**
     * Navigation bar interface designed for visual studio's dual-column layout.
     * This does not form a proper tree.
     * The navbar is returned as a list of top-level items, each of which has a list of child items.
     * Child items always have an empty array for their `childItems`.
     */
    interface NavigationBarItem {
        text: string;
        kind: ScriptElementKind;
        kindModifiers: string;
        spans: TextSpan[];
        childItems: NavigationBarItem[];
        indent: number;
        bolded: boolean;
        grayed: boolean;
    }
    /**
     * Node in a tree of nested declarations in a file.
     * The top node is always a script or module node.
     */
    interface NavigationTree {
        /** Name of the declaration, or a short description, e.g. "<class>". */
        text: string;
        kind: ScriptElementKind;
        /** ScriptElementKindModifier separated by commas, e.g. "public,abstract" */
        kindModifiers: string;
        /**
         * Spans of the nodes that generated this declaration.
         * There will be more than one if this is the result of merging.
         */
        spans: TextSpan[];
        nameSpan: TextSpan | undefined;
        /** Present if non-empty */
        childItems?: NavigationTree[];
    }
    interface CallHierarchyItem {
        name: string;
        kind: ScriptElementKind;
        kindModifiers?: string;
        file: string;
        span: TextSpan;
        selectionSpan: TextSpan;
        containerName?: string;
    }
    interface CallHierarchyIncomingCall {
        from: CallHierarchyItem;
        fromSpans: TextSpan[];
    }
    interface CallHierarchyOutgoingCall {
        to: CallHierarchyItem;
        fromSpans: TextSpan[];
    }
    enum InlayHintKind {
        Type = "Type",
        Parameter = "Parameter",
        Enum = "Enum"
    }
    interface InlayHint {
        text: string;
        position: number;
        kind: InlayHintKind;
        whitespaceBefore?: boolean;
        whitespaceAfter?: boolean;
    }
    interface TodoCommentDescriptor {
        text: string;
        priority: number;
    }
    interface TodoComment {
        descriptor: TodoCommentDescriptor;
        message: string;
        position: number;
    }
    interface TextChange {
        span: TextSpan;
        newText: string;
    }
    interface FileTextChanges {
        fileName: string;
        textChanges: readonly TextChange[];
        isNewFile?: boolean;
    }
    interface CodeAction {
        /** Description of the code action to display in the UI of the editor */
        description: string;
        /** Text changes to apply to each file as part of the code action */
        changes: FileTextChanges[];
        /**
         * If the user accepts the code fix, the editor should send the action back in a `applyAction` request.
         * This allows the language service to have side effects (e.g. installing dependencies) upon a code fix.
         */
        commands?: CodeActionCommand[];
    }
    interface CodeFixAction extends CodeAction {
        /** Short name to identify the fix, for use by telemetry. */
        fixName: string;
        /**
         * If present, one may call 'getCombinedCodeFix' with this fixId.
         * This may be omitted to indicate that the code fix can't be applied in a group.
         */
        fixId?: {};
        fixAllDescription?: string;
    }
    interface CombinedCodeActions {
        changes: readonly FileTextChanges[];
        commands?: readonly CodeActionCommand[];
    }
    type CodeActionCommand = InstallPackageAction;
    interface InstallPackageAction {
        /** @internal */ readonly type: "install package";
        /** @internal */ readonly file: string;
        /** @internal */ readonly packageName: string;
    }
    /**
     * A set of one or more available refactoring actions, grouped under a parent refactoring.
     */
    interface ApplicableRefactorInfo {
        /**
         * The programmatic name of the refactoring
         */
        name: string;
        /**
         * A description of this refactoring category to show to the user.
         * If the refactoring gets inlined (see below), this text will not be visible.
         */
        description: string;
        /**
         * Inlineable refactorings can have their actions hoisted out to the top level
         * of a context menu. Non-inlineanable refactorings should always be shown inside
         * their parent grouping.
         *
         * If not specified, this value is assumed to be 'true'
         */
        inlineable?: boolean;
        actions: RefactorActionInfo[];
    }
    /**
     * Represents a single refactoring action - for example, the "Extract Method..." refactor might
     * offer several actions, each corresponding to a surround class or closure to extract into.
     */
    interface RefactorActionInfo {
        /**
         * The programmatic name of the refactoring action
         */
        name: string;
        /**
         * A description of this refactoring action to show to the user.
         * If the parent refactoring is inlined away, this will be the only text shown,
         * so this description should make sense by itself if the parent is inlineable=true
         */
        description: string;
        /**
         * A message to show to the user if the refactoring cannot be applied in
         * the current context.
         */
        notApplicableReason?: string;
        /**
         * The hierarchical dotted name of the refactor action.
         */
        kind?: string;
    }
    /**
     * A set of edits to make in response to a refactor action, plus an optional
     * location where renaming should be invoked from
     */
    interface RefactorEditInfo {
        edits: FileTextChanges[];
        renameFilename?: string;
        renameLocation?: number;
        commands?: CodeActionCommand[];
    }
    type RefactorTriggerReason = "implicit" | "invoked";
    interface TextInsertion {
        newText: string;
        /** The position in newText the caret should point to after the insertion. */
        caretOffset: number;
    }
    interface DocumentSpan {
        textSpan: TextSpan;
        fileName: string;
        /**
         * If the span represents a location that was remapped (e.g. via a .d.ts.map file),
         * then the original filename and span will be specified here
         */
        originalTextSpan?: TextSpan;
        originalFileName?: string;
        /**
         * If DocumentSpan.textSpan is the span for name of the declaration,
         * then this is the span for relevant declaration
         */
        contextSpan?: TextSpan;
        originalContextSpan?: TextSpan;
    }
    interface RenameLocation extends DocumentSpan {
        readonly prefixText?: string;
        readonly suffixText?: string;
    }
    interface ReferenceEntry extends DocumentSpan {
        isWriteAccess: boolean;
        isInString?: true;
    }
    interface ImplementationLocation extends DocumentSpan {
        kind: ScriptElementKind;
        displayParts: SymbolDisplayPart[];
    }
    enum HighlightSpanKind {
        none = "none",
        definition = "definition",
        reference = "reference",
        writtenReference = "writtenReference"
    }
    interface HighlightSpan {
        fileName?: string;
        isInString?: true;
        textSpan: TextSpan;
        contextSpan?: TextSpan;
        kind: HighlightSpanKind;
    }
    interface NavigateToItem {
        name: string;
        kind: ScriptElementKind;
        kindModifiers: string;
        matchKind: "exact" | "prefix" | "substring" | "camelCase";
        isCaseSensitive: boolean;
        fileName: string;
        textSpan: TextSpan;
        containerName: string;
        containerKind: ScriptElementKind;
    }
    enum IndentStyle {
        None = 0,
        Block = 1,
        Smart = 2
    }
    enum SemicolonPreference {
        Ignore = "ignore",
        Insert = "insert",
        Remove = "remove"
    }
    /** @deprecated - consider using EditorSettings instead */
    interface EditorOptions {
        BaseIndentSize?: number;
        IndentSize: number;
        TabSize: number;
        NewLineCharacter: string;
        ConvertTabsToSpaces: boolean;
        IndentStyle: IndentStyle;
    }
    interface EditorSettings {
        baseIndentSize?: number;
        indentSize?: number;
        tabSize?: number;
        newLineCharacter?: string;
        convertTabsToSpaces?: boolean;
        indentStyle?: IndentStyle;
        trimTrailingWhitespace?: boolean;
    }
    /** @deprecated - consider using FormatCodeSettings instead */
    interface FormatCodeOptions extends EditorOptions {
        InsertSpaceAfterCommaDelimiter: boolean;
        InsertSpaceAfterSemicolonInForStatements: boolean;
        InsertSpaceBeforeAndAfterBinaryOperators: boolean;
        InsertSpaceAfterConstructor?: boolean;
        InsertSpaceAfterKeywordsInControlFlowStatements: boolean;
        InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean;
        InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean;
        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean;
        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
        InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: boolean;
        InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
        InsertSpaceAfterTypeAssertion?: boolean;
        InsertSpaceBeforeFunctionParenthesis?: boolean;
        PlaceOpenBraceOnNewLineForFunctions: boolean;
        PlaceOpenBraceOnNewLineForControlBlocks: boolean;
        insertSpaceBeforeTypeAnnotation?: boolean;
    }
    interface FormatCodeSettings extends EditorSettings {
        readonly insertSpaceAfterCommaDelimiter?: boolean;
        readonly insertSpaceAfterSemicolonInForStatements?: boolean;
        readonly insertSpaceBeforeAndAfterBinaryOperators?: boolean;
        readonly insertSpaceAfterConstructor?: boolean;
        readonly insertSpaceAfterKeywordsInControlFlowStatements?: boolean;
        readonly insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
        readonly insertSpaceAfterTypeAssertion?: boolean;
        readonly insertSpaceBeforeFunctionParenthesis?: boolean;
        readonly placeOpenBraceOnNewLineForFunctions?: boolean;
        readonly placeOpenBraceOnNewLineForControlBlocks?: boolean;
        readonly insertSpaceBeforeTypeAnnotation?: boolean;
        readonly indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean;
        readonly semicolons?: SemicolonPreference;
    }
    /** @internal */
    const testFormatSettings: FormatCodeSettings;
    interface DefinitionInfo extends DocumentSpan {
        kind: ScriptElementKind;
        name: string;
        containerKind: ScriptElementKind;
        containerName: string;
        unverified?: boolean;
        /** @internal
         * Initially, this value is determined syntactically, but it is updated by the checker to cover
         * cases like declarations that are exported in subsequent statements.  As a result, the value
         * may be "incomplete" if this span has yet to be checked.
         */
        isLocal?: boolean;
        /** @internal */ isAmbient?: boolean;
        /** @internal */ failedAliasResolution?: boolean;
    }
    interface DefinitionInfoAndBoundSpan {
        definitions?: readonly DefinitionInfo[];
        textSpan: TextSpan;
    }
    interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {
        displayParts: SymbolDisplayPart[];
    }
    interface ReferencedSymbol {
        definition: ReferencedSymbolDefinitionInfo;
        references: ReferencedSymbolEntry[];
    }
    interface ReferencedSymbolEntry extends ReferenceEntry {
        isDefinition?: boolean;
    }
    enum SymbolDisplayPartKind {
        aliasName = 0,
        className = 1,
        enumName = 2,
        fieldName = 3,
        interfaceName = 4,
        keyword = 5,
        lineBreak = 6,
        numericLiteral = 7,
        stringLiteral = 8,
        localName = 9,
        methodName = 10,
        moduleName = 11,
        operator = 12,
        parameterName = 13,
        propertyName = 14,
        punctuation = 15,
        space = 16,
        text = 17,
        typeParameterName = 18,
        enumMemberName = 19,
        functionName = 20,
        regularExpressionLiteral = 21,
        link = 22,
        linkName = 23,
        linkText = 24
    }
    interface SymbolDisplayPart {
        text: string;
        kind: string;
    }
    interface JSDocLinkDisplayPart extends SymbolDisplayPart {
        target: DocumentSpan;
    }
    interface JSDocTagInfo {
        name: string;
        text?: SymbolDisplayPart[];
    }
    interface QuickInfo {
        kind: ScriptElementKind;
        kindModifiers: string;
        textSpan: TextSpan;
        displayParts?: SymbolDisplayPart[];
        documentation?: SymbolDisplayPart[];
        tags?: JSDocTagInfo[];
    }
    type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
    interface RenameInfoSuccess {
        canRename: true;
        /**
         * File or directory to rename.
         * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.
         */
        fileToRename?: string;
        displayName: string;
        fullDisplayName: string;
        kind: ScriptElementKind;
        kindModifiers: string;
        triggerSpan: TextSpan;
    }
    interface RenameInfoFailure {
        canRename: false;
        localizedErrorMessage: string;
    }
    /**
     * @deprecated Use `UserPreferences` instead.
     */
    interface RenameInfoOptions {
        readonly allowRenameOfImportPath?: boolean;
    }
    interface DocCommentTemplateOptions {
        readonly generateReturnInDocTemplate?: boolean;
    }
    interface SignatureHelpParameter {
        name: string;
        documentation: SymbolDisplayPart[];
        displayParts: SymbolDisplayPart[];
        isOptional: boolean;
        isRest?: boolean;
    }
    interface SelectionRange {
        textSpan: TextSpan;
        parent?: SelectionRange;
    }
    /**
     * Represents a single signature to show in signature help.
     * The id is used for subsequent calls into the language service to ask questions about the
     * signature help item in the context of any documents that have been updated.  i.e. after
     * an edit has happened, while signature help is still active, the host can ask important
     * questions like 'what parameter is the user currently contained within?'.
     */
    interface SignatureHelpItem {
        isVariadic: boolean;
        prefixDisplayParts: SymbolDisplayPart[];
        suffixDisplayParts: SymbolDisplayPart[];
        separatorDisplayParts: SymbolDisplayPart[];
        parameters: SignatureHelpParameter[];
        documentation: SymbolDisplayPart[];
        tags: JSDocTagInfo[];
    }
    /**
     * Represents a set of signature help items, and the preferred item that should be selected.
     */
    interface SignatureHelpItems {
        items: SignatureHelpItem[];
        applicableSpan: TextSpan;
        selectedItemIndex: number;
        argumentIndex: number;
        argumentCount: number;
    }
    enum CompletionInfoFlags {
        None = 0,
        MayIncludeAutoImports = 1,
        IsImportStatementCompletion = 2,
        IsContinuation = 4,
        ResolvedModuleSpecifiers = 8,
        ResolvedModuleSpecifiersBeyondLimit = 16,
        MayIncludeMethodSnippets = 32
    }
    interface CompletionInfo {
        /** For performance telemetry. */
        flags?: CompletionInfoFlags;
        /** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */
        isGlobalCompletion: boolean;
        isMemberCompletion: boolean;
        /**
         * In the absence of `CompletionEntry["replacementSpan"]`, the editor may choose whether to use
         * this span or its default one. If `CompletionEntry["replacementSpan"]` is defined, that span
         * must be used to commit that completion entry.
         */
        optionalReplacementSpan?: TextSpan;
        /**
         * true when the current location also allows for a new identifier
         */
        isNewIdentifierLocation: boolean;
        /**
         * Indicates to client to continue requesting completions on subsequent keystrokes.
         */
        isIncomplete?: true;
        entries: CompletionEntry[];
    }
    interface CompletionEntryDataAutoImport {
        /**
         * The name of the property or export in the module's symbol table. Differs from the completion name
         * in the case of InternalSymbolName.ExportEquals and InternalSymbolName.Default.
         */
        exportName: string;
        exportMapKey?: string;
        moduleSpecifier?: string;
        /** The file name declaring the export's module symbol, if it was an external module */
        fileName?: string;
        /** The module name (with quotes stripped) of the export's module symbol, if it was an ambient module */
        ambientModuleName?: string;
        /** True if the export was found in the package.json AutoImportProvider */
        isPackageJsonImport?: true;
    }
    interface CompletionEntryDataUnresolved extends CompletionEntryDataAutoImport {
        exportMapKey: string;
    }
    interface CompletionEntryDataResolved extends CompletionEntryDataAutoImport {
        moduleSpecifier: string;
    }
    type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;
    interface CompletionEntry {
        name: string;
        kind: ScriptElementKind;
        kindModifiers?: string;
        sortText: string;
        insertText?: string;
        isSnippet?: true;
        /**
         * An optional span that indicates the text to be replaced by this completion item.
         * If present, this span should be used instead of the default one.
         * It will be set if the required span differs from the one generated by the default replacement behavior.
         */
        replacementSpan?: TextSpan;
        hasAction?: true;
        source?: string;
        sourceDisplay?: SymbolDisplayPart[];
        labelDetails?: CompletionEntryLabelDetails;
        isRecommended?: true;
        isFromUncheckedFile?: true;
        isPackageJsonImport?: true;
        isImportStatementCompletion?: true;
        /**
         * For API purposes.
         * Included for non-string completions only when `includeSymbol: true` option is passed to `getCompletionsAtPosition`.
         * @example Get declaration of completion: `symbol.valueDeclaration`
         */
        symbol?: Symbol;
        /**
         * A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,
         * that allows TS Server to look up the symbol represented by the completion item, disambiguating
         * items with the same name. Currently only defined for auto-import completions, but the type is
         * `unknown` in the protocol, so it can be changed as needed to support other kinds of completions.
         * The presence of this property should generally not be used to assume that this completion entry
         * is an auto-import.
         */
        data?: CompletionEntryData;
    }
    interface CompletionEntryLabelDetails {
        detail?: string;
        description?: string;
    }
    interface CompletionEntryDetails {
        name: string;
        kind: ScriptElementKind;
        kindModifiers: string;
        displayParts: SymbolDisplayPart[];
        documentation?: SymbolDisplayPart[];
        tags?: JSDocTagInfo[];
        codeActions?: CodeAction[];
        /** @deprecated Use `sourceDisplay` instead. */
        source?: SymbolDisplayPart[];
        sourceDisplay?: SymbolDisplayPart[];
    }
    interface OutliningSpan {
        /** The span of the document to actually collapse. */
        textSpan: TextSpan;
        /** The span of the document to display when the user hovers over the collapsed span. */
        hintSpan: TextSpan;
        /** The text to display in the editor for the collapsed region. */
        bannerText: string;
        /**
         * Whether or not this region should be automatically collapsed when
         * the 'Collapse to Definitions' command is invoked.
         */
        autoCollapse: boolean;
        /**
         * Classification of the contents of the span
         */
        kind: OutliningSpanKind;
    }
    enum OutliningSpanKind {
        /** Single or multi-line comments */
        Comment = "comment",
        /** Sections marked by '// #region' and '// #endregion' comments */
        Region = "region",
        /** Declarations and expressions */
        Code = "code",
        /** Contiguous blocks of import declarations */
        Imports = "imports"
    }
    enum OutputFileType {
        JavaScript = 0,
        SourceMap = 1,
        Declaration = 2
    }
    enum EndOfLineState {
        None = 0,
        InMultiLineCommentTrivia = 1,
        InSingleQuoteStringLiteral = 2,
        InDoubleQuoteStringLiteral = 3,
        InTemplateHeadOrNoSubstitutionTemplate = 4,
        InTemplateMiddleOrTail = 5,
        InTemplateSubstitutionPosition = 6
    }
    enum TokenClass {
        Punctuation = 0,
        Keyword = 1,
        Operator = 2,
        Comment = 3,
        Whitespace = 4,
        Identifier = 5,
        NumberLiteral = 6,
        BigIntLiteral = 7,
        StringLiteral = 8,
        RegExpLiteral = 9
    }
    interface ClassificationResult {
        finalLexState: EndOfLineState;
        entries: ClassificationInfo[];
    }
    interface ClassificationInfo {
        length: number;
        classification: TokenClass;
    }
    interface Classifier {
        /**
         * Gives lexical classifications of tokens on a line without any syntactic context.
         * For instance, a token consisting of the text 'string' can be either an identifier
         * named 'string' or the keyword 'string', however, because this classifier is not aware,
         * it relies on certain heuristics to give acceptable results. For classifications where
         * speed trumps accuracy, this function is preferable; however, for true accuracy, the
         * syntactic classifier is ideal. In fact, in certain editing scenarios, combining the
         * lexical, syntactic, and semantic classifiers may issue the best user experience.
         *
         * @param text                      The text of a line to classify.
         * @param lexState                  The state of the lexical classifier at the end of the previous line.
         * @param syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.
         *                                  If there is no syntactic classifier (syntacticClassifierAbsent=true),
         *                                  certain heuristics may be used in its place; however, if there is a
         *                                  syntactic classifier (syntacticClassifierAbsent=false), certain
         *                                  classifications which may be incorrectly categorized will be given
         *                                  back as Identifiers in order to allow the syntactic classifier to
         *                                  subsume the classification.
         * @deprecated Use getLexicalClassifications instead.
         */
        getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;
        getEncodedLexicalClassifications(text: string, endOfLineState: EndOfLineState, syntacticClassifierAbsent: boolean): Classifications;
    }
    enum ScriptElementKind {
        unknown = "",
        warning = "warning",
        /** predefined type (void) or keyword (class) */
        keyword = "keyword",
        /** top level script node */
        scriptElement = "script",
        /** module foo {} */
        moduleElement = "module",
        /** class X {} */
        classElement = "class",
        /** var x = class X {} */
        localClassElement = "local class",
        /** interface Y {} */
        interfaceElement = "interface",
        /** type T = ... */
        typeElement = "type",
        /** enum E */
        enumElement = "enum",
        enumMemberElement = "enum member",
        /**
         * Inside module and script only
         * const v = ..
         */
        variableElement = "var",
        /** Inside function */
        localVariableElement = "local var",
        /**
         * Inside module and script only
         * function f() { }
         */
        functionElement = "function",
        /** Inside function */
        localFunctionElement = "local function",
        /** class X { [public|private]* foo() {} } */
        memberFunctionElement = "method",
        /** class X { [public|private]* [get|set] foo:number; } */
        memberGetAccessorElement = "getter",
        memberSetAccessorElement = "setter",
        /**
         * class X { [public|private]* foo:number; }
         * interface Y { foo:number; }
         */
        memberVariableElement = "property",
        /** class X { [public|private]* accessor foo: number; } */
        memberAccessorVariableElement = "accessor",
        /**
         * class X { constructor() { } }
         * class X { static { } }
         */
        constructorImplementationElement = "constructor",
        /** interface Y { ():number; } */
        callSignatureElement = "call",
        /** interface Y { []:number; } */
        indexSignatureElement = "index",
        /** interface Y { new():Y; } */
        constructSignatureElement = "construct",
        /** function foo(*Y*: string) */
        parameterElement = "parameter",
        typeParameterElement = "type parameter",
        primitiveType = "primitive type",
        label = "label",
        alias = "alias",
        constElement = "const",
        letElement = "let",
        directory = "directory",
        externalModuleName = "external module name",
        /**
         * <JsxTagName attribute1 attribute2={0} />
         * @deprecated
         */
        jsxAttribute = "JSX attribute",
        /** String literal */
        string = "string",
        /** Jsdoc @link: in `{@link C link text}`, the before and after text "{@link " and "}" */
        link = "link",
        /** Jsdoc @link: in `{@link C link text}`, the entity name "C" */
        linkName = "link name",
        /** Jsdoc @link: in `{@link C link text}`, the link text "link text" */
        linkText = "link text"
    }
    enum ScriptElementKindModifier {
        none = "",
        publicMemberModifier = "public",
        privateMemberModifier = "private",
        protectedMemberModifier = "protected",
        exportedModifier = "export",
        ambientModifier = "declare",
        staticModifier = "static",
        abstractModifier = "abstract",
        optionalModifier = "optional",
        deprecatedModifier = "deprecated",
        dtsModifier = ".d.ts",
        tsModifier = ".ts",
        tsxModifier = ".tsx",
        jsModifier = ".js",
        jsxModifier = ".jsx",
        jsonModifier = ".json",
        dmtsModifier = ".d.mts",
        mtsModifier = ".mts",
        mjsModifier = ".mjs",
        dctsModifier = ".d.cts",
        ctsModifier = ".cts",
        cjsModifier = ".cjs"
    }
    enum ClassificationTypeNames {
        comment = "comment",
        identifier = "identifier",
        keyword = "keyword",
        numericLiteral = "number",
        bigintLiteral = "bigint",
        operator = "operator",
        stringLiteral = "string",
        whiteSpace = "whitespace",
        text = "text",
        punctuation = "punctuation",
        className = "class name",
        enumName = "enum name",
        interfaceName = "interface name",
        moduleName = "module name",
        typeParameterName = "type parameter name",
        typeAliasName = "type alias name",
        parameterName = "parameter name",
        docCommentTagName = "doc comment tag name",
        jsxOpenTagName = "jsx open tag name",
        jsxCloseTagName = "jsx close tag name",
        jsxSelfClosingTagName = "jsx self closing tag name",
        jsxAttribute = "jsx attribute",
        jsxText = "jsx text",
        jsxAttributeStringLiteralValue = "jsx attribute string literal value"
    }
    enum ClassificationType {
        comment = 1,
        identifier = 2,
        keyword = 3,
        numericLiteral = 4,
        operator = 5,
        stringLiteral = 6,
        regularExpressionLiteral = 7,
        whiteSpace = 8,
        text = 9,
        punctuation = 10,
        className = 11,
        enumName = 12,
        interfaceName = 13,
        moduleName = 14,
        typeParameterName = 15,
        typeAliasName = 16,
        parameterName = 17,
        docCommentTagName = 18,
        jsxOpenTagName = 19,
        jsxCloseTagName = 20,
        jsxSelfClosingTagName = 21,
        jsxAttribute = 22,
        jsxText = 23,
        jsxAttributeStringLiteralValue = 24,
        bigintLiteral = 25
    }
    /** @internal */
    interface CodeFixRegistration {
        errorCodes: readonly number[];
        getCodeActions(context: CodeFixContext): CodeFixAction[] | undefined;
        fixIds?: readonly string[];
        getAllCodeActions?(context: CodeFixAllContext): CombinedCodeActions;
    }
    /** @internal */
    interface CodeFixContextBase extends textChanges.TextChangesContext {
        sourceFile: SourceFile;
        program: Program;
        cancellationToken: CancellationToken;
        preferences: UserPreferences;
    }
    /** @internal */
    interface CodeFixAllContext extends CodeFixContextBase {
        fixId: {};
    }
    /** @internal */
    interface CodeFixContext extends CodeFixContextBase {
        errorCode: number;
        span: TextSpan;
    }
    /** @internal */
    interface Refactor {
        /** List of action kinds a refactor can provide.
         * Used to skip unnecessary calculation when specific refactors are requested. */
        kinds?: string[];
        /** Compute the associated code actions */
        getEditsForAction(context: RefactorContext, actionName: string): RefactorEditInfo | undefined;
        /** Compute (quickly) which actions are available here */
        getAvailableActions(context: RefactorContext): readonly ApplicableRefactorInfo[];
    }
    /** @internal */
    interface RefactorContext extends textChanges.TextChangesContext {
        file: SourceFile;
        startPosition: number;
        endPosition?: number;
        program: Program;
        cancellationToken?: CancellationToken;
        preferences: UserPreferences;
        triggerReason?: RefactorTriggerReason;
        kind?: string;
    }
    interface InlayHintsContext {
        file: SourceFile;
        program: Program;
        cancellationToken: CancellationToken;
        host: LanguageServiceHost;
        span: TextSpan;
        preferences: UserPreferences;
    }
    /** @internal */
    function getMeaningFromDeclaration(node: Node): SemanticMeaning;
    /** @internal */
    function getMeaningFromLocation(node: Node): SemanticMeaning;
    /** @internal */
    function isInRightSideOfInternalImportEqualsDeclaration(node: Node): boolean;
    /** @internal */
    function isCallExpressionTarget(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
    /** @internal */
    function isNewExpressionTarget(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
    /** @internal */
    function isCallOrNewExpressionTarget(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
    /** @internal */
    function isTaggedTemplateTag(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
    /** @internal */
    function isDecoratorTarget(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
    /** @internal */
    function isJsxOpeningLikeElementTagName(node: Node, includeElementAccess?: boolean, skipPastOuterExpressions?: boolean): boolean;
    /** @internal */
    function climbPastPropertyAccess(node: Node): Node;
    /** @internal */
    function climbPastPropertyOrElementAccess(node: Node): Node;
    /** @internal */
    function getTargetLabel(referenceNode: Node, labelName: string): Identifier | undefined;
    /** @internal */
    function hasPropertyAccessExpressionWithName(node: CallExpression, funcName: string): boolean;
    /** @internal */
    function isJumpStatementTarget(node: Node): node is Identifier & {
        parent: BreakOrContinueStatement;
    };
    /** @internal */
    function isLabelOfLabeledStatement(node: Node): node is Identifier;
    /** @internal */
    function isLabelName(node: Node): boolean;
    /** @internal */
    function isTagName(node: Node): boolean;
    /** @internal */
    function isRightSideOfQualifiedName(node: Node): boolean;
    /** @internal */
    function isRightSideOfPropertyAccess(node: Node): boolean;
    /** @internal */
    function isArgumentExpressionOfElementAccess(node: Node): boolean;
    /** @internal */
    function isNameOfModuleDeclaration(node: Node): boolean;
    /** @internal */
    function isNameOfFunctionDeclaration(node: Node): boolean;
    /** @internal */
    function isLiteralNameOfPropertyDeclarationOrIndexAccess(node: StringLiteral | NumericLiteral | NoSubstitutionTemplateLiteral): boolean;
    /** @internal */
    function isExpressionOfExternalModuleImportEqualsDeclaration(node: Node): boolean;
    /** @internal */
    function getContainerNode(node: Node): Declaration | undefined;
    /** @internal */
    function getNodeKind(node: Node): ScriptElementKind;
    /** @internal */
    function isThis(node: Node): boolean;
    /** @internal */
    function getLineStartPositionForPosition(position: number, sourceFile: SourceFileLike): number;
    /** @internal */
    function rangeContainsRange(r1: TextRange, r2: TextRange): boolean;
    /** @internal */
    function rangeContainsRangeExclusive(r1: TextRange, r2: TextRange): boolean;
    /** @internal */
    function rangeContainsPosition(r: TextRange, pos: number): boolean;
    /** @internal */
    function rangeContainsPositionExclusive(r: TextRange, pos: number): boolean;
    /** @internal */
    function startEndContainsRange(start: number, end: number, range: TextRange): boolean;
    /** @internal */
    function rangeContainsStartEnd(range: TextRange, start: number, end: number): boolean;
    /** @internal */
    function rangeOverlapsWithStartEnd(r1: TextRange, start: number, end: number): boolean;
    /** @internal */
    function nodeOverlapsWithStartEnd(node: Node, sourceFile: SourceFile, start: number, end: number): boolean;
    /** @internal */
    function startEndOverlapsWithStartEnd(start1: number, end1: number, start2: number, end2: number): boolean;
    /**
     * Assumes `candidate.start <= position` holds.
     *
     * @internal
     */
    function positionBelongsToNode(candidate: Node, position: number, sourceFile: SourceFile): boolean;
    /** @internal */
    function findListItemInfo(node: Node): ListItemInfo | undefined;
    /** @internal */
    function hasChildOfKind(n: Node, kind: SyntaxKind, sourceFile: SourceFile): boolean;
    /** @internal */
    function findChildOfKind<T extends Node>(n: Node, kind: T["kind"], sourceFile: SourceFileLike): T | undefined;
    /** @internal */
    function findContainingList(node: Node): SyntaxList | undefined;
    /** @internal */
    function getContextualTypeFromParentOrAncestorTypeNode(node: Expression, checker: TypeChecker): Type | undefined;
    /**
     * Adjusts the location used for "find references" and "go to definition" when the cursor was not
     * on a property name.
     *
     * @internal
     */
    function getAdjustedReferenceLocation(node: Node): Node;
    /**
     * Adjusts the location used for "rename" when the cursor was not on a property name.
     *
     * @internal
     */
    function getAdjustedRenameLocation(node: Node): Node;
    /**
     * Gets the token whose text has range [start, end) and
     * position >= start and (position < end or (position === end && token is literal or keyword or identifier))
     *
     * @internal
     */
    function getTouchingPropertyName(sourceFile: SourceFile, position: number): Node;
    /**
     * Returns the token if position is in [start, end).
     * If position === end, returns the preceding token if includeItemAtEndPosition(previousToken) === true
     *
     * @internal
     */
    function getTouchingToken(sourceFile: SourceFile, position: number, includePrecedingTokenAtEndPosition?: (n: Node) => boolean): Node;
    /**
     * Returns a token if position is in [start-of-leading-trivia, end)
     *
     * @internal
     */
    function getTokenAtPosition(sourceFile: SourceFile, position: number): Node;
    /**
     * Returns the first token where position is in [start, end),
     * excluding `JsxText` tokens containing only whitespace.
     *
     * @internal
     */
    function findFirstNonJsxWhitespaceToken(sourceFile: SourceFile, position: number): Node | undefined;
    /**
     * The token on the left of the position is the token that strictly includes the position
     * or sits to the left of the cursor if it is on a boundary. For example
     *
     *   fo|o               -> will return foo
     *   foo <comment> |bar -> will return foo
     *
     *
     * @internal
     */
    function findTokenOnLeftOfPosition(file: SourceFile, position: number): Node | undefined;
    /** @internal */
    function findNextToken(previousToken: Node, parent: Node, sourceFile: SourceFileLike): Node | undefined;
    /**
     * Finds the rightmost token satisfying `token.end <= position`,
     * excluding `JsxText` tokens containing only whitespace.
     *
     * @internal
     */
    function findPrecedingToken(position: number, sourceFile: SourceFileLike, startNode: Node, excludeJsdoc?: boolean): Node | undefined;
    /** @internal */
    function findPrecedingToken(position: number, sourceFile: SourceFile, startNode?: Node, excludeJsdoc?: boolean): Node | undefined;
    /** @internal */
    function isInString(sourceFile: SourceFile, position: number, previousToken?: Node | undefined): boolean;
    /**
     *
     * @internal
     */
    function isInsideJsxElementOrAttribute(sourceFile: SourceFile, position: number): boolean;
    /** @internal */
    function isInTemplateString(sourceFile: SourceFile, position: number): boolean;
    /** @internal */
    function isInJSXText(sourceFile: SourceFile, position: number): boolean;
    /** @internal */
    function isInsideJsxElement(sourceFile: SourceFile, position: number): boolean;
    /** @internal */
    function findPrecedingMatchingToken(token: Node, matchingTokenKind: SyntaxKind.OpenBraceToken | SyntaxKind.OpenParenToken | SyntaxKind.OpenBracketToken, sourceFile: SourceFile): Node | undefined;
    /** @internal */
    function removeOptionality(type: Type, isOptionalExpression: boolean, isOptionalChain: boolean): Type;
    /** @internal */
    function isPossiblyTypeArgumentPosition(token: Node, sourceFile: SourceFile, checker: TypeChecker): boolean;
    /** @internal */
    function getPossibleGenericSignatures(called: Expression, typeArgumentCount: number, checker: TypeChecker): readonly Signature[];
    /** @internal */
    function getPossibleTypeArgumentsInfo(tokenIn: Node | undefined, sourceFile: SourceFile): PossibleTypeArgumentInfo | undefined;
    /**
     * Returns true if the cursor at position in sourceFile is within a comment.
     *
     * @param tokenAtPosition Must equal `getTokenAtPosition(sourceFile, position)`
     * @param predicate Additional predicate to test on the comment range.
     *
     * @internal
     */
    function isInComment(sourceFile: SourceFile, position: number, tokenAtPosition?: Node): CommentRange | undefined;
    /** @internal */
    function hasDocComment(sourceFile: SourceFile, position: number): boolean;
    /** @internal */
    function getNodeModifiers(node: Node, excludeFlags?: ModifierFlags): string;
    /** @internal */
    function getTypeArgumentOrTypeParameterList(node: Node): NodeArray<Node> | undefined;
    /** @internal */
    function isComment(kind: SyntaxKind): boolean;
    /** @internal */
    function isStringOrRegularExpressionOrTemplateLiteral(kind: SyntaxKind): boolean;
    /** @internal */
    function isStringAndEmptyAnonymousObjectIntersection(type: Type): boolean | 0;
    /** @internal */
    function isPunctuation(kind: SyntaxKind): boolean;
    /** @internal */
    function isInsideTemplateLiteral(node: TemplateLiteralToken, position: number, sourceFile: SourceFile): boolean;
    /** @internal */
    function isAccessibilityModifier(kind: SyntaxKind): boolean;
    /** @internal */
    function cloneCompilerOptions(options: CompilerOptions): CompilerOptions;
    /** @internal */
    function isArrayLiteralOrObjectLiteralDestructuringPattern(node: Node): boolean;
    /** @internal */
    function isInReferenceComment(sourceFile: SourceFile, position: number): boolean;
    /** @internal */
    function isInNonReferenceComment(sourceFile: SourceFile, position: number): boolean;
    /** @internal */
    function getReplacementSpanForContextToken(contextToken: Node | undefined): TextSpan | undefined;
    /** @internal */
    function createTextSpanFromNode(node: Node, sourceFile?: SourceFile, endNode?: Node): TextSpan;
    /** @internal */
    function createTextSpanFromStringLiteralLikeContent(node: StringLiteralLike): TextSpan | undefined;
    /** @internal */
    function createTextRangeFromNode(node: Node, sourceFile: SourceFile): TextRange;
    /** @internal */
    function createTextSpanFromRange(range: TextRange): TextSpan;
    /** @internal */
    function createTextRangeFromSpan(span: TextSpan): TextRange;
    /** @internal */
    function createTextChangeFromStartLength(start: number, length: number, newText: string): TextChange;
    /** @internal */
    function createTextChange(span: TextSpan, newText: string): TextChange;
    /** @internal */
    function isTypeKeyword(kind: SyntaxKind): boolean;
    /** @internal */
    function isTypeKeywordToken(node: Node): node is Token<SyntaxKind.TypeKeyword>;
    /** @internal */
    function isTypeKeywordTokenOrIdentifier(node: Node): boolean;
    /**
     * True if the symbol is for an external module, as opposed to a namespace.
     *
     * @internal
     */
    function isExternalModuleSymbol(moduleSymbol: Symbol): boolean;
    /** @internal */
    function nodeSeenTracker<T extends Node>(): NodeSeenTracker<T>;
    /** @internal */
    function getSnapshotText(snap: IScriptSnapshot): string;
    /** @internal */
    function repeatString(str: string, count: number): string;
    /** @internal */
    function skipConstraint(type: Type): Type;
    /** @internal */
    function getNameFromPropertyName(name: PropertyName): string | undefined;
    /** @internal */
    function programContainsModules(program: Program): boolean;
    /** @internal */
    function programContainsEsModules(program: Program): boolean;
    /** @internal */
    function compilerOptionsIndicateEsModules(compilerOptions: CompilerOptions): boolean;
    /** @internal */
    function createModuleSpecifierResolutionHost(program: Program, host: LanguageServiceHost): ModuleSpecifierResolutionHost;
    /** @internal */
    function getModuleSpecifierResolverHost(program: Program, host: LanguageServiceHost): SymbolTracker["moduleResolverHost"];
    /** @internal */
    function moduleResolutionUsesNodeModules(moduleResolution: ModuleResolutionKind): boolean;
    /** @internal */
    function makeImportIfNecessary(defaultImport: Identifier | undefined, namedImports: readonly ImportSpecifier[] | undefined, moduleSpecifier: string, quotePreference: QuotePreference): ImportDeclaration | undefined;
    /** @internal */
    function makeImport(defaultImport: Identifier | undefined, namedImports: readonly ImportSpecifier[] | undefined, moduleSpecifier: string | Expression, quotePreference: QuotePreference, isTypeOnly?: boolean): ImportDeclaration;
    /** @internal */
    function makeStringLiteral(text: string, quotePreference: QuotePreference): StringLiteral;
    /** @internal */
    function quotePreferenceFromString(str: StringLiteral, sourceFile: SourceFile): QuotePreference;
    /** @internal */
    function getQuotePreference(sourceFile: SourceFile, preferences: UserPreferences): QuotePreference;
    /** @internal */
    function getQuoteFromPreference(qp: QuotePreference): string;
    /** @internal */
    function symbolNameNoDefault(symbol: Symbol): string | undefined;
    /** @internal */
    function symbolEscapedNameNoDefault(symbol: Symbol): __String | undefined;
    /** @internal */
    function isModuleSpecifierLike(node: Node): node is StringLiteralLike;
    /** @internal */
    function isObjectBindingElementWithoutPropertyName(bindingElement: Node): bindingElement is ObjectBindingElementWithoutPropertyName;
    /** @internal */
    function getPropertySymbolFromBindingElement(checker: TypeChecker, bindingElement: ObjectBindingElementWithoutPropertyName): Symbol | undefined;
    /** @internal */
    function getParentNodeInSpan(node: Node | undefined, file: SourceFile, span: TextSpan): Node | undefined;
    /** @internal */
    function findModifier(node: Node, kind: Modifier["kind"]): Modifier | undefined;
    /** @internal */
    function insertImports(changes: textChanges.ChangeTracker, sourceFile: SourceFile, imports: AnyImportOrRequireStatement | readonly AnyImportOrRequireStatement[], blankLineBetween: boolean, preferences: UserPreferences): void;
    /** @internal */
    function getTypeKeywordOfTypeOnlyImport(importClause: ImportClause, sourceFile: SourceFile): Token<SyntaxKind.TypeKeyword>;
    /** @internal */
    function textSpansEqual(a: TextSpan | undefined, b: TextSpan | undefined): boolean;
    /** @internal */
    function documentSpansEqual(a: DocumentSpan, b: DocumentSpan): boolean;
    /**
     * Iterates through 'array' by index and performs the callback on each element of array until the callback
     * returns a truthy value, then returns that value.
     * If no such value is found, the callback is applied to each element of array and undefined is returned.
     *
     * @internal
     */
    function forEachUnique<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U): U | undefined;
    /** @internal */
    function isTextWhiteSpaceLike(text: string, startPos: number, endPos: number): boolean;
    /** @internal */
    function getMappedLocation(location: DocumentPosition, sourceMapper: SourceMapper, fileExists: ((path: string) => boolean) | undefined): DocumentPosition | undefined;
    /** @internal */
    function getMappedDocumentSpan(documentSpan: DocumentSpan, sourceMapper: SourceMapper, fileExists?: (path: string) => boolean): DocumentSpan | undefined;
    /** @internal */
    function getMappedContextSpan(documentSpan: DocumentSpan, sourceMapper: SourceMapper, fileExists?: (path: string) => boolean): TextSpan | undefined;
    /** @internal */
    function isFirstDeclarationOfSymbolParameter(symbol: Symbol): boolean;
    /** @internal */
    function symbolPart(text: string, symbol: Symbol): SymbolDisplayPart;
    /** @internal */
    function displayPart(text: string, kind: SymbolDisplayPartKind): SymbolDisplayPart;
    /** @internal */
    function spacePart(): SymbolDisplayPart;
    /** @internal */
    function keywordPart(kind: SyntaxKind): SymbolDisplayPart;
    /** @internal */
    function punctuationPart(kind: SyntaxKind): SymbolDisplayPart;
    /** @internal */
    function operatorPart(kind: SyntaxKind): SymbolDisplayPart;
    /** @internal */
    function parameterNamePart(text: string): SymbolDisplayPart;
    /** @internal */
    function propertyNamePart(text: string): SymbolDisplayPart;
    /** @internal */
    function textOrKeywordPart(text: string): SymbolDisplayPart;
    /** @internal */
    function textPart(text: string): SymbolDisplayPart;
    /** @internal */
    function typeAliasNamePart(text: string): SymbolDisplayPart;
    /** @internal */
    function typeParameterNamePart(text: string): SymbolDisplayPart;
    /** @internal */
    function linkTextPart(text: string): SymbolDisplayPart;
    /** @internal */
    function linkNamePart(text: string, target: Declaration): JSDocLinkDisplayPart;
    /** @internal */
    function linkPart(text: string): SymbolDisplayPart;
    /** @internal */
    function buildLinkParts(link: JSDocLink | JSDocLinkCode | JSDocLinkPlain, checker?: TypeChecker): SymbolDisplayPart[];
    /**
     * The default is LF.
     *
     * @internal
     */
    function getNewLineOrDefaultFromHost(host: FormattingHost, formatSettings: FormatCodeSettings | undefined): string;
    /** @internal */
    function lineBreakPart(): SymbolDisplayPart;
    /** @internal */
    function mapToDisplayParts(writeDisplayParts: (writer: DisplayPartsSymbolWriter) => void): SymbolDisplayPart[];
    /** @internal */
    function typeToDisplayParts(typechecker: TypeChecker, type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): SymbolDisplayPart[];
    /** @internal */
    function symbolToDisplayParts(typeChecker: TypeChecker, symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): SymbolDisplayPart[];
    /** @internal */
    function signatureToDisplayParts(typechecker: TypeChecker, signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags): SymbolDisplayPart[];
    /** @internal */
    function nodeToDisplayParts(node: Node, enclosingDeclaration: Node): SymbolDisplayPart[];
    /** @internal */
    function isImportOrExportSpecifierName(location: Node): location is Identifier;
    /** @internal */
    function getScriptKind(fileName: string, host: LanguageServiceHost): ScriptKind;
    /** @internal */
    function getSymbolTarget(symbol: Symbol, checker: TypeChecker): Symbol;
    /** @internal */
    function getUniqueSymbolId(symbol: Symbol, checker: TypeChecker): number;
    /** @internal */
    function getFirstNonSpaceCharacterPosition(text: string, position: number): number;
    /** @internal */
    function getPrecedingNonSpaceCharacterPosition(text: string, position: number): number;
    /**
     * Creates a deep, memberwise clone of a node with no source map location.
     *
     * WARNING: This is an expensive operation and is only intended to be used in refactorings
     * and code fixes (because those are triggered by explicit user actions).
     *
     * @internal
     */
    function getSynthesizedDeepClone<T extends Node | undefined>(node: T, includeTrivia?: boolean): T;
    /** @internal */
    function getSynthesizedDeepCloneWithReplacements<T extends Node>(node: T, includeTrivia: boolean, replaceNode: (node: Node) => Node | undefined): T;
    /** @internal */
    function getSynthesizedDeepClones<T extends Node>(nodes: NodeArray<T>, includeTrivia?: boolean): NodeArray<T>;
    /** @internal */
    function getSynthesizedDeepClones<T extends Node>(nodes: NodeArray<T> | undefined, includeTrivia?: boolean): NodeArray<T> | undefined;
    /** @internal */
    function getSynthesizedDeepClonesWithReplacements<T extends Node>(nodes: NodeArray<T>, includeTrivia: boolean, replaceNode: (node: Node) => Node | undefined): NodeArray<T>;
    /**
     * Sets EmitFlags to suppress leading and trailing trivia on the node.
     *
     * @internal
     */
    function suppressLeadingAndTrailingTrivia(node: Node): void;
    /**
     * Sets EmitFlags to suppress leading trivia on the node.
     *
     * @internal
     */
    function suppressLeadingTrivia(node: Node): void;
    /**
     * Sets EmitFlags to suppress trailing trivia on the node.
     *
     * @internal
     */
    function suppressTrailingTrivia(node: Node): void;
    /** @internal */
    function copyComments(sourceNode: Node, targetNode: Node): void;
    /** @internal */
    function getUniqueName(baseName: string, sourceFile: SourceFile): string;
    /**
     * @return The index of the (only) reference to the extracted symbol.  We want the cursor
     * to be on the reference, rather than the declaration, because it's closer to where the
     * user was before extracting it.
     *
     * @internal
     */
    function getRenameLocation(edits: readonly FileTextChanges[], renameFilename: string, name: string, preferLastLocation: boolean): number;
    /** @internal */
    function copyLeadingComments(sourceNode: Node, targetNode: Node, sourceFile: SourceFile, commentKind?: CommentKind, hasTrailingNewLine?: boolean): void;
    /** @internal */
    function copyTrailingComments(sourceNode: Node, targetNode: Node, sourceFile: SourceFile, commentKind?: CommentKind, hasTrailingNewLine?: boolean): void;
    /**
     * This function copies the trailing comments for the token that comes before `sourceNode`, as leading comments of `targetNode`.
     * This is useful because sometimes a comment that refers to `sourceNode` will be a leading comment for `sourceNode`, according to the
     * notion of trivia ownership, and instead will be a trailing comment for the token before `sourceNode`, e.g.:
     * `function foo(\* not leading comment for a *\ a: string) {}`
     * The comment refers to `a` but belongs to the `(` token, but we might want to copy it.
     *
     * @internal
     */
    function copyTrailingAsLeadingComments(sourceNode: Node, targetNode: Node, sourceFile: SourceFile, commentKind?: CommentKind, hasTrailingNewLine?: boolean): void;
    /** @internal */
    function needsParentheses(expression: Expression): boolean;
    /** @internal */
    function getContextualTypeFromParent(node: Expression, checker: TypeChecker, contextFlags?: ContextFlags): Type | undefined;
    /** @internal */
    function quote(sourceFile: SourceFile, preferences: UserPreferences, text: string): string;
    /** @internal */
    function isEqualityOperatorKind(kind: SyntaxKind): kind is EqualityOperator;
    /** @internal */
    function isStringLiteralOrTemplate(node: Node): node is StringLiteralLike | TemplateExpression | TaggedTemplateExpression;
    /** @internal */
    function hasIndexSignature(type: Type): boolean;
    /** @internal */
    function getSwitchedType(caseClause: CaseClause, checker: TypeChecker): Type | undefined;
    /** @internal */
    function getTypeNodeIfAccessible(type: Type, enclosingScope: Node, program: Program, host: LanguageServiceHost): TypeNode | undefined;
    /** @internal */
    function syntaxRequiresTrailingSemicolonOrASI(kind: SyntaxKind): boolean;
    /** @internal */
    function positionIsASICandidate(pos: number, context: Node, sourceFile: SourceFileLike): boolean;
    /** @internal */
    function probablyUsesSemicolons(sourceFile: SourceFile): boolean;
    /** @internal */
    function tryGetDirectories(host: Pick<LanguageServiceHost, "getDirectories">, directoryName: string): string[];
    /** @internal */
    function tryReadDirectory(host: Pick<LanguageServiceHost, "readDirectory">, path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[]): readonly string[];
    /** @internal */
    function tryFileExists(host: Pick<LanguageServiceHost, "fileExists">, path: string): boolean;
    /** @internal */
    function tryDirectoryExists(host: LanguageServiceHost, path: string): boolean;
    /** @internal */
    function tryAndIgnoreErrors<T>(cb: () => T): T | undefined;
    /** @internal */
    function tryIOAndConsumeErrors<T>(host: unknown, toApply: ((...a: any[]) => T) | undefined, ...args: any[]): any;
    /** @internal */
    function findPackageJsons(startDirectory: string, host: Pick<LanguageServiceHost, "fileExists">, stopDirectory?: string): string[];
    /** @internal */
    function findPackageJson(directory: string, host: LanguageServiceHost): string | undefined;
    /** @internal */
    function getPackageJsonsVisibleToFile(fileName: string, host: LanguageServiceHost): readonly ProjectPackageJsonInfo[];
    /** @internal */
    function createPackageJsonInfo(fileName: string, host: {
        readFile?(fileName: string): string | undefined;
    }): ProjectPackageJsonInfo | undefined;
    /** @internal */
    function createPackageJsonImportFilter(fromFile: SourceFile, preferences: UserPreferences, host: LanguageServiceHost): PackageJsonImportFilter;
    /** @internal */
    function consumesNodeCoreModules(sourceFile: SourceFile): boolean;
    /** @internal */
    function isInsideNodeModules(fileOrDirectory: string): boolean;
    /** @internal */
    function isDiagnosticWithLocation(diagnostic: Diagnostic): diagnostic is DiagnosticWithLocation;
    /** @internal */
    function findDiagnosticForNode(node: Node, sortedFileDiagnostics: readonly Diagnostic[]): DiagnosticWithLocation | undefined;
    /** @internal */
    function getDiagnosticsWithinSpan(span: TextSpan, sortedFileDiagnostics: readonly Diagnostic[]): readonly DiagnosticWithLocation[];
    /** @internal */
    function getRefactorContextSpan({ startPosition, endPosition }: RefactorContext): TextSpan;
    /** @internal */
    function getFixableErrorSpanExpression(sourceFile: SourceFile, span: TextSpan): Expression | undefined;
    /**
     * If the provided value is an array, the mapping function is applied to each element; otherwise, the mapping function is applied
     * to the provided value itself.
     *
     * @internal
     */
    function mapOneOrMany<T, U>(valueOrArray: T | readonly T[], f: (x: T, i: number) => U): U | U[];
    /** @internal */
    function mapOneOrMany<T, U>(valueOrArray: T | readonly T[] | undefined, f: (x: T, i: number) => U): U | U[] | undefined;
    /** @internal */
    function mapOneOrMany<T, U>(valueOrArray: T | readonly T[], f: (x: T, i: number) => U, resultSelector: (x: U[]) => U): U;
    /** @internal */
    function mapOneOrMany<T, U>(valueOrArray: T | readonly T[] | undefined, f: (x: T, i: number) => U, resultSelector: (x: U[]) => U): U | undefined;
    /**
     * If the provided value is an array, the first element of the array is returned; otherwise, the provided value is returned instead.
     *
     * @internal
     */
    function firstOrOnly<T>(valueOrArray: T | readonly T[]): T;
    /** @internal */
    function getNamesForExportedSymbol(symbol: Symbol, scriptTarget: ScriptTarget | undefined): string | [
        lowercase: string,
        capitalized: string
    ];
    /** @internal */
    function getNameForExportedSymbol(symbol: Symbol, scriptTarget: ScriptTarget | undefined, preferCapitalized?: boolean): string;
    /**
     * Useful to check whether a string contains another string at a specific index
     * without allocating another string or traversing the entire contents of the outer string.
     *
     * This function is useful in place of either of the following:
     *
     * ```ts
     * // Allocates
     * haystack.substr(startIndex, needle.length) === needle
     *
     * // Full traversal
     * haystack.indexOf(needle, startIndex) === startIndex
     * ```
     *
     * @param haystack The string that potentially contains `needle`.
     * @param needle The string whose content might sit within `haystack`.
     * @param startIndex The index within `haystack` to start searching for `needle`.
     *
     * @internal
     */
    function stringContainsAt(haystack: string, needle: string, startIndex: number): boolean;
    /** @internal */
    function startsWithUnderscore(name: string): boolean;
    /** @internal */
    function isGlobalDeclaration(declaration: Declaration): boolean;
    /** @internal */
    function isNonGlobalDeclaration(declaration: Declaration): boolean;
    /** @internal */
    function isDeprecatedDeclaration(decl: Declaration): boolean;
    /** @internal */
    function shouldUseUriStyleNodeCoreModules(file: SourceFile, program: Program): boolean;
    /** @internal */
    function getNewLineKind(newLineCharacter: string): NewLineKind;
    /** @internal */
    function diagnosticToString(diag: DiagnosticAndArguments): string;
    /**
     * Get format code settings for a code writing context (e.g. when formatting text changes or completions code).
     *
     * @internal
     */
    function getFormatCodeSettingsForWriting({ options }: formatting.FormatContext, sourceFile: SourceFile): FormatCodeSettings;
    /** @internal */
    function jsxModeNeedsExplicitImport(jsx: JsxEmit | undefined): boolean;
    /** @internal */
    function isSourceFileFromLibrary(program: Program, node: SourceFile): boolean;
    /** @internal */
    function newCaseClauseTracker(checker: TypeChecker, clauses: readonly (CaseClause | DefaultClause)[]): CaseClauseTracker;
    /** @internal */
    const scanner: Scanner;
    /** @internal */
    enum SemanticMeaning {
        None = 0,
        Value = 1,
        Type = 2,
        Namespace = 4,
        All = 7
    }
    /** @internal */
    interface ListItemInfo {
        listItemIndex: number;
        list: Node;
    }
    /** @internal */
    interface PossibleTypeArgumentInfo {
        readonly called: Identifier;
        readonly nTypeArguments: number;
    }
    /** @internal */
    interface PossibleProgramFileInfo {
        ProgramFiles?: string[];
    }
    /** @internal */
    const typeKeywords: readonly SyntaxKind[];
    /**
     * Returns `true` the first time it encounters a node and `false` afterwards.
     *
     * @internal
     */
    type NodeSeenTracker<T = Node> = (node: T) => boolean;
    /** @internal */
    enum QuotePreference {
        Single = 0,
        Double = 1
    }
    /** @internal */
    type ObjectBindingElementWithoutPropertyName = BindingElement & {
        name: Identifier;
    };
    /** @internal */
    const ANONYMOUS = "anonymous function";
    /** @internal */
    const syntaxMayBeASICandidate: (kind: SyntaxKind) => boolean;
    /** @internal */
    interface PackageJsonImportFilter {
        allowsImportingAmbientModule: (moduleSymbol: Symbol, moduleSpecifierResolutionHost: ModuleSpecifierResolutionHost) => boolean;
        allowsImportingSourceFile: (sourceFile: SourceFile, moduleSpecifierResolutionHost: ModuleSpecifierResolutionHost) => boolean;
        /**
         * Use for a specific module specifier that has already been resolved.
         * Use `allowsImportingAmbientModule` or `allowsImportingSourceFile` to resolve
         * the best module specifier for a given module _and_ determine if it’s importable.
         */
        allowsImportingSpecifier: (moduleSpecifier: string) => boolean;
    }
    /** @internal */
    type DiagnosticAndArguments = DiagnosticMessage | [
        DiagnosticMessage,
        string
    ] | [
        DiagnosticMessage,
        string,
        string
    ];
    /** @internal */
    interface CaseClauseTracker {
        addValue(value: string | number): void;
        hasValue(value: string | number | PseudoBigInt): boolean;
    }
    /** @internal */
    function createCacheableExportInfoMap(host: CacheableExportInfoMapHost): ExportInfoMap;
    /** @internal */
    function isImportableFile(program: Program, from: SourceFile, to: SourceFile, preferences: UserPreferences, packageJsonFilter: PackageJsonImportFilter | undefined, moduleSpecifierResolutionHost: ModuleSpecifierResolutionHost, moduleSpecifierCache: ModuleSpecifierCache | undefined): boolean;
    /** @internal */
    function forEachExternalModuleToImportFrom(program: Program, host: LanguageServiceHost, preferences: UserPreferences, useAutoImportProvider: boolean, cb: (module: Symbol, moduleFile: SourceFile | undefined, program: Program, isFromPackageJson: boolean) => void): void;
    /** @internal */
    function getExportInfoMap(importingFile: SourceFile, host: LanguageServiceHost, program: Program, preferences: UserPreferences, cancellationToken: CancellationToken | undefined): ExportInfoMap;
    /** @internal */
    function getDefaultLikeExportInfo(moduleSymbol: Symbol, checker: TypeChecker, compilerOptions: CompilerOptions): {
        resolvedSymbol: Symbol;
        name: string;
        symbol: Symbol;
        exportKind: ExportKind;
    } | undefined;
    /** @internal */
    function getDefaultExportInfoWorker(defaultExport: Symbol, checker: TypeChecker, compilerOptions: CompilerOptions): {
        readonly resolvedSymbol: Symbol;
        readonly name: string;
    } | undefined;
    /** @internal */
    enum ImportKind {
        Named = 0,
        Default = 1,
        Namespace = 2,
        CommonJS = 3
    }
    /** @internal */
    enum ExportKind {
        Named = 0,
        Default = 1,
        ExportEquals = 2,
        UMD = 3
    }
    /** @internal */
    interface SymbolExportInfo {
        readonly symbol: Symbol;
        readonly moduleSymbol: Symbol;
        /** Set if `moduleSymbol` is an external module, not an ambient module */
        moduleFileName: string | undefined;
        exportKind: ExportKind;
        targetFlags: SymbolFlags;
        /** True if export was only found via the package.json AutoImportProvider (for telemetry). */
        isFromPackageJson: boolean;
    }
    /** @internal */
    interface ExportInfoMap {
        isUsableByFile(importingFile: Path): boolean;
        clear(): void;
        add(importingFile: Path, symbol: Symbol, key: __String, moduleSymbol: Symbol, moduleFile: SourceFile | undefined, exportKind: ExportKind, isFromPackageJson: boolean, checker: TypeChecker): void;
        get(importingFile: Path, key: string): readonly SymbolExportInfo[] | undefined;
        search<T>(importingFile: Path, preferCapitalized: boolean, matches: (name: string, targetFlags: SymbolFlags) => boolean, action: (info: readonly SymbolExportInfo[], symbolName: string, isFromAmbientModule: boolean, key: string) => T | undefined): T | undefined;
        releaseSymbols(): void;
        isEmpty(): boolean;
        /** @returns Whether the change resulted in the cache being cleared */
        onFileChanged(oldSourceFile: SourceFile, newSourceFile: SourceFile, typeAcquisitionEnabled: boolean): boolean;
    }
    /** @internal */
    interface CacheableExportInfoMapHost {
        getCurrentProgram(): Program | undefined;
        getPackageJsonAutoImportProvider(): Program | undefined;
        getGlobalTypingsCacheLocation(): string | undefined;
    }
    /** The classifier is used for syntactic highlighting in editors via the TSServer */
    function createClassifier(): Classifier;
    /** @internal */
    function getSemanticClassifications(typeChecker: TypeChecker, cancellationToken: CancellationToken, sourceFile: SourceFile, classifiableNames: ReadonlySet<__String>, span: TextSpan): ClassifiedSpan[];
    /** @internal */
    function getEncodedSemanticClassifications(typeChecker: TypeChecker, cancellationToken: CancellationToken, sourceFile: SourceFile, classifiableNames: ReadonlySet<__String>, span: TextSpan): Classifications;
    /** @internal */
    function getSyntacticClassifications(cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): ClassifiedSpan[];
    /** @internal */
    function getEncodedSyntacticClassifications(cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): Classifications;
    interface DocumentHighlights {
        fileName: string;
        highlightSpans: HighlightSpan[];
    }
    /** @internal */
    namespace DocumentHighlights {
        function getDocumentHighlights(program: Program, cancellationToken: CancellationToken, sourceFile: SourceFile, position: number, sourceFilesToSearch: readonly SourceFile[]): DocumentHighlights[] | undefined;
    }
    function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string): DocumentRegistry;
    /** @internal */
    function createDocumentRegistryInternal(useCaseSensitiveFileNames?: boolean, currentDirectory?: string, externalCache?: ExternalDocumentCache): DocumentRegistry;
    /**
     * The document registry represents a store of SourceFile objects that can be shared between
     * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)
     * of files in the context.
     * SourceFile objects account for most of the memory usage by the language service. Sharing
     * the same DocumentRegistry instance between different instances of LanguageService allow
     * for more efficient memory utilization since all projects will share at least the library
     * file (lib.d.ts).
     *
     * A more advanced use of the document registry is to serialize sourceFile objects to disk
     * and re-hydrate them when needed.
     *
     * To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it
     * to all subsequent createLanguageService calls.
     */
    interface DocumentRegistry {
        /**
         * Request a stored SourceFile with a given fileName and compilationSettings.
         * The first call to acquire will call createLanguageServiceSourceFile to generate
         * the SourceFile if was not found in the registry.
         *
         * @param fileName The name of the file requested
         * @param compilationSettingsOrHost Some compilation settings like target affects the
         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store
         * multiple copies of the same file for different compilation settings. A minimal
         * resolution cache is needed to fully define a source file's shape when
         * the compilation settings include `module: node16`+, so providing a cache host
         * object should be preferred. A common host is a language service `ConfiguredProject`.
         * @param scriptSnapshot Text of the file. Only used if the file was not found
         * in the registry and a new one was created.
         * @param version Current version of the file. Only used if the file was not found
         * in the registry and a new one was created.
         */
        acquireDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
        acquireDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
        /**
         * Request an updated version of an already existing SourceFile with a given fileName
         * and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile
         * to get an updated SourceFile.
         *
         * @param fileName The name of the file requested
         * @param compilationSettingsOrHost Some compilation settings like target affects the
         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store
         * multiple copies of the same file for different compilation settings. A minimal
         * resolution cache is needed to fully define a source file's shape when
         * the compilation settings include `module: node16`+, so providing a cache host
         * object should be preferred. A common host is a language service `ConfiguredProject`.
         * @param scriptSnapshot Text of the file.
         * @param version Current version of the file.
         */
        updateDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
        updateDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
        getKeyForCompilationSettings(settings: CompilerOptions): DocumentRegistryBucketKey;
        /**
         * Informs the DocumentRegistry that a file is not needed any longer.
         *
         * Note: It is not allowed to call release on a SourceFile that was not acquired from
         * this registry originally.
         *
         * @param fileName The name of the file to be released
         * @param compilationSettings The compilation settings used to acquire the file
         * @param scriptKind The script kind of the file to be released
         *
         * @deprecated pass scriptKind and impliedNodeFormat for correctness
         */
        releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind?: ScriptKind): void;
        /**
         * Informs the DocumentRegistry that a file is not needed any longer.
         *
         * Note: It is not allowed to call release on a SourceFile that was not acquired from
         * this registry originally.
         *
         * @param fileName The name of the file to be released
         * @param compilationSettings The compilation settings used to acquire the file
         * @param scriptKind The script kind of the file to be released
         * @param impliedNodeFormat The implied source file format of the file to be released
         */
        releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind: ScriptKind, impliedNodeFormat: ResolutionMode): void;
        /**
         * @deprecated pass scriptKind for and impliedNodeFormat correctness */
        releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind?: ScriptKind): void;
        releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind: ScriptKind, impliedNodeFormat: ResolutionMode): void;
        /** @internal */
        getLanguageServiceRefCounts(path: Path, scriptKind: ScriptKind): [
            string,
            number | undefined
        ][];
        reportStats(): string;
    }
    /** @internal */
    interface ExternalDocumentCache {
        setDocument(key: DocumentRegistryBucketKeyWithMode, path: Path, sourceFile: SourceFile): void;
        getDocument(key: DocumentRegistryBucketKeyWithMode, path: Path): SourceFile | undefined;
    }
    type DocumentRegistryBucketKey = string & {
        __bucketKey: any;
    };
    /** @internal */
    type DocumentRegistryBucketKeyWithMode = string & {
        __documentRegistryBucketKeyWithMode: any;
    };
    /** @internal */
    function getEditsForFileRename(program: Program, oldFileOrDirPath: string, newFileOrDirPath: string, host: LanguageServiceHost, formatContext: formatting.FormatContext, preferences: UserPreferences, sourceMapper: SourceMapper): readonly FileTextChanges[];
    /** @internal */
    function getPathUpdater(oldFileOrDirPath: string, newFileOrDirPath: string, getCanonicalFileName: GetCanonicalFileName, sourceMapper: SourceMapper | undefined): PathUpdater;
    /**
     * If 'path' refers to an old directory, returns path in the new directory.
     *
     * @internal
     */
    type PathUpdater = (path: string) => string | undefined;
    /** @internal */
    function createPatternMatcher(pattern: string): PatternMatcher | undefined;
    /** @internal */
    function breakIntoCharacterSpans(identifier: string): TextSpan[];
    /** @internal */
    function breakIntoWordSpans(identifier: string): TextSpan[];
    /** @internal */
    enum PatternMatchKind {
        exact = 0,
        prefix = 1,
        substring = 2,
        camelCase = 3
    }
    /** @internal */
    interface PatternMatch {
        kind: PatternMatchKind;
        isCaseSensitive: boolean;
    }
    /** @internal */
    interface PatternMatcher {
        getMatchForLastSegmentOfPattern(candidate: string): PatternMatch | undefined;
        getFullMatch(candidateContainers: readonly string[], candidate: string): PatternMatch | undefined;
        patternContainsDots: boolean;
    }
    function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;
    /** @internal */
    function getSourceMapper(host: SourceMapperHost): SourceMapper;
    /** @internal */
    function getDocumentPositionMapper(host: DocumentPositionMapperHost, generatedFileName: string, generatedFileLineInfo: LineInfo, readMapFile: ReadMapFile): ts.DocumentPositionMapper | undefined;
    /** @internal */
    interface SourceMapper {
        toLineColumnOffset(fileName: string, position: number): LineAndCharacter;
        tryGetSourcePosition(info: DocumentPosition): DocumentPosition | undefined;
        tryGetGeneratedPosition(info: DocumentPosition): DocumentPosition | undefined;
        clearCache(): void;
    }
    /** @internal */
    interface SourceMapperHost {
        useCaseSensitiveFileNames(): boolean;
        getCurrentDirectory(): string;
        getProgram(): Program | undefined;
        fileExists?(path: string): boolean;
        readFile?(path: string, encoding?: string): string | undefined;
        getSourceFileLike?(fileName: string): SourceFileLike | undefined;
        getDocumentPositionMapper?(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined;
        log(s: string): void;
    }
    /**
     * string | undefined to contents of map file to create DocumentPositionMapper from it
     * DocumentPositionMapper | false to give back cached DocumentPositionMapper
     *
     * @internal
     */
    type ReadMapFile = (mapFileName: string, mapFileNameFromDts: string | undefined) => string | undefined | DocumentPositionMapper | false;
    /** @internal */
    function computeSuggestionDiagnostics(sourceFile: SourceFile, program: Program, cancellationToken: CancellationToken): DiagnosticWithLocation[];
    /** @internal */
    function returnsPromise(node: FunctionLikeDeclaration, checker: TypeChecker): boolean;
    /** @internal */
    function isReturnStatementWithFixablePromiseHandler(node: Node, checker: TypeChecker): node is ReturnStatement & {
        expression: CallExpression;
    };
    /** @internal */
    function isFixablePromiseHandler(node: Node, checker: TypeChecker): boolean;
    /** @internal */
    function canBeConvertedToAsync(node: Node): node is FunctionDeclaration | MethodDeclaration | FunctionExpression | ArrowFunction;
    function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;
    function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;
    /**
     * JS users may pass in string values for enum compiler options (such as ModuleKind), so convert.
     *
     * @internal
     */
    function fixupCompilerOptions(options: CompilerOptions, diagnostics: Diagnostic[]): CompilerOptions;
    interface TranspileOptions {
        compilerOptions?: CompilerOptions;
        fileName?: string;
        reportDiagnostics?: boolean;
        moduleName?: string;
        renamedDependencies?: MapLike<string>;
        transformers?: CustomTransformers;
    }
    interface TranspileOutput {
        outputText: string;
        diagnostics?: Diagnostic[];
        sourceMapText?: string;
    }
    /** @internal */
    function toEditorSettings(options: FormatCodeOptions | FormatCodeSettings): FormatCodeSettings;
    function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;
    function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;
    function getDefaultCompilerOptions(): CompilerOptions;
    function getSupportedCodeFixes(): readonly string[];
    function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTargetOrOptions: ScriptTarget | CreateSourceFileOptions, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;
    function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;
    function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;
    /**
     * Names in the name table are escaped, so an identifier `__foo` will have a name table entry `___foo`.
     *
     * @internal
     */
    function getNameTable(sourceFile: SourceFile): UnderscoreEscapedMap<number>;
    /**
     * Returns the containing object literal property declaration given a possible name node, e.g. "a" in x = { "a": 1 }
     *
     * @internal
     */
    function getContainingObjectLiteralElement(node: Node): ObjectLiteralElementWithName | undefined;
    /**
     * Gets all symbols for one property. Does not get symbols for every property.
     *
     * @internal
     */
    function getPropertySymbolsFromContextualType(node: ObjectLiteralElementWithName, checker: TypeChecker, contextualType: Type, unionSymbolOk: boolean): readonly Symbol[];
    /**
     * Get the path of the default library files (lib.d.ts) as distributed with the typescript
     * node package.
     * The functionality is not supported if the ts module is consumed outside of a node module.
     */
    function getDefaultLibFilePath(options: CompilerOptions): string;
    /** The version of the language service API */
    const servicesVersion = "0.8";
    /** @internal */
    interface DisplayPartsSymbolWriter extends EmitTextWriter {
        displayParts(): SymbolDisplayPart[];
    }
    /**
     * A cancellation that throttles calls to the host
     *
     * @internal
     */
    class ThrottledCancellationToken implements CancellationToken {
        private hostCancellationToken;
        private readonly throttleWaitMilliseconds;
        private lastCancellationCheckTime;
        constructor(hostCancellationToken: HostCancellationToken, throttleWaitMilliseconds?: number);
        isCancellationRequested(): boolean;
        throwIfCancellationRequested(): void;
    }
    /** @internal */
    type ObjectLiteralElementWithName = ObjectLiteralElement & {
        name: PropertyName;
        parent: ObjectLiteralExpression | JsxAttributes;
    };
    /**
     * Transform one or more nodes using the supplied transformers.
     * @param source A single `Node` or an array of `Node` objects.
     * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.
     * @param compilerOptions Optional compiler options.
     */
    function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;
    /** @internal */
    function realizeDiagnostics(diagnostics: readonly Diagnostic[], newLine: string): RealizedDiagnostic[];
    /** @internal */
    interface ScriptSnapshotShim {
        /** Gets a portion of the script snapshot specified by [start, end). */
        getText(start: number, end: number): string;
        /** Gets the length of this script snapshot. */
        getLength(): number;
        /**
         * Returns a JSON-encoded value of the type:
         *   { span: { start: number; length: number }; newLength: number }
         *
         * Or undefined value if there was no change.
         */
        getChangeRange(oldSnapshot: ScriptSnapshotShim): string | undefined;
        /** Releases all resources held by this script snapshot */
        dispose?(): void;
    }
    /** @internal */
    interface Logger {
        log(s: string): void;
        trace(s: string): void;
        error(s: string): void;
    }
    /**
     * Public interface of the host of a language service shim instance.
     *
     * @internal
     */
    interface LanguageServiceShimHost extends Logger {
        getCompilationSettings(): string;
        /** Returns a JSON-encoded value of the type: string[] */
        getScriptFileNames(): string;
        getScriptKind?(fileName: string): ScriptKind;
        getScriptVersion(fileName: string): string;
        getScriptSnapshot(fileName: string): ScriptSnapshotShim;
        getLocalizedDiagnosticMessages(): string;
        getCancellationToken(): HostCancellationToken;
        getCurrentDirectory(): string;
        getDirectories(path: string): string;
        getDefaultLibFileName(options: string): string;
        getNewLine?(): string;
        getProjectVersion?(): string;
        useCaseSensitiveFileNames?(): boolean;
        getTypeRootsVersion?(): number;
        readDirectory(rootDir: string, extension: string, basePaths?: string, excludeEx?: string, includeFileEx?: string, includeDirEx?: string, depth?: number): string;
        readFile(path: string, encoding?: string): string | undefined;
        fileExists(path: string): boolean;
        getModuleResolutionsForFile?(fileName: string): string;
        getTypeReferenceDirectiveResolutionsForFile?(fileName: string): string;
        directoryExists(directoryName: string): boolean;
    }
    /**
     * Public interface of the core-services host instance used in managed side
     *
     * @internal
     */
    interface CoreServicesShimHost extends Logger {
        directoryExists(directoryName: string): boolean;
        fileExists(fileName: string): boolean;
        getCurrentDirectory(): string;
        getDirectories(path: string): string;
        /**
         * Returns a JSON-encoded value of the type: string[]
         *
         * @param exclude A JSON encoded string[] containing the paths to exclude
         *  when enumerating the directory.
         */
        readDirectory(rootDir: string, extension: string, basePaths?: string, excludeEx?: string, includeFileEx?: string, includeDirEx?: string, depth?: number): string;
        /**
         * Read arbitrary text files on disk, i.e. when resolution procedure needs the content of 'package.json' to determine location of bundled typings for node modules
         */
        readFile(fileName: string): string | undefined;
        realpath?(path: string): string;
        trace(s: string): void;
        useCaseSensitiveFileNames?(): boolean;
    }
    /** @internal */
    interface ShimsFileReference {
        path: string;
        position: number;
        length: number;
    }
    /**
     * Public interface of a language service instance shim.
     *
     * @internal
     */
    interface ShimFactory {
        registerShim(shim: Shim): void;
        unregisterShim(shim: Shim): void;
    }
    /** @internal */
    interface Shim {
        dispose(_dummy: {}): void;
    }
    /** @internal */
    interface LanguageServiceShim extends Shim {
        languageService: LanguageService;
        dispose(_dummy: {}): void;
        refresh(throwOnError: boolean): void;
        cleanupSemanticCache(): void;
        getSyntacticDiagnostics(fileName: string): string;
        getSemanticDiagnostics(fileName: string): string;
        getSuggestionDiagnostics(fileName: string): string;
        getCompilerOptionsDiagnostics(): string;
        getSyntacticClassifications(fileName: string, start: number, length: number): string;
        getSemanticClassifications(fileName: string, start: number, length: number, format?: SemanticClassificationFormat): string;
        getEncodedSyntacticClassifications(fileName: string, start: number, length: number): string;
        getEncodedSemanticClassifications(fileName: string, start: number, length: number, format?: SemanticClassificationFormat): string;
        getCompletionsAtPosition(fileName: string, position: number, preferences: UserPreferences | undefined, formattingSettings: FormatCodeSettings | undefined): string;
        getCompletionEntryDetails(fileName: string, position: number, entryName: string, formatOptions: string | undefined, source: string | undefined, preferences: UserPreferences | undefined, data: CompletionEntryData | undefined): string;
        getQuickInfoAtPosition(fileName: string, position: number): string;
        getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): string;
        getBreakpointStatementAtPosition(fileName: string, position: number): string;
        getSignatureHelpItems(fileName: string, position: number, options: SignatureHelpItemsOptions | undefined): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { canRename: boolean, localizedErrorMessage: string, displayName: string, fullDisplayName: string, kind: string, kindModifiers: string, triggerSpan: { start; length } }
         */
        getRenameInfo(fileName: string, position: number, preferences: UserPreferences): string;
        getSmartSelectionRange(fileName: string, position: number): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { fileName: string, textSpan: { start: number, length: number } }[]
         */
        findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, providePrefixAndSuffixTextForRename?: boolean): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { fileName: string; textSpan: { start: number; length: number}; kind: string; name: string; containerKind: string; containerName: string }
         *
         * Or undefined value if no definition can be found.
         */
        getDefinitionAtPosition(fileName: string, position: number): string;
        getDefinitionAndBoundSpan(fileName: string, position: number): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { fileName: string; textSpan: { start: number; length: number}; kind: string; name: string; containerKind: string; containerName: string }
         *
         * Or undefined value if no definition can be found.
         */
        getTypeDefinitionAtPosition(fileName: string, position: number): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { fileName: string; textSpan: { start: number; length: number}; }[]
         */
        getImplementationAtPosition(fileName: string, position: number): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { fileName: string; textSpan: { start: number; length: number}; isWriteAccess: boolean, isDefinition?: boolean }[]
         */
        getReferencesAtPosition(fileName: string, position: number): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { definition: <encoded>; references: <encoded>[] }[]
         */
        findReferences(fileName: string, position: number): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { fileName: string; textSpan: { start: number; length: number}; isWriteAccess: boolean, isDefinition?: boolean }[]
         */
        getFileReferences(fileName: string): string;
        /**
         * @deprecated
         * Returns a JSON-encoded value of the type:
         * { fileName: string; textSpan: { start: number; length: number}; isWriteAccess: boolean }[]
         */
        getOccurrencesAtPosition(fileName: string, position: number): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { fileName: string; highlights: { start: number; length: number }[] }[]
         *
         * @param fileToSearch A JSON encoded string[] containing the file names that should be
         *  considered when searching.
         */
        getDocumentHighlights(fileName: string, position: number, filesToSearch: string): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { name: string; kind: string; kindModifiers: string; containerName: string; containerKind: string; matchKind: string; fileName: string; textSpan: { start: number; length: number}; } [] = [];
         */
        getNavigateToItems(searchValue: string, maxResultCount?: number, fileName?: string): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { text: string; kind: string; kindModifiers: string; bolded: boolean; grayed: boolean; indent: number; spans: { start: number; length: number; }[]; childItems: <recursive use of this type>[] } [] = [];
         */
        getNavigationBarItems(fileName: string): string;
        /** Returns a JSON-encoded value of the type ts.NavigationTree. */
        getNavigationTree(fileName: string): string;
        /**
         * Returns a JSON-encoded value of the type:
         * { textSpan: { start: number, length: number }; hintSpan: { start: number, length: number }; bannerText: string; autoCollapse: boolean } [] = [];
         */
        getOutliningSpans(fileName: string): string;
        getTodoComments(fileName: string, todoCommentDescriptors: string): string;
        getBraceMatchingAtPosition(fileName: string, position: number): string;
        getIndentationAtPosition(fileName: string, position: number, options: string): string;
        getFormattingEditsForRange(fileName: string, start: number, end: number, options: string): string;
        getFormattingEditsForDocument(fileName: string, options: string): string;
        getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: string): string;
        /**
         * Returns JSON-encoded value of the type TextInsertion.
         */
        getDocCommentTemplateAtPosition(fileName: string, position: number, options?: DocCommentTemplateOptions, formatOptions?: FormatCodeSettings): string;
        /**
         * Returns JSON-encoded boolean to indicate whether we should support brace location
         * at the current position.
         * E.g. we don't want brace completion inside string-literals, comments, etc.
         */
        isValidBraceCompletionAtPosition(fileName: string, position: number, openingBrace: number): string;
        /**
         * Returns a JSON-encoded TextSpan | undefined indicating the range of the enclosing comment, if it exists.
         */
        getSpanOfEnclosingComment(fileName: string, position: number, onlyMultiLine: boolean): string;
        prepareCallHierarchy(fileName: string, position: number): string;
        provideCallHierarchyIncomingCalls(fileName: string, position: number): string;
        provideCallHierarchyOutgoingCalls(fileName: string, position: number): string;
        provideInlayHints(fileName: string, span: TextSpan, preference: UserPreferences | undefined): string;
        getEmitOutput(fileName: string): string;
        getEmitOutputObject(fileName: string): EmitOutput;
        toggleLineComment(fileName: string, textChange: TextRange): string;
        toggleMultilineComment(fileName: string, textChange: TextRange): string;
        commentSelection(fileName: string, textChange: TextRange): string;
        uncommentSelection(fileName: string, textChange: TextRange): string;
    }
    /** @internal */
    interface ClassifierShim extends Shim {
        getEncodedLexicalClassifications(text: string, lexState: EndOfLineState, syntacticClassifierAbsent?: boolean): string;
        getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent?: boolean): string;
    }
    /** @internal */
    interface CoreServicesShim extends Shim {
        getAutomaticTypeDirectiveNames(compilerOptionsJson: string): string;
        getPreProcessedFileInfo(fileName: string, sourceText: IScriptSnapshot): string;
        getTSConfigFileInfo(fileName: string, sourceText: IScriptSnapshot): string;
        getDefaultCompilationSettings(): string;
        discoverTypings(discoverTypingsJson: string): string;
    }
    /** @internal */
    class LanguageServiceShimHostAdapter implements LanguageServiceHost {
        private shimHost;
        private loggingEnabled;
        private tracingEnabled;
        resolveModuleNames: ((moduleName: string[], containingFile: string) => (ResolvedModuleFull | undefined)[]) | undefined;
        resolveTypeReferenceDirectives: ((typeDirectiveNames: string[] | readonly FileReference[], containingFile: string) => (ResolvedTypeReferenceDirective | undefined)[]) | undefined;
        directoryExists: ((directoryName: string) => boolean) | undefined;
        constructor(shimHost: LanguageServiceShimHost);
        log(s: string): void;
        trace(s: string): void;
        error(s: string): void;
        getProjectVersion(): string;
        getTypeRootsVersion(): number;
        useCaseSensitiveFileNames(): boolean;
        getCompilationSettings(): CompilerOptions;
        getScriptFileNames(): string[];
        getScriptSnapshot(fileName: string): IScriptSnapshot | undefined;
        getScriptKind(fileName: string): ScriptKind;
        getScriptVersion(fileName: string): string;
        getLocalizedDiagnosticMessages(): any;
        getCancellationToken(): HostCancellationToken;
        getCurrentDirectory(): string;
        getDirectories(path: string): string[];
        getDefaultLibFileName(options: CompilerOptions): string;
        readDirectory(path: string, extensions?: readonly string[], exclude?: string[], include?: string[], depth?: number): string[];
        readFile(path: string, encoding?: string): string | undefined;
        fileExists(path: string): boolean;
    }
    /** @internal */
    class CoreServicesShimHostAdapter implements ParseConfigHost, ModuleResolutionHost, JsTyping.TypingResolutionHost {
        private shimHost;
        directoryExists: (directoryName: string) => boolean;
        realpath: (path: string) => string;
        useCaseSensitiveFileNames: boolean;
        constructor(shimHost: CoreServicesShimHost);
        readDirectory(rootDir: string, extensions: readonly string[], exclude: readonly string[], include: readonly string[], depth?: number): string[];
        fileExists(fileName: string): boolean;
        readFile(fileName: string): string | undefined;
        getDirectories(path: string): string[];
    }
    /** @internal */
    interface RealizedDiagnostic {
        message: string;
        start: number;
        length: number;
        category: string;
        code: number;
        reportsUnnecessary?: {};
        reportsDeprecated?: {};
    }
    /** @internal */
    class TypeScriptServicesFactory implements ShimFactory {
        private _shims;
        private documentRegistry;
        getServicesVersion(): string;
        createLanguageServiceShim(host: LanguageServiceShimHost): LanguageServiceShim;
        createClassifierShim(logger: Logger): ClassifierShim;
        createCoreServicesShim(host: CoreServicesShimHost): CoreServicesShim;
        close(): void;
        registerShim(shim: Shim): void;
        unregisterShim(shim: Shim): void;
    }
    /** @internal */
    function createOverload<T extends OverloadDefinitions>(name: string, overloads: T, binder: OverloadBinders<T>, deprecations?: OverloadDeprecations<T>): UnionToIntersection<T[keyof T]>;
    /** @internal */
    function buildOverload(name: string): OverloadBuilder;
    /** @internal */
    interface DeprecationOptions {
        message?: string;
        error?: boolean;
        since?: Version | string;
        warnAfter?: Version | string;
        errorAfter?: Version | string;
        typeScriptVersion?: Version | string;
        name?: string;
    }
    /**
     * Defines a list of overloads by ordinal
     *
     * @internal
     */
    type OverloadDefinitions = {
        readonly [P in number]: (...args: any[]) => any;
    };
    /**
     * Extracts the ordinals from an set of overload definitions.
     *
     * @internal
     */
    type OverloadKeys<T extends OverloadDefinitions> = Extract<keyof T, number>;
    /**
     * Extracts a union of the potential parameter lists for each overload.
     *
     * @internal
     */
    type OverloadParameters<T extends OverloadDefinitions> = Parameters<{
        [P in OverloadKeys<T>]: T[P];
    }[OverloadKeys<T>]>;
    /**
     * Constructs an intersection of each overload in a set of overload definitions.
     *
     * @internal
     */
    type OverloadFunction<T extends OverloadDefinitions> = UnionToIntersection<T[keyof T]>;
    /**
     * Maps each ordinal in a set of overload definitions to a function that can be used to bind its arguments.
     *
     * @internal
     */
    type OverloadBinders<T extends OverloadDefinitions> = {
        [P in OverloadKeys<T>]: (args: OverloadParameters<T>) => boolean | undefined;
    };
    /**
     * Defines deprecations for specific overloads by ordinal.
     *
     * @internal
     */
    type OverloadDeprecations<T extends OverloadDefinitions> = {
        [P in OverloadKeys<T>]?: DeprecationOptions;
    };
    /** @internal */
    interface OverloadBuilder {
        overload<T extends OverloadDefinitions>(overloads: T): BindableOverloadBuilder<T>;
    }
    /** @internal */
    interface BindableOverloadBuilder<T extends OverloadDefinitions> {
        bind(binder: OverloadBinders<T>): BoundOverloadBuilder<T>;
    }
    /** @internal */
    interface FinishableOverloadBuilder<T extends OverloadDefinitions> {
        finish(): OverloadFunction<T>;
    }
    /** @internal */
    interface BoundOverloadBuilder<T extends OverloadDefinitions> extends FinishableOverloadBuilder<T> {
        deprecate(deprecations: OverloadDeprecations<T>): FinishableOverloadBuilder<T>;
    }
}
export = ts;